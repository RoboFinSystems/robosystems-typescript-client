// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type { RegisterUserData, RegisterUserResponses, RegisterUserErrors, LoginUserData, LoginUserResponses, LoginUserErrors, LogoutUserData, LogoutUserResponses, GetCurrentAuthUserData, GetCurrentAuthUserResponses, GetCurrentAuthUserErrors, RefreshAuthSessionData, RefreshAuthSessionResponses, RefreshAuthSessionErrors, ResendVerificationEmailData, ResendVerificationEmailResponses, ResendVerificationEmailErrors, VerifyEmailData, VerifyEmailResponses, VerifyEmailErrors, GetPasswordPolicyData, GetPasswordPolicyResponses, CheckPasswordStrengthData, CheckPasswordStrengthResponses, CheckPasswordStrengthErrors, ForgotPasswordData, ForgotPasswordResponses, ForgotPasswordErrors, ValidateResetTokenData, ValidateResetTokenResponses, ValidateResetTokenErrors, ResetPasswordData, ResetPasswordResponses, ResetPasswordErrors, GenerateSsoTokenData, GenerateSsoTokenResponses, GenerateSsoTokenErrors, SsoTokenExchangeData, SsoTokenExchangeResponses, SsoTokenExchangeErrors, CompleteSsoAuthData, CompleteSsoAuthResponses, CompleteSsoAuthErrors, GetCaptchaConfigData, GetCaptchaConfigResponses, GetServiceStatusData, GetServiceStatusResponses, GetCurrentUserData, GetCurrentUserResponses, UpdateUserData, UpdateUserResponses, UpdateUserErrors, UpdateUserPasswordData, UpdateUserPasswordResponses, UpdateUserPasswordErrors, ListUserApiKeysData, ListUserApiKeysResponses, CreateUserApiKeyData, CreateUserApiKeyResponses, CreateUserApiKeyErrors, RevokeUserApiKeyData, RevokeUserApiKeyResponses, RevokeUserApiKeyErrors, UpdateUserApiKeyData, UpdateUserApiKeyResponses, UpdateUserApiKeyErrors, ListUserOrgsData, ListUserOrgsResponses, CreateOrgData, CreateOrgResponses, CreateOrgErrors, GetOrgData, GetOrgResponses, GetOrgErrors, UpdateOrgData, UpdateOrgResponses, UpdateOrgErrors, ListOrgGraphsData, ListOrgGraphsResponses, ListOrgGraphsErrors, ListOrgMembersData, ListOrgMembersResponses, ListOrgMembersErrors, InviteOrgMemberData, InviteOrgMemberResponses, InviteOrgMemberErrors, RemoveOrgMemberData, RemoveOrgMemberResponses, RemoveOrgMemberErrors, UpdateOrgMemberRoleData, UpdateOrgMemberRoleResponses, UpdateOrgMemberRoleErrors, GetOrgLimitsData, GetOrgLimitsResponses, GetOrgLimitsErrors, GetOrgUsageData, GetOrgUsageResponses, GetOrgUsageErrors, ListConnectionsData, ListConnectionsResponses, ListConnectionsErrors, CreateConnectionData, CreateConnectionResponses, CreateConnectionErrors, GetConnectionOptionsData, GetConnectionOptionsResponses, GetConnectionOptionsErrors, ExchangeLinkTokenData, ExchangeLinkTokenResponses, ExchangeLinkTokenErrors, CreateLinkTokenData, CreateLinkTokenResponses, CreateLinkTokenErrors, InitOAuthData, InitOAuthResponses, InitOAuthErrors, OauthCallbackData, OauthCallbackResponses, OauthCallbackErrors, DeleteConnectionData, DeleteConnectionResponses, DeleteConnectionErrors, GetConnectionData, GetConnectionResponses, GetConnectionErrors, SyncConnectionData, SyncConnectionResponses, SyncConnectionErrors, ListAgentsData, ListAgentsResponses, ListAgentsErrors, AutoSelectAgentData, AutoSelectAgentResponses, AutoSelectAgentErrors, GetAgentMetadataData, GetAgentMetadataResponses, GetAgentMetadataErrors, ExecuteSpecificAgentData, ExecuteSpecificAgentResponses, ExecuteSpecificAgentErrors, BatchProcessQueriesData, BatchProcessQueriesResponses, BatchProcessQueriesErrors, RecommendAgentData, RecommendAgentResponses, RecommendAgentErrors, ListMcpToolsData, ListMcpToolsResponses, ListMcpToolsErrors, CallMcpToolData, CallMcpToolResponses, CallMcpToolErrors, ListBackupsData, ListBackupsResponses, ListBackupsErrors, CreateBackupData, CreateBackupResponses, CreateBackupErrors, GetBackupDownloadUrlData, GetBackupDownloadUrlResponses, GetBackupDownloadUrlErrors, RestoreBackupData, RestoreBackupResponses, RestoreBackupErrors, GetBackupStatsData, GetBackupStatsResponses, GetBackupStatsErrors, GetGraphMetricsData, GetGraphMetricsResponses, GetGraphMetricsErrors, GetGraphUsageAnalyticsData, GetGraphUsageAnalyticsResponses, GetGraphUsageAnalyticsErrors, ExecuteCypherQueryData, ExecuteCypherQueryResponses, ExecuteCypherQueryErrors, GetGraphSchemaData, GetGraphSchemaResponses, GetGraphSchemaErrors, ExportGraphSchemaData, ExportGraphSchemaResponses, ExportGraphSchemaErrors, ValidateSchemaData, ValidateSchemaResponses, ValidateSchemaErrors, GetCreditSummaryData, GetCreditSummaryResponses, GetCreditSummaryErrors, ListCreditTransactionsData, ListCreditTransactionsResponses, ListCreditTransactionsErrors, CheckCreditBalanceData, CheckCreditBalanceResponses, CheckCreditBalanceErrors, GetStorageUsageData, GetStorageUsageResponses, GetStorageUsageErrors, CheckStorageLimitsData, CheckStorageLimitsResponses, CheckStorageLimitsErrors, GetDatabaseHealthData, GetDatabaseHealthResponses, GetDatabaseHealthErrors, GetDatabaseInfoData, GetDatabaseInfoResponses, GetDatabaseInfoErrors, GetGraphLimitsData, GetGraphLimitsResponses, GetGraphLimitsErrors, ListSubgraphsData, ListSubgraphsResponses, ListSubgraphsErrors, CreateSubgraphData, CreateSubgraphResponses, CreateSubgraphErrors, DeleteSubgraphData, DeleteSubgraphResponses, DeleteSubgraphErrors, GetSubgraphInfoData, GetSubgraphInfoResponses, GetSubgraphInfoErrors, GetSubgraphQuotaData, GetSubgraphQuotaResponses, GetSubgraphQuotaErrors, GetGraphSubscriptionData, GetGraphSubscriptionResponses, GetGraphSubscriptionErrors, CreateRepositorySubscriptionData, CreateRepositorySubscriptionResponses, CreateRepositorySubscriptionErrors, UpgradeSubscriptionData, UpgradeSubscriptionResponses, UpgradeSubscriptionErrors, ListTablesData, ListTablesResponses, ListTablesErrors, QueryTablesData, QueryTablesResponses, QueryTablesErrors, CreateViewData, CreateViewResponses, CreateViewErrors, SaveViewData, SaveViewResponses, SaveViewErrors, GetMaterializationStatusData, GetMaterializationStatusResponses, GetMaterializationStatusErrors, MaterializeGraphData, MaterializeGraphResponses, MaterializeGraphErrors, ListFilesData, ListFilesResponses, ListFilesErrors, CreateFileUploadData, CreateFileUploadResponses, CreateFileUploadErrors, DeleteFileData, DeleteFileResponses, DeleteFileErrors, GetFileData, GetFileResponses, GetFileErrors, UpdateFileData, UpdateFileResponses, UpdateFileErrors, GetGraphsData, GetGraphsResponses, GetGraphsErrors, CreateGraphData, CreateGraphResponses, CreateGraphErrors, GetAvailableExtensionsData, GetAvailableExtensionsResponses, GetAvailableExtensionsErrors, GetAvailableGraphTiersData, GetAvailableGraphTiersResponses, GetAvailableGraphTiersErrors, SelectGraphData, SelectGraphResponses, SelectGraphErrors, GetServiceOfferingsData, GetServiceOfferingsResponses, GetServiceOfferingsErrors, StreamOperationEventsData, StreamOperationEventsResponses, StreamOperationEventsErrors, GetOperationStatusData, GetOperationStatusResponses, GetOperationStatusErrors, CancelOperationData, CancelOperationResponses, CancelOperationErrors, GetOrgBillingCustomerData, GetOrgBillingCustomerResponses, GetOrgBillingCustomerErrors, CreatePortalSessionData, CreatePortalSessionResponses, CreatePortalSessionErrors, ListOrgSubscriptionsData, ListOrgSubscriptionsResponses, ListOrgSubscriptionsErrors, GetOrgSubscriptionData, GetOrgSubscriptionResponses, GetOrgSubscriptionErrors, CancelOrgSubscriptionData, CancelOrgSubscriptionResponses, CancelOrgSubscriptionErrors, ListOrgInvoicesData, ListOrgInvoicesResponses, ListOrgInvoicesErrors, GetOrgUpcomingInvoiceData, GetOrgUpcomingInvoiceResponses, GetOrgUpcomingInvoiceErrors, CreateCheckoutSessionData, CreateCheckoutSessionResponses, CreateCheckoutSessionErrors, GetCheckoutStatusData, GetCheckoutStatusResponses, GetCheckoutStatusErrors } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Register New User
 * Register a new user account with email and password.
 *
 * **Organization Creation**: RoboSystems is an org-centric platform. When you register, a personal organization is automatically created for you. All resources (graphs, subscriptions, billing) belong to organizations, not individual users. You can later upgrade your personal org to a team or enterprise organization.
 *
 * **Security Controls**: CAPTCHA and email verification are disabled in development for API testing, but required in production.
 */
export const registerUser = <ThrowOnError extends boolean = false>(options: Options<RegisterUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RegisterUserResponses, RegisterUserErrors, ThrowOnError>({
        url: '/v1/auth/register',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * User Login
 * Authenticate user with email and password.
 */
export const loginUser = <ThrowOnError extends boolean = false>(options: Options<LoginUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<LoginUserResponses, LoginUserErrors, ThrowOnError>({
        url: '/v1/auth/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * User Logout
 * Logout user and invalidate session.
 */
export const logoutUser = <ThrowOnError extends boolean = false>(options?: Options<LogoutUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<LogoutUserResponses, unknown, ThrowOnError>({
        url: '/v1/auth/logout',
        ...options
    });
};

/**
 * Get Current User
 * Get the currently authenticated user.
 */
export const getCurrentAuthUser = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentAuthUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCurrentAuthUserResponses, GetCurrentAuthUserErrors, ThrowOnError>({
        url: '/v1/auth/me',
        ...options
    });
};

/**
 * Refresh Session
 * Refresh authentication session with a new JWT token.
 */
export const refreshAuthSession = <ThrowOnError extends boolean = false>(options?: Options<RefreshAuthSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RefreshAuthSessionResponses, RefreshAuthSessionErrors, ThrowOnError>({
        url: '/v1/auth/refresh',
        ...options
    });
};

/**
 * Resend Email Verification
 * Resend verification email to the authenticated user. Rate limited to 3 per hour.
 */
export const resendVerificationEmail = <ThrowOnError extends boolean = false>(options?: Options<ResendVerificationEmailData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ResendVerificationEmailResponses, ResendVerificationEmailErrors, ThrowOnError>({
        url: '/v1/auth/email/resend',
        ...options
    });
};

/**
 * Verify Email
 * Verify email address with token from email link. Returns JWT for auto-login.
 */
export const verifyEmail = <ThrowOnError extends boolean = false>(options: Options<VerifyEmailData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<VerifyEmailResponses, VerifyEmailErrors, ThrowOnError>({
        url: '/v1/auth/email/verify',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Password Policy
 * Get current password policy requirements for frontend validation
 */
export const getPasswordPolicy = <ThrowOnError extends boolean = false>(options?: Options<GetPasswordPolicyData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetPasswordPolicyResponses, unknown, ThrowOnError>({
        url: '/v1/auth/password/policy',
        ...options
    });
};

/**
 * Check Password Strength
 * Check password strength and get validation feedback
 */
export const checkPasswordStrength = <ThrowOnError extends boolean = false>(options: Options<CheckPasswordStrengthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CheckPasswordStrengthResponses, CheckPasswordStrengthErrors, ThrowOnError>({
        url: '/v1/auth/password/check',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Forgot Password
 * Request password reset email. Always returns success to prevent email enumeration.
 */
export const forgotPassword = <ThrowOnError extends boolean = false>(options: Options<ForgotPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ForgotPasswordResponses, ForgotPasswordErrors, ThrowOnError>({
        url: '/v1/auth/password/forgot',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Validate Reset Token
 * Check if a password reset token is valid without consuming it.
 */
export const validateResetToken = <ThrowOnError extends boolean = false>(options: Options<ValidateResetTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ValidateResetTokenResponses, ValidateResetTokenErrors, ThrowOnError>({
        url: '/v1/auth/password/reset/validate',
        ...options
    });
};

/**
 * Reset Password
 * Reset password with token from email. Returns JWT for auto-login.
 */
export const resetPassword = <ThrowOnError extends boolean = false>(options: Options<ResetPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ResetPasswordResponses, ResetPasswordErrors, ThrowOnError>({
        url: '/v1/auth/password/reset',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Generate SSO Token
 * Generate a temporary SSO token for cross-app authentication.
 */
export const generateSsoToken = <ThrowOnError extends boolean = false>(options?: Options<GenerateSsoTokenData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GenerateSsoTokenResponses, GenerateSsoTokenErrors, ThrowOnError>({
        url: '/v1/auth/sso-token',
        ...options
    });
};

/**
 * SSO Token Exchange
 * Exchange SSO token for secure session handoff to target application.
 */
export const ssoTokenExchange = <ThrowOnError extends boolean = false>(options: Options<SsoTokenExchangeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SsoTokenExchangeResponses, SsoTokenExchangeErrors, ThrowOnError>({
        url: '/v1/auth/sso-exchange',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Complete SSO Authentication
 * Complete SSO authentication using session ID from secure handoff.
 */
export const completeSsoAuth = <ThrowOnError extends boolean = false>(options: Options<CompleteSsoAuthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CompleteSsoAuthResponses, CompleteSsoAuthErrors, ThrowOnError>({
        url: '/v1/auth/sso-complete',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get CAPTCHA Configuration
 * Get CAPTCHA configuration including site key and whether CAPTCHA is required.
 */
export const getCaptchaConfig = <ThrowOnError extends boolean = false>(options?: Options<GetCaptchaConfigData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCaptchaConfigResponses, unknown, ThrowOnError>({
        url: '/v1/auth/captcha/config',
        ...options
    });
};

/**
 * Health Check
 * Service health check endpoint for monitoring and load balancers
 */
export const getServiceStatus = <ThrowOnError extends boolean = false>(options?: Options<GetServiceStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetServiceStatusResponses, unknown, ThrowOnError>({
        url: '/v1/status',
        ...options
    });
};

/**
 * Get Current User
 * Returns information about the currently authenticated user.
 */
export const getCurrentUser = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCurrentUserResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user',
        ...options
    });
};

/**
 * Update User Profile
 * Update the current user's profile information.
 */
export const updateUser = <ThrowOnError extends boolean = false>(options: Options<UpdateUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserResponses, UpdateUserErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Update Password
 * Update the current user's password.
 */
export const updateUserPassword = <ThrowOnError extends boolean = false>(options: Options<UpdateUserPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserPasswordResponses, UpdateUserPasswordErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/password',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List API Keys
 * Get all API keys for the current user.
 */
export const listUserApiKeys = <ThrowOnError extends boolean = false>(options?: Options<ListUserApiKeysData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ListUserApiKeysResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys',
        ...options
    });
};

/**
 * Create API Key
 * Create a new API key for the current user.
 */
export const createUserApiKey = <ThrowOnError extends boolean = false>(options: Options<CreateUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateUserApiKeyResponses, CreateUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Revoke API Key
 * Revoke (deactivate) an API key.
 */
export const revokeUserApiKey = <ThrowOnError extends boolean = false>(options: Options<RevokeUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<RevokeUserApiKeyResponses, RevokeUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys/{api_key_id}',
        ...options
    });
};

/**
 * Update API Key
 * Update an API key's name or description.
 */
export const updateUserApiKey = <ThrowOnError extends boolean = false>(options: Options<UpdateUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserApiKeyResponses, UpdateUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys/{api_key_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List User's Organizations
 * Get all organizations the current user belongs to, with their role in each.
 */
export const listUserOrgs = <ThrowOnError extends boolean = false>(options?: Options<ListUserOrgsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ListUserOrgsResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs',
        ...options
    });
};

/**
 * Create Organization
 * Create a new organization. The creating user becomes the owner.
 */
export const createOrg = <ThrowOnError extends boolean = false>(options: Options<CreateOrgData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateOrgResponses, CreateOrgErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Organization
 * Get detailed information about an organization.
 */
export const getOrg = <ThrowOnError extends boolean = false>(options: Options<GetOrgData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOrgResponses, GetOrgErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs/{org_id}',
        ...options
    });
};

/**
 * Update Organization
 * Update organization information. Requires admin or owner role.
 */
export const updateOrg = <ThrowOnError extends boolean = false>(options: Options<UpdateOrgData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateOrgResponses, UpdateOrgErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs/{org_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Organization Graphs
 * Get all graphs belonging to an organization.
 */
export const listOrgGraphs = <ThrowOnError extends boolean = false>(options: Options<ListOrgGraphsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListOrgGraphsResponses, ListOrgGraphsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs/{org_id}/graphs',
        ...options
    });
};

/**
 * List Organization Members
 * Get all members of an organization with their roles.
 */
export const listOrgMembers = <ThrowOnError extends boolean = false>(options: Options<ListOrgMembersData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListOrgMembersResponses, ListOrgMembersErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs/{org_id}/members',
        ...options
    });
};

/**
 * Invite Member
 * Invite a user to join the organization. Requires admin or owner role.
 *
 * **⚠️ FEATURE NOT READY**: This endpoint is disabled by default (ORG_MEMBER_INVITATIONS_ENABLED=false).
 * Returns 501 NOT IMPLEMENTED when disabled. See endpoint implementation for TODO list before enabling.
 */
export const inviteOrgMember = <ThrowOnError extends boolean = false>(options: Options<InviteOrgMemberData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<InviteOrgMemberResponses, InviteOrgMemberErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs/{org_id}/members',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Remove Member
 * Remove a member from the organization. Requires admin or owner role.
 */
export const removeOrgMember = <ThrowOnError extends boolean = false>(options: Options<RemoveOrgMemberData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<RemoveOrgMemberResponses, RemoveOrgMemberErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs/{org_id}/members/{user_id}',
        ...options
    });
};

/**
 * Update Member Role
 * Update a member's role in the organization. Requires admin or owner role.
 */
export const updateOrgMemberRole = <ThrowOnError extends boolean = false>(options: Options<UpdateOrgMemberRoleData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateOrgMemberRoleResponses, UpdateOrgMemberRoleErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs/{org_id}/members/{user_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Organization Limits
 * Get the current limits and quotas for an organization.
 */
export const getOrgLimits = <ThrowOnError extends boolean = false>(options: Options<GetOrgLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOrgLimitsResponses, GetOrgLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs/{org_id}/limits',
        ...options
    });
};

/**
 * Get Organization Usage
 * Get detailed usage statistics for an organization aggregated across all graphs.
 */
export const getOrgUsage = <ThrowOnError extends boolean = false>(options: Options<GetOrgUsageData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOrgUsageResponses, GetOrgUsageErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/orgs/{org_id}/usage',
        ...options
    });
};

/**
 * List Connections
 * List all data connections in the graph.
 *
 * Returns active and inactive connections with their current status.
 * Connections can be filtered by:
 * - **Entity**: Show connections for a specific entity
 * - **Provider**: Filter by connection type (sec, quickbooks, plaid)
 *
 * Each connection shows:
 * - Current sync status and health
 * - Last successful sync timestamp
 * - Configuration metadata
 * - Error messages if any
 *
 * No credits are consumed for listing connections.
 */
export const listConnections = <ThrowOnError extends boolean = false>(options: Options<ListConnectionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListConnectionsResponses, ListConnectionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections',
        ...options
    });
};

/**
 * Create Connection
 * Create a new data connection for external system integration.
 *
 * This endpoint initiates connections to external data sources:
 *
 * **SEC Connections**:
 * - Provide entity CIK for automatic filing retrieval
 * - No authentication needed
 * - Begins immediate data sync
 *
 * **QuickBooks Connections**:
 * - Returns OAuth URL for authorization
 * - Requires admin permissions in QuickBooks
 * - Complete with OAuth callback
 *
 * **Plaid Connections**:
 * - Returns Plaid Link token
 * - User completes bank authentication
 * - Exchange public token for access
 *
 * Note:
 * This operation is included - no credit consumption required.
 */
export const createConnection = <ThrowOnError extends boolean = false>(options: Options<CreateConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateConnectionResponses, CreateConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Connection Options
 * Get metadata about all available data connection providers.
 *
 * This endpoint returns comprehensive information about each supported provider:
 *
 * **SEC EDGAR**: Public entity financial filings
 * - No authentication required (public data)
 * - 10-K, 10-Q, 8-K reports with XBRL data
 * - Historical and real-time filing access
 *
 * **QuickBooks Online**: Full accounting system integration
 * - OAuth 2.0 authentication
 * - Chart of accounts, transactions, trial balance
 * - Real-time sync capabilities
 *
 * **Plaid**: Bank account connections
 * - Secure bank authentication via Plaid Link
 * - Transaction history and balances
 * - Multi-account support
 *
 * No credits are consumed for viewing connection options.
 */
export const getConnectionOptions = <ThrowOnError extends boolean = false>(options: Options<GetConnectionOptionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetConnectionOptionsResponses, GetConnectionOptionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/options',
        ...options
    });
};

/**
 * Exchange Link Token
 * Exchange a public token for permanent access credentials.
 *
 * This completes the embedded authentication flow after user authorization.
 *
 * The exchange process:
 * 1. Validates the temporary public token
 * 2. Exchanges it for permanent access credentials
 * 3. Updates the connection with account information
 * 4. Optionally triggers initial data sync
 *
 * Supported providers:
 * - **Plaid**: Exchanges Plaid Link public token for access token
 *
 * Security:
 * - Public tokens expire after 30 minutes
 * - Each token can only be exchanged once
 * - Full audit trail is maintained
 *
 * No credits are consumed for token exchange.
 */
export const exchangeLinkToken = <ThrowOnError extends boolean = false>(options: Options<ExchangeLinkTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExchangeLinkTokenResponses, ExchangeLinkTokenErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/link/exchange',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Link Token
 * Create a link token for embedded authentication providers.
 *
 * This endpoint generates a temporary token used to initialize embedded authentication UI.
 *
 * Currently supported providers:
 * - **Plaid**: Bank account connections with real-time transaction access
 *
 * The link token:
 * - Expires after 4 hours
 * - Is single-use only
 * - Must be used with the matching frontend SDK
 * - Includes user and entity context
 *
 * No credits are consumed for creating link tokens.
 */
export const createLinkToken = <ThrowOnError extends boolean = false>(options: Options<CreateLinkTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateLinkTokenResponses, CreateLinkTokenErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/link/token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Init Oauth
 * Initialize OAuth flow for a connection.
 *
 * This generates an authorization URL that the frontend should redirect the user to.
 * Currently supports: QuickBooks
 */
export const initOAuth = <ThrowOnError extends boolean = false>(options: Options<InitOAuthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<InitOAuthResponses, InitOAuthErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/oauth/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * OAuth Callback
 * Handle OAuth callback from provider after user authorization.
 *
 * This endpoint completes the OAuth flow:
 * 1. Validates the OAuth state parameter
 * 2. Exchanges authorization code for access tokens
 * 3. Stores tokens securely
 * 4. Updates connection status
 * 5. Optionally triggers initial sync
 *
 * Supported providers:
 * - **QuickBooks**: Accounting data integration
 *
 * Security measures:
 * - State validation prevents session hijacking
 * - User context is verified
 * - Tokens are encrypted before storage
 * - Full audit trail is maintained
 *
 * No credits are consumed for OAuth callbacks.
 */
export const oauthCallback = <ThrowOnError extends boolean = false>(options: Options<OauthCallbackData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<OauthCallbackResponses, OauthCallbackErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/oauth/callback/{provider}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Connection
 * Delete a data connection and clean up related resources.
 *
 * This operation:
 * - Removes the connection configuration
 * - Preserves any imported data in the graph
 * - Performs provider-specific cleanup
 * - Revokes stored credentials
 *
 * Note:
 * This operation is included - no credit consumption required.
 *
 * Only users with admin role can delete connections.
 */
export const deleteConnection = <ThrowOnError extends boolean = false>(options: Options<DeleteConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteConnectionResponses, DeleteConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/{connection_id}',
        ...options
    });
};

/**
 * Get Connection
 * Get detailed information about a specific connection.
 *
 * Returns comprehensive connection details including:
 * - Current status and health indicators
 * - Authentication state
 * - Sync history and statistics
 * - Error details if any
 * - Provider-specific metadata
 *
 * No credits are consumed for viewing connection details.
 */
export const getConnection = <ThrowOnError extends boolean = false>(options: Options<GetConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetConnectionResponses, GetConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/{connection_id}',
        ...options
    });
};

/**
 * Sync Connection
 * Trigger a data synchronization for the connection.
 *
 * Initiates data sync based on provider type:
 *
 * **SEC Sync**:
 * - Downloads latest filings from EDGAR
 * - Parses XBRL data and updates graph
 * - Typically completes in 5-10 minutes
 *
 * **QuickBooks Sync**:
 * - Fetches latest transactions and balances
 * - Updates chart of accounts
 * - Generates fresh trial balance
 * - Duration depends on data volume
 *
 * **Plaid Sync**:
 * - Retrieves recent bank transactions
 * - Updates account balances
 * - Categorizes new transactions
 *
 * Note:
 * This operation is included - no credit consumption required.
 *
 * Returns a task ID for monitoring sync progress.
 */
export const syncConnection = <ThrowOnError extends boolean = false>(options: Options<SyncConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SyncConnectionResponses, SyncConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/{connection_id}/sync',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List available agents
 * Get a comprehensive list of all available agents with their metadata.
 *
 * **Returns:**
 * - Agent types and names
 * - Capabilities and supported modes
 * - Version information
 * - Credit requirements
 *
 * Use the optional `capability` filter to find agents with specific capabilities.
 */
export const listAgents = <ThrowOnError extends boolean = false>(options: Options<ListAgentsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListAgentsResponses, ListAgentsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent',
        ...options
    });
};

/**
 * Auto-select agent for query
 * Automatically select the best agent for your query with intelligent execution strategy.
 *
 * **Agent Selection Process:**
 *
 * The orchestrator intelligently routes your query by:
 * 1. Analyzing query intent and complexity
 * 2. Enriching context with RAG if enabled
 * 3. Evaluating all available agents against selection criteria
 * 4. Selecting the best match based on confidence scores
 * 5. Choosing execution strategy (sync/SSE/async) based on expected time
 * 6. Executing the query with the selected agent
 *
 * **Available Agent Types:**
 * - `financial`: Financial analysis, SEC filings, company metrics
 * - `research`: General research, data exploration, trend analysis
 * - `rag`: Knowledge base search using RAG enrichment
 *
 * **Execution Modes:**
 * - `quick`: Fast responses (~2-5s), suitable for simple queries
 * - `standard`: Balanced approach (~5-15s), default mode
 * - `extended`: Comprehensive analysis (~15-60s), deep research
 * - `streaming`: Real-time response streaming
 *
 * **Execution Strategies (automatic):**
 * - Fast operations (<5s): Immediate synchronous response
 * - Medium operations (5-30s): SSE streaming with progress updates
 * - Long operations (>30s): Async Celery worker with operation tracking
 *
 * **Response Mode Override:**
 * Use query parameter `?mode=sync|async` to override automatic strategy selection.
 *
 * **Confidence Score Interpretation:**
 * - `0.9-1.0`: High confidence, agent is ideal match
 * - `0.7-0.9`: Good confidence, agent is suitable
 * - `0.5-0.7`: Moderate confidence, agent can handle but may not be optimal
 * - `0.3-0.5`: Low confidence, fallback agent used
 * - `<0.3`: Very low confidence, consider using specific agent endpoint
 *
 * **Credit Costs:**
 * - Quick mode: 5-10 credits per query
 * - Standard mode: 15-25 credits per query
 * - Extended mode: 30-75 credits per query
 * - RAG enrichment: +5-15 credits (if enabled)
 *
 * **Use Cases:**
 * - Ask questions without specifying agent type
 * - Get intelligent routing for complex multi-domain queries
 * - Leverage conversation history for contextual understanding
 * - Enable RAG for knowledge base enrichment
 *
 * **Subgraph Support:**
 * This endpoint accepts both parent graph IDs and subgraph IDs.
 * - Parent graph: Use `graph_id` like `kg0123456789abcdef`
 * - Subgraph: Use full subgraph ID like `kg0123456789abcdef_dev`
 * Agents operate on the specified graph/subgraph's data independently. RAG enrichment
 * and knowledge base search are scoped to the specific graph/subgraph.
 *
 * See request/response examples in the "Examples" dropdown below.
 */
export const autoSelectAgent = <ThrowOnError extends boolean = false>(options: Options<AutoSelectAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<AutoSelectAgentResponses, AutoSelectAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get agent metadata
 * Get comprehensive metadata for a specific agent type.
 *
 * **Returns:**
 * - Agent name and description
 * - Version information
 * - Supported capabilities and modes
 * - Credit requirements
 * - Author and tags
 * - Configuration options
 *
 * Use this to understand agent capabilities before execution.
 */
export const getAgentMetadata = <ThrowOnError extends boolean = false>(options: Options<GetAgentMetadataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetAgentMetadataResponses, GetAgentMetadataErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/{agent_type}',
        ...options
    });
};

/**
 * Execute specific agent
 * Execute a specific agent type directly with intelligent execution strategy.
 *
 * Available agents:
 * - **financial**: Financial analysis, SEC filings, accounting data
 * - **research**: Deep research and comprehensive analysis
 * - **rag**: Fast retrieval without AI (no credits required)
 *
 * **Execution Strategies (automatic):**
 * - Fast operations (<5s): Immediate synchronous response
 * - Medium operations (5-30s): SSE streaming with progress updates
 * - Long operations (>30s): Async Celery worker with operation tracking
 *
 * **Response Mode Override:**
 * Use query parameter `?mode=sync|async` to override automatic strategy selection.
 *
 * Use this endpoint when you know which agent you want to use.
 */
export const executeSpecificAgent = <ThrowOnError extends boolean = false>(options: Options<ExecuteSpecificAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecuteSpecificAgentResponses, ExecuteSpecificAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/{agent_type}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Batch process multiple queries
 * Process multiple queries either sequentially or in parallel.
 *
 * **Features:**
 * - Process up to 10 queries in a single request
 * - Sequential or parallel execution modes
 * - Automatic error handling per query
 * - Credit checking before execution
 *
 * **Use Cases:**
 * - Bulk analysis of multiple entities
 * - Comparative analysis across queries
 * - Automated report generation
 *
 * Returns individual results for each query with execution metrics.
 */
export const batchProcessQueries = <ThrowOnError extends boolean = false>(options: Options<BatchProcessQueriesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BatchProcessQueriesResponses, BatchProcessQueriesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/batch',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get agent recommendations
 * Get intelligent agent recommendations for a specific query.
 *
 * **How it works:**
 * 1. Analyzes query content and structure
 * 2. Evaluates agent capabilities
 * 3. Calculates confidence scores
 * 4. Returns ranked recommendations
 *
 * **Use this when:**
 * - Unsure which agent to use
 * - Need to understand agent suitability
 * - Want confidence scores for decision making
 *
 * Returns top agents ranked by confidence with explanations.
 */
export const recommendAgent = <ThrowOnError extends boolean = false>(options: Options<RecommendAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RecommendAgentResponses, RecommendAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/recommend',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List MCP Tools
 * Get available Model Context Protocol tools for graph analysis.
 *
 * This endpoint returns a comprehensive list of MCP tools optimized for AI agents:
 * - Tool schemas with detailed parameter documentation
 * - Context-aware descriptions based on graph type
 * - Capability indicators for streaming and progress
 *
 * The tool list is customized based on:
 * - Graph type (shared repository vs user graph)
 * - User permissions and subscription tier
 * - Backend capabilities (Kuzu, Neo4j, etc.)
 *
 * **Subgraph Support:**
 * This endpoint accepts both parent graph IDs and subgraph IDs.
 * - Parent graph: Use `graph_id` like `kg0123456789abcdef`
 * - Subgraph: Use full subgraph ID like `kg0123456789abcdef_dev`
 * The returned tool list is identical for parent graphs and subgraphs, as all
 * MCP tools work uniformly across graph boundaries.
 *
 * **Note:**
 * MCP tool listing is included - no credit consumption required.
 */
export const listMcpTools = <ThrowOnError extends boolean = false>(options: Options<ListMcpToolsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListMcpToolsResponses, ListMcpToolsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/mcp/tools',
        ...options
    });
};

/**
 * Execute MCP Tool
 * Execute an MCP tool with intelligent response optimization.
 *
 * This endpoint automatically selects the best execution strategy based on:
 * - Tool type and estimated complexity
 * - Client capabilities (AI agent detection)
 * - System load and queue status
 * - Graph type (shared repository vs user graph)
 *
 * **Response Formats:**
 * - **JSON**: Direct response for small/fast operations
 * - **SSE**: Server-Sent Events for progress monitoring
 * - **NDJSON**: Newline-delimited JSON for streaming
 * - **Queued**: Asynchronous execution with status monitoring
 *
 * **SSE Streaming Support:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation to direct response if SSE unavailable
 * - Progress events for long-running operations
 *
 * **AI Agent Optimization:**
 * The Node.js MCP client transparently handles all response formats,
 * presenting a unified interface to AI agents. Streaming responses are
 * automatically aggregated for seamless consumption.
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Connection limit or rate limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - `408 Request Timeout`: Tool execution exceeded timeout
 * - Clients should implement exponential backoff on errors
 *
 * **Subgraph Support:**
 * This endpoint accepts both parent graph IDs and subgraph IDs.
 * - Parent graph: Use `graph_id` like `kg0123456789abcdef`
 * - Subgraph: Use full subgraph ID like `kg0123456789abcdef_dev`
 * MCP tools operate on the specified graph/subgraph independently. Each subgraph
 * has its own schema, data, and can be queried separately via MCP.
 *
 * **Credit Model:**
 * MCP tool execution is included - no credit consumption required. Database
 * operations (queries, schema inspection, analytics) are completely free.
 * Only AI operations that invoke Claude or other LLM APIs consume credits,
 * which happens at the AI agent layer, not the MCP tool layer.
 */
export const callMcpTool = <ThrowOnError extends boolean = false>(options: Options<CallMcpToolData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CallMcpToolResponses, CallMcpToolErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/mcp/call-tool',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List graph database backups
 * List all backups for the specified graph database
 */
export const listBackups = <ThrowOnError extends boolean = false>(options: Options<ListBackupsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListBackupsResponses, ListBackupsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups',
        ...options
    });
};

/**
 * Create Backup
 * Create a backup of the graph database.
 *
 * Creates a complete backup of the graph database (.kuzu file) with:
 * - **Format**: Full database backup only (complete .kuzu file)
 * - **Compression**: Always enabled for optimal storage
 * - **Encryption**: Optional AES-256 encryption for security
 * - **Retention**: Configurable retention period (1-2555 days)
 *
 * **Backup Features:**
 * - **Complete Backup**: Full database file backup
 * - **Consistency**: Point-in-time consistent snapshot
 * - **Download Support**: Unencrypted backups can be downloaded
 * - **Restore Support**: Future support for encrypted backup restoration
 *
 * **Operation State Machine:**
 * ```
 * pending → processing → completed
 * ↘ failed
 * ```
 * - **pending**: Backup queued, waiting to start
 * - **processing**: Actively backing up database
 * - **completed**: Backup successfully created and stored
 * - **failed**: Backup failed (check error message)
 *
 * **Expected Durations:**
 * Operation times vary by database size:
 * - **Small** (<1GB): 30 seconds - 2 minutes
 * - **Medium** (1-10GB): 2-10 minutes
 * - **Large** (10-100GB): 10-30 minutes
 * - **Very Large** (>100GB): 30+ minutes
 *
 * **Progress Monitoring:**
 * Use the returned operation_id to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.addEventListener('operation_progress', (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Backup progress:', data.progress_percent + '%');
 * console.log('Status:', data.status); // pending, processing, completed, failed
 * });
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Important Notes:**
 * - Only full_dump format is supported (no CSV/JSON exports)
 * - Compression is always enabled
 * - Encrypted backups cannot be downloaded (security measure)
 * - All backups are stored securely in cloud storage
 *
 * **Credit Consumption:**
 * - Base cost: 25.0 credits
 * - Large databases (>10GB): 50.0 credits
 * - Multiplied by graph tier
 *
 * Returns operation details for SSE monitoring.
 */
export const createBackup = <ThrowOnError extends boolean = false>(options: Options<CreateBackupData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateBackupResponses, CreateBackupErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get temporary download URL for backup
 * Generate a temporary download URL for a backup (unencrypted, compressed .kuzu files only)
 */
export const getBackupDownloadUrl = <ThrowOnError extends boolean = false>(options: Options<GetBackupDownloadUrlData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetBackupDownloadUrlResponses, GetBackupDownloadUrlErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups/{backup_id}/download',
        ...options
    });
};

/**
 * Restore Encrypted Backup
 * Restore a graph database from an encrypted backup.
 *
 * Restores a complete graph database from an encrypted backup:
 * - **Format**: Only full_dump backups can be restored
 * - **Encryption**: Only encrypted backups can be restored (security requirement)
 * - **System Backup**: Creates automatic backup of existing database before restore
 * - **Verification**: Optionally verifies database integrity after restore
 *
 * **Restore Features:**
 * - **Atomic Operation**: Complete replacement of database
 * - **Rollback Protection**: System backup created before restore
 * - **Data Integrity**: Verification ensures successful restore
 * - **Security**: Only encrypted backups to prevent data tampering
 *
 * **Operation State Machine:**
 * ```
 * pending → backing_up_current → downloading → restoring → verifying → completed
 * ↘ failed
 * ```
 * - **pending**: Restore queued, waiting to start
 * - **backing_up_current**: Creating safety backup of existing database
 * - **downloading**: Downloading backup from storage
 * - **restoring**: Replacing database with backup contents
 * - **verifying**: Verifying database integrity (if enabled)
 * - **completed**: Restore successful, database operational
 * - **failed**: Restore failed (rollback may be available)
 *
 * **Expected Durations:**
 * Operation times vary by database size (includes backup + restore):
 * - **Small** (<1GB): 1-3 minutes
 * - **Medium** (1-10GB): 5-15 minutes
 * - **Large** (10-100GB): 20-45 minutes
 * - **Very Large** (>100GB): 45+ minutes
 *
 * Note: Restore operations take longer than backups due to safety backup step.
 *
 * **Progress Monitoring:**
 * Use the returned operation_id to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.addEventListener('operation_progress', (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Restore progress:', data.message);
 * console.log('Status:', data.status); // Shows current state
 * });
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Important Notes:**
 * - Only encrypted backups can be restored (security measure)
 * - Existing database is backed up to S3 before restore
 * - Restore is a destructive operation - existing data is replaced
 * - System backups are stored separately for recovery
 *
 * **Credit Consumption:**
 * - Base cost: 100.0 credits
 * - Large databases (>10GB): 200.0 credits
 * - Multiplied by graph tier
 *
 * Returns operation details for SSE monitoring.
 */
export const restoreBackup = <ThrowOnError extends boolean = false>(options: Options<RestoreBackupData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RestoreBackupResponses, RestoreBackupErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups/{backup_id}/restore',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get backup statistics
 * Get comprehensive backup statistics for the specified graph database
 */
export const getBackupStats = <ThrowOnError extends boolean = false>(options: Options<GetBackupStatsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetBackupStatsResponses, GetBackupStatsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups/stats',
        ...options
    });
};

/**
 * Get Graph Metrics
 * Get comprehensive metrics for the graph database.
 *
 * Provides detailed analytics including:
 * - **Node Statistics**: Counts by type (Entity, Report, Account, Transaction)
 * - **Relationship Metrics**: Connection counts and patterns
 * - **Data Quality**: Completeness scores and validation results
 * - **Performance Metrics**: Query response times and database health
 * - **Storage Analytics**: Database size and growth trends
 *
 * This data helps with:
 * - Monitoring data completeness
 * - Identifying data quality issues
 * - Capacity planning
 * - Performance optimization
 *
 * Note:
 * This operation is included - no credit consumption required.
 */
export const getGraphMetrics = <ThrowOnError extends boolean = false>(options: Options<GetGraphMetricsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphMetricsResponses, GetGraphMetricsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/analytics',
        ...options
    });
};

/**
 * Get Graph Usage Analytics
 * Get comprehensive usage analytics tracked by the GraphUsage model.
 *
 * Provides temporal usage patterns including:
 * - **Storage Analytics**: GB-hours for billing, breakdown by type (files, tables, graphs, subgraphs)
 * - **Credit Analytics**: Consumption patterns, operation breakdown, cached vs billable
 * - **Performance Insights**: Operation stats, slow queries, performance scoring
 * - **Recent Events**: Latest usage events with full details
 *
 * Time ranges available:
 * - `24h` - Last 24 hours (hourly breakdown)
 * - `7d` - Last 7 days (daily breakdown)
 * - `30d` - Last 30 days (daily breakdown)
 * - `current_month` - Current billing month
 * - `last_month` - Previous billing month
 *
 * Include options:
 * - `storage` - Storage usage summary (GB-hours, averages, peaks)
 * - `credits` - Credit consumption analytics
 * - `performance` - Performance insights and optimization opportunities
 * - `events` - Recent usage events (last 50)
 *
 * Useful for:
 * - Billing and cost analysis
 * - Capacity planning
 * - Performance optimization
 * - Usage trend analysis
 *
 * Note:
 * This operation is included - no credit consumption required.
 */
export const getGraphUsageAnalytics = <ThrowOnError extends boolean = false>(options: Options<GetGraphUsageAnalyticsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphUsageAnalyticsResponses, GetGraphUsageAnalyticsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/analytics/usage',
        ...options
    });
};

/**
 * Execute Cypher Query
 * Execute a Cypher query with intelligent response optimization.
 *
 * **IMPORTANT: Write operations depend on graph type:**
 * - **Main Graphs**: READ-ONLY. Write operations (CREATE, MERGE, SET, DELETE) are not allowed.
 * - **Subgraphs**: WRITE-ENABLED. Full Cypher write operations are supported for development and report creation.
 *
 * To load data into main graphs, use the staging pipeline:
 * 1. Create file upload: `POST /v1/graphs/{graph_id}/tables/{table_name}/files`
 * 2. Ingest to graph: `POST /v1/graphs/{graph_id}/tables/ingest`
 *
 * **Security Best Practice - Use Parameterized Queries:**
 * ALWAYS use query parameters instead of string interpolation to prevent injection attacks:
 * - ✅ SAFE: `MATCH (n:Entity {type: $entity_type}) RETURN n` with `parameters: {"entity_type": "Company"}`
 * - ❌ UNSAFE: `MATCH (n:Entity {type: "Company"}) RETURN n` with user input concatenated into query string
 *
 * Query parameters provide automatic escaping and type safety. All examples in this API use parameterized queries.
 *
 * This endpoint automatically selects the best execution strategy based on:
 * - Query characteristics (size, complexity)
 * - Client capabilities (SSE, NDJSON, JSON)
 * - System load (queue status, concurrent queries)
 * - User preferences (mode parameter, headers)
 *
 * **Response Modes:**
 * - `auto` (default): Intelligent automatic selection
 * - `sync`: Force synchronous JSON response (best for testing)
 * - `async`: Force queued response with SSE monitoring endpoints (no polling needed)
 * - `stream`: Force streaming response (SSE or NDJSON)
 *
 * **Client Detection:**
 * - Automatically detects testing tools (Postman, Swagger UI)
 * - Adjusts behavior for better interactive experience
 * - Respects Accept and Prefer headers for capabilities
 *
 * **Streaming Support (SSE):**
 * - Real-time events with progress updates
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 * - 30-second keepalive to prevent timeouts
 *
 * **Streaming Support (NDJSON):**
 * - Efficient line-delimited JSON for large results
 * - Automatic chunking (configurable 10-10000 rows)
 * - No connection limits (stateless streaming)
 *
 * **Queue Management:**
 * - Automatic queuing under high load
 * - Real-time monitoring via SSE events (no polling needed)
 * - Priority based on subscription tier
 * - Queue position and progress updates pushed via SSE
 * - Connect to returned `/v1/operations/{id}/stream` endpoint for updates
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Rate limit or connection limit exceeded
 * - `503 Service Unavailable`: Circuit breaker open or SSE disabled
 * - Clients should implement exponential backoff
 *
 * **Subgraph Support:**
 * This endpoint accepts both parent graph IDs and subgraph IDs.
 * - Parent graph: Use `graph_id` like `kg0123456789abcdef`
 * - Subgraph: Use full subgraph ID like `kg0123456789abcdef_dev`
 * Subgraphs share the same instance as their parent graph and have independent data.
 *
 * **Note:**
 * Query operations are included - no credit consumption required.
 * Queue position is based on subscription tier for priority.
 */
export const executeCypherQuery = <ThrowOnError extends boolean = false>(options: Options<ExecuteCypherQueryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecuteCypherQueryResponses, ExecuteCypherQueryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/query',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Runtime Graph Schema
 * Get runtime schema information for the specified graph database.
 *
 * ## What This Returns
 *
 * This endpoint inspects the **actual current state** of the graph database and returns:
 * - **Node Labels**: All node types currently in the database
 * - **Relationship Types**: All relationship types currently in the database
 * - **Node Properties**: Properties discovered from actual data (up to 10 properties per node type)
 *
 * ## Runtime vs Declared Schema
 *
 * **Use this endpoint** (`/schema`) when you need to know:
 * - What data is ACTUALLY in the database right now
 * - What properties exist on real nodes
 * - What relationships have been created
 * - Current database structure for querying
 *
 * **Use `/schema/export` instead** when you need:
 * - The original schema definition used to create the graph
 * - Schema in a specific format (JSON, YAML, Cypher DDL)
 * - Schema for documentation or version control
 * - Schema to replicate in another graph
 *
 * ## Example Use Cases
 *
 * - **Building queries**: See what node labels and properties exist to write accurate Cypher
 * - **Data exploration**: Discover what's in an unfamiliar graph
 * - **Schema drift detection**: Compare runtime vs declared schema
 * - **API integration**: Dynamically adapt to current graph structure
 *
 * ## Performance Note
 *
 * Property discovery is limited to 10 properties per node type for performance.
 * For complete schema definitions, use `/schema/export`.
 *
 * ## Subgraph Support
 *
 * This endpoint accepts both parent graph IDs and subgraph IDs.
 * - Parent graph: Use `graph_id` like `kg0123456789abcdef`
 * - Subgraph: Use full subgraph ID like `kg0123456789abcdef_dev`
 * Each subgraph has independent schema and data. The returned schema reflects
 * only the specified graph/subgraph's actual structure.
 *
 * This operation is included - no credit consumption required.
 */
export const getGraphSchema = <ThrowOnError extends boolean = false>(options: Options<GetGraphSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphSchemaResponses, GetGraphSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/schema',
        ...options
    });
};

/**
 * Export Declared Graph Schema
 * Export the declared schema definition of an existing graph.
 *
 * ## What This Returns
 *
 * This endpoint returns the **original schema definition** that was used to create the graph:
 * - The schema as it was **declared** during graph creation
 * - Complete node and relationship definitions
 * - Property types and constraints
 * - Schema metadata (name, version, type)
 *
 * ## Runtime vs Declared Schema
 *
 * **Use this endpoint** (`/schema/export`) when you need:
 * - The original schema definition used to create the graph
 * - Schema in a specific format (JSON, YAML, Cypher DDL)
 * - Schema for documentation or version control
 * - Schema to replicate in another graph
 *
 * **Use `/schema` instead** when you need:
 * - What data is ACTUALLY in the database right now
 * - What properties exist on real nodes (discovered from data)
 * - Current runtime database structure for querying
 *
 * ## Export Formats
 *
 * ### JSON Format (`format=json`)
 * Returns structured JSON with nodes, relationships, and properties.
 * Best for programmatic access and API integration.
 *
 * ### YAML Format (`format=yaml`)
 * Returns human-readable YAML with comments.
 * Best for documentation and configuration management.
 *
 * ### Cypher DDL Format (`format=cypher`)
 * Returns Cypher CREATE statements for recreating the schema.
 * Best for database migration and replication.
 *
 * ## Data Statistics
 *
 * Set `include_data_stats=true` to include:
 * - Node counts by label
 * - Relationship counts by type
 * - Total nodes and relationships
 *
 * This combines declared schema with runtime statistics.
 *
 * This operation is included - no credit consumption required.
 */
export const exportGraphSchema = <ThrowOnError extends boolean = false>(options: Options<ExportGraphSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ExportGraphSchemaResponses, ExportGraphSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/schema/export',
        ...options
    });
};

/**
 * Validate Schema
 * Validate a custom schema definition before deployment.
 *
 * This endpoint performs comprehensive validation including:
 * - **Structure Validation**: Ensures proper JSON/YAML format
 * - **Type Checking**: Validates data types (STRING, INT, DOUBLE, etc.)
 * - **Constraint Verification**: Checks primary keys and unique constraints
 * - **Relationship Integrity**: Validates node references in relationships
 * - **Naming Conventions**: Ensures valid identifiers
 * - **Compatibility**: Checks against existing extensions if specified
 *
 * Supported formats:
 * - JSON schema definitions
 * - YAML schema definitions
 * - Direct dictionary format
 *
 * Validation helps prevent:
 * - Schema deployment failures
 * - Data integrity issues
 * - Performance problems
 * - Naming conflicts
 *
 * **Subgraph Support:**
 * This endpoint accepts both parent graph IDs and subgraph IDs.
 * - Parent graph: Use `graph_id` like `kg0123456789abcdef`
 * - Subgraph: Use full subgraph ID like `kg0123456789abcdef_dev`
 * Schema validation is performed against the specified graph/subgraph's current
 * schema and data structure.
 *
 * This operation is included - no credit consumption required.
 */
export const validateSchema = <ThrowOnError extends boolean = false>(options: Options<ValidateSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ValidateSchemaResponses, ValidateSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/schema/validate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Credit Summary
 * Retrieve comprehensive credit usage summary for the specified graph.
 *
 * This endpoint provides:
 * - Current credit balance and monthly allocation
 * - Credit consumption metrics for the current month
 * - Graph tier and credit multiplier information
 * - Usage percentage to help monitor credit consumption
 *
 * No credits are consumed for checking credit status.
 */
export const getCreditSummary = <ThrowOnError extends boolean = false>(options: Options<GetCreditSummaryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCreditSummaryResponses, GetCreditSummaryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/summary',
        ...options
    });
};

/**
 * List Credit Transactions
 * Retrieve detailed credit transaction history for the specified graph.
 *
 * This enhanced endpoint provides:
 * - Detailed transaction records with idempotency information
 * - Summary by operation type to identify high-consumption operations
 * - Date range filtering for analysis
 * - Metadata search capabilities
 *
 * Transaction types include:
 * - ALLOCATION: Monthly credit allocations
 * - CONSUMPTION: Credit usage for operations
 * - BONUS: Bonus credits added by admins
 * - REFUND: Credit refunds
 *
 * No credits are consumed for viewing transaction history.
 */
export const listCreditTransactions = <ThrowOnError extends boolean = false>(options: Options<ListCreditTransactionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListCreditTransactionsResponses, ListCreditTransactionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/transactions',
        ...options
    });
};

/**
 * Check Credit Balance
 * Check if the graph has sufficient credits for a planned operation.
 *
 * This endpoint allows you to verify credit availability before performing
 * an operation, helping prevent failed operations due to insufficient credits.
 *
 * The check considers:
 * - Base operation cost
 * - Graph tier multiplier
 * - Current credit balance
 *
 * No credits are consumed for checking availability.
 */
export const checkCreditBalance = <ThrowOnError extends boolean = false>(options: Options<CheckCreditBalanceData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<CheckCreditBalanceResponses, CheckCreditBalanceErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/balance/check',
        ...options
    });
};

/**
 * Get Storage Usage
 * Get storage usage history for a graph.
 *
 * Returns detailed storage usage information including:
 * - Daily average storage consumption
 * - Storage trends over time
 * - Credit costs for storage
 * - Current storage billing information
 *
 * This endpoint helps users understand their storage patterns
 * and associated credit costs.
 */
export const getStorageUsage = <ThrowOnError extends boolean = false>(options: Options<GetStorageUsageData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetStorageUsageResponses, GetStorageUsageErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/storage/usage',
        ...options
    });
};

/**
 * Check Storage Limits
 * Check storage limits and usage for a graph.
 *
 * Returns comprehensive storage limit information including:
 * - Current storage usage
 * - Effective limit (override or default)
 * - Usage percentage and warnings
 * - Recommendations for limit management
 *
 * This endpoint helps users monitor storage usage and plan for potential
 * limit increases. No credits are consumed for checking storage limits.
 */
export const checkStorageLimits = <ThrowOnError extends boolean = false>(options: Options<CheckStorageLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<CheckStorageLimitsResponses, CheckStorageLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/storage/limits',
        ...options
    });
};

/**
 * Database Health Check
 * Get comprehensive health information for the graph database.
 *
 * Returns detailed health metrics including:
 * - **Connection Status**: Database connectivity and responsiveness
 * - **Performance Metrics**: Query execution times and throughput
 * - **Resource Usage**: Memory and storage utilization
 * - **Error Monitoring**: Recent error rates and patterns
 * - **Uptime Statistics**: Service availability metrics
 *
 * Health indicators:
 * - **Status**: healthy, degraded, or unhealthy
 * - **Query Performance**: Average execution times
 * - **Error Rates**: Recent failure percentages
 * - **Resource Usage**: Memory and storage consumption
 * - **Alerts**: Active warnings or issues
 *
 * **Subgraph Support:**
 * This endpoint accepts both parent graph IDs and subgraph IDs.
 * - Parent graph: Use `graph_id` like `kg0123456789abcdef`
 * - Subgraph: Use full subgraph ID like `kg0123456789abcdef_dev`
 * Health metrics are specific to the requested graph/subgraph. Subgraphs share the
 * same physical instance as their parent but have independent health indicators.
 *
 * This endpoint provides essential monitoring data for operational visibility.
 */
export const getDatabaseHealth = <ThrowOnError extends boolean = false>(options: Options<GetDatabaseHealthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetDatabaseHealthResponses, GetDatabaseHealthErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/health',
        ...options
    });
};

/**
 * Database Information
 * Get comprehensive database information and statistics.
 *
 * Returns detailed database metrics including:
 * - **Database Metadata**: Name, path, size, and timestamps
 * - **Schema Information**: Node labels, relationship types, and counts
 * - **Storage Statistics**: Database size and usage metrics
 * - **Data Composition**: Node and relationship counts
 * - **Backup Information**: Available backups and last backup date
 * - **Configuration**: Read-only status and schema version
 *
 * Database statistics:
 * - **Size**: Storage usage in bytes and MB
 * - **Content**: Node and relationship counts
 * - **Schema**: Available labels and relationship types
 * - **Backup Status**: Backup availability and recency
 * - **Timestamps**: Creation and modification dates
 *
 * **Subgraph Support:**
 * This endpoint accepts both parent graph IDs and subgraph IDs.
 * - Parent graph: Use `graph_id` like `kg0123456789abcdef`
 * - Subgraph: Use full subgraph ID like `kg0123456789abcdef_dev`
 * Returned metrics are specific to the requested graph/subgraph. Subgraphs have
 * independent size, node/relationship counts, and backup status.
 *
 * This endpoint provides essential database information for capacity planning and monitoring.
 */
export const getDatabaseInfo = <ThrowOnError extends boolean = false>(options: Options<GetDatabaseInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetDatabaseInfoResponses, GetDatabaseInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/info',
        ...options
    });
};

/**
 * Get Graph Operational Limits
 * Get comprehensive operational limits for the graph database.
 *
 * Returns all operational limits that apply to this graph including:
 * - **Storage Limits**: Maximum storage size and current usage
 * - **Query Limits**: Timeouts, complexity, row limits
 * - **Copy/Ingestion Limits**: File sizes, timeouts, concurrent operations
 * - **Backup Limits**: Frequency, retention, size limits
 * - **Rate Limits**: Requests per minute/hour based on tier
 * - **Credit Limits**: AI operation credits (if applicable)
 *
 * This unified endpoint provides all limits in one place for easier client integration.
 *
 * **Note**: Limits vary based on subscription tier (kuzu-standard, kuzu-large, kuzu-xlarge).
 */
export const getGraphLimits = <ThrowOnError extends boolean = false>(options: Options<GetGraphLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphLimitsResponses, GetGraphLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/limits',
        ...options
    });
};

/**
 * List Subgraphs
 * List all subgraphs for a parent graph.
 *
 * **Requirements:**
 * - Valid authentication
 * - Parent graph must exist and be accessible to the user
 * - User must have at least 'read' permission on the parent graph
 *
 * **Returns:**
 * - List of all subgraphs for the parent graph
 * - Each subgraph includes its ID, name, description, type, status, and creation date
 */
export const listSubgraphs = <ThrowOnError extends boolean = false>(options: Options<ListSubgraphsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListSubgraphsResponses, ListSubgraphsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs',
        ...options
    });
};

/**
 * Create Subgraph
 * Create a new subgraph within a parent graph, with optional data forking.
 *
 * **Requirements:**
 * - Valid authentication
 * - Parent graph must exist and be accessible to the user
 * - User must have 'admin' permission on the parent graph
 * - Parent graph tier must support subgraphs (Kuzu Large/XLarge or Neo4j Enterprise XLarge)
 * - Must be within subgraph quota limits
 * - Subgraph name must be unique within the parent graph
 *
 * **Fork Mode:**
 * When `fork_parent=true`, the operation:
 * - Returns immediately with an operation_id for SSE monitoring
 * - Copies data from parent graph to the new subgraph
 * - Supports selective forking via metadata.fork_options
 * - Tracks progress in real-time via SSE
 *
 * **Returns:**
 * - Without fork: Immediate SubgraphResponse with created subgraph details
 * - With fork: Operation response with SSE monitoring endpoint
 *
 * **Subgraph ID format:** `{parent_id}_{subgraph_name}` (e.g., kg1234567890abcdef_dev)
 *
 * **Usage:**
 * - Subgraphs share parent's credit pool
 * - Subgraph ID can be used in all standard `/v1/graphs/{graph_id}*` endpoints
 * - Permissions inherited from parent graph
 */
export const createSubgraph = <ThrowOnError extends boolean = false>(options: Options<CreateSubgraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateSubgraphResponses, CreateSubgraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Subgraph
 * Delete a subgraph database.
 *
 * **Requirements:**
 * - Must be a valid subgraph (not parent graph)
 * - User must have admin access to parent graph
 * - Subgraph name must be alphanumeric (1-20 characters)
 * - Optional backup before deletion
 *
 * **Deletion Options:**
 * - `force`: Delete even if contains data
 * - `backup_first`: Create backup before deletion
 *
 * **Warning:**
 * Deletion is permanent unless backup is created.
 * All data in the subgraph will be lost.
 *
 * **Backup Location:**
 * If backup requested, stored in S3 Kuzu database bucket at:
 * `s3://{kuzu_s3_bucket}/{instance_id}/{database_name}_{timestamp}.backup`
 *
 * **Notes:**
 * - Use the subgraph name (e.g., 'dev', 'staging') not the full subgraph ID
 * - Deletion does not affect parent graph's credit pool or permissions
 * - Backup creation consumes credits from parent graph's allocation
 */
export const deleteSubgraph = <ThrowOnError extends boolean = false>(options: Options<DeleteSubgraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteSubgraphResponses, DeleteSubgraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_name}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Subgraph Details
 * Get detailed information about a specific subgraph.
 *
 * **Requirements:**
 * - User must have read access to parent graph
 * - Subgraph name must be alphanumeric (1-20 characters)
 *
 * **Response includes:**
 * - Full subgraph metadata
 * - Database statistics (nodes, edges)
 * - Size information
 * - Schema configuration
 * - Creation/modification timestamps
 * - Last access time (when available)
 *
 * **Statistics:**
 * Real-time statistics queried from Kuzu:
 * - Node count
 * - Edge count
 * - Database size on disk
 * - Schema information
 *
 * **Note:**
 * Use the subgraph name (e.g., 'dev', 'staging') not the full subgraph ID.
 * The full ID is returned in the response (e.g., 'kg0123456789abcdef_dev').
 */
export const getSubgraphInfo = <ThrowOnError extends boolean = false>(options: Options<GetSubgraphInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSubgraphInfoResponses, GetSubgraphInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_name}/info',
        ...options
    });
};

/**
 * Get Subgraph Quota
 * Get subgraph quota and usage information for a parent graph.
 *
 * **Shows:**
 * - Current subgraph count
 * - Maximum allowed subgraphs per tier
 * - Remaining capacity
 * - Total size usage across all subgraphs
 *
 * **Tier Limits:**
 * - Standard: 0 subgraphs (not supported)
 * - Enterprise: Configurable limit (default: 10 subgraphs)
 * - Premium: Unlimited subgraphs
 * - Limits are defined in deployment configuration
 *
 * **Size Tracking:**
 * Provides aggregate size metrics when available.
 * Individual subgraph sizes shown in list endpoint.
 */
export const getSubgraphQuota = <ThrowOnError extends boolean = false>(options: Options<GetSubgraphQuotaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSubgraphQuotaResponses, GetSubgraphQuotaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs/quota',
        ...options
    });
};

/**
 * Get Subscription
 * Get subscription details for a graph or shared repository.
 *
 * For user graphs (kg*): Returns the graph's subscription (owned by graph creator)
 * For shared repositories (sec, industry, etc.): Returns user's personal subscription to that repository
 *
 * This unified endpoint automatically detects the resource type and returns the appropriate subscription.
 */
export const getGraphSubscription = <ThrowOnError extends boolean = false>(options: Options<GetGraphSubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphSubscriptionResponses, GetGraphSubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subscriptions',
        ...options
    });
};

/**
 * Create Repository Subscription
 * Create a new subscription to a shared repository.
 *
 * This endpoint is ONLY for shared repositories (sec, industry, economic).
 * User graph subscriptions are created automatically when the graph is provisioned.
 *
 * The subscription will be created in ACTIVE status immediately and credits will be allocated.
 */
export const createRepositorySubscription = <ThrowOnError extends boolean = false>(options: Options<CreateRepositorySubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateRepositorySubscriptionResponses, CreateRepositorySubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subscriptions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Upgrade Subscription
 * Upgrade a subscription to a different plan.
 *
 * Works for both user graphs and shared repositories.
 * The subscription will be immediately updated to the new plan and pricing.
 */
export const upgradeSubscription = <ThrowOnError extends boolean = false>(options: Options<UpgradeSubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpgradeSubscriptionResponses, UpgradeSubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subscriptions/upgrade',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Staging Tables
 * List all DuckDB staging tables with comprehensive metrics and status.
 *
 * Get a complete inventory of all staging tables for a graph, including
 * file counts, storage sizes, and row estimates. Essential for monitoring
 * the data pipeline and determining which tables are ready for ingestion.
 *
 * **Returned Metrics:**
 * - Table name and type (node/relationship)
 * - File count per table
 * - Total storage size in bytes
 * - Estimated row count
 * - S3 location pattern
 * - Ready-for-ingestion status
 *
 * **Use Cases:**
 * - Monitor data upload progress
 * - Check which tables have files ready
 * - Track storage consumption
 * - Validate pipeline before ingestion
 * - Capacity planning
 *
 * **Workflow:**
 * 1. List tables to see current state
 * 2. Upload files to empty tables
 * 3. Re-list to verify uploads
 * 4. Check file counts and sizes
 * 5. Ingest when ready
 *
 * **Important Notes:**
 * - Tables with `file_count > 0` have data ready
 * - Check `total_size_bytes` for storage monitoring
 * - Use `s3_location` to verify upload paths
 * - Empty tables (file_count=0) are skipped during ingestion
 * - Table queries are included - no credit consumption
 */
export const listTables = <ThrowOnError extends boolean = false>(options: Options<ListTablesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListTablesResponses, ListTablesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables',
        ...options
    });
};

/**
 * Query Staging Tables with SQL
 * Execute SQL queries on DuckDB staging tables for data inspection and validation.
 *
 * Query raw staging data directly with SQL before ingestion into the graph database.
 * Useful for data quality checks, validation, and exploratory analysis.
 *
 * **Security Best Practice - Use Parameterized Queries:**
 * ALWAYS use query parameters instead of string concatenation to prevent SQL injection:
 * - ✅ SAFE: `SELECT * FROM Entity WHERE type = ? LIMIT ?` with `parameters: ["Company", 100]`
 * - ❌ UNSAFE: `SELECT * FROM Entity WHERE type = 'Company' LIMIT 100` with user input concatenated into SQL string
 *
 * Query parameters provide automatic escaping and type safety. Use `?` placeholders with parameters array.
 *
 * **Use Cases:**
 * - Validate data quality before graph ingestion
 * - Inspect row-level data for debugging
 * - Run analytics on staging tables
 * - Check for duplicates, nulls, or data issues
 * - Preview data transformations
 *
 * **Workflow:**
 * 1. Upload data files via `POST /tables/{table_name}/files`
 * 2. Query staging tables to validate: `POST /tables/query`
 * 3. Fix any data issues by re-uploading
 * 4. Ingest validated data: `POST /tables/ingest`
 *
 * **Supported SQL:**
 * - Full DuckDB SQL syntax
 * - SELECT, JOIN, WHERE, GROUP BY, ORDER BY
 * - Aggregations, window functions, CTEs
 * - Multiple table joins across staging area
 *
 * **Common Operations:**
 * - Count rows: `SELECT COUNT(*) FROM Entity`
 * - Filter by type: `SELECT * FROM Entity WHERE entity_type = ? LIMIT ?` with `parameters: ["Company", 100]`
 * - Check for nulls: `SELECT * FROM Entity WHERE name IS NULL LIMIT 10`
 * - Find duplicates: `SELECT identifier, COUNT(*) as cnt FROM Entity GROUP BY identifier HAVING COUNT(*) > 1`
 * - Filter amounts: `SELECT * FROM Transaction WHERE amount > ? AND date >= ?` with `parameters: [1000, "2024-01-01"]`
 *
 * **Limits:**
 * - Query timeout: 30 seconds
 * - Result limit: 10,000 rows (use LIMIT clause)
 * - Read-only: No INSERT, UPDATE, DELETE
 * - User's tables only: Cannot query other users' data
 *
 * **Subgraph Support:**
 * This endpoint accepts both parent graph IDs and subgraph IDs.
 * - Parent graph: Use `graph_id` like `kg0123456789abcdef`
 * - Subgraph: Use full subgraph ID like `kg0123456789abcdef_dev`
 * Each subgraph has its own independent staging tables.
 *
 * **Shared Repositories:**
 * Shared repositories (SEC, etc.) do not allow direct SQL queries.
 * Use the graph query endpoint instead: `POST /v1/graphs/{graph_id}/query`
 *
 * **Note:**
 * Staging table queries are included - no credit consumption
 */
export const queryTables = <ThrowOnError extends boolean = false>(options: Options<QueryTablesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<QueryTablesResponses, QueryTablesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/query',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create View
 * Generate financial report view from data source (dual-mode support).
 *
 * **Mode 1: Transaction Aggregation (generate_from_transactions)**
 * - Aggregates raw transaction data to trial balance
 * - Creates facts on-demand
 * - Shows real-time reporting from source of truth
 *
 * **Mode 2: Existing Facts (pivot_existing_facts)**
 * - Queries existing Fact nodes
 * - Supports multi-dimensional analysis
 * - Works with SEC filings and pre-computed facts
 *
 * Both modes:
 * - Build FactGrid from data
 * - Generate pivot table presentation
 * - Return consistent response format
 */
export const createView = <ThrowOnError extends boolean = false>(options: Options<CreateViewData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateViewResponses, CreateViewErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/views',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Save View
 * Save or update view as materialized report in the graph.
 *
 * Converts computed view results into persistent Report, Fact, and Structure nodes.
 * This establishes what data exists in the subgraph, which then defines what
 * needs to be exported for publishing to the parent graph.
 *
 * **Create Mode** (no report_id provided):
 * - Generates new report_id from entity + period + report type
 * - Creates new Report, Facts, and Structures
 *
 * **Update Mode** (report_id provided):
 * - Deletes all existing Facts and Structures for the report
 * - Updates Report metadata
 * - Creates fresh Facts and Structures from current view
 * - Useful for refreshing reports with updated data or view configurations
 *
 * **This is NOT publishing** - it only creates nodes in the subgraph workspace.
 * Publishing (export → parquet → parent ingest) happens separately.
 *
 * Creates/Updates:
 * - Report node with metadata
 * - Fact nodes with all aspects (period, entity, element, unit)
 * - PresentationStructure nodes (how facts are displayed)
 * - CalculationStructure nodes (how facts roll up)
 *
 * Returns:
 * - report_id: Unique identifier used as parquet export prefix
 * - parquet_export_prefix: Filename prefix for future exports
 * - All created facts and structures
 */
export const saveView = <ThrowOnError extends boolean = false>(options: Options<SaveViewData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SaveViewResponses, SaveViewErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/views/save',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Materialization Status
 * Get current materialization status for the graph.
 *
 * Shows whether the graph is stale (DuckDB has changes not yet in graph database),
 * when it was last materialized, and how long since last materialization.
 *
 * **Status Information:**
 * - Whether graph is currently stale
 * - Reason for staleness if applicable
 * - When graph became stale
 * - When graph was last materialized
 * - Total materialization count
 * - Hours since last materialization
 *
 * **Use Cases:**
 * - Decide if materialization is needed
 * - Monitor graph freshness
 * - Track materialization history
 * - Understand data pipeline state
 *
 * **Important Notes:**
 * - Stale graph means DuckDB has changes not in graph
 * - Graph becomes stale after file deletions
 * - Materialization clears staleness
 * - Status retrieval is included - no credit consumption
 */
export const getMaterializationStatus = <ThrowOnError extends boolean = false>(options: Options<GetMaterializationStatusData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetMaterializationStatusResponses, GetMaterializationStatusErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/materialize/status',
        ...options
    });
};

/**
 * Materialize Graph from DuckDB
 * Rebuild entire graph from DuckDB staging tables (materialized view pattern).
 *
 * This endpoint rebuilds the complete graph database from the current state of DuckDB
 * staging tables. It automatically discovers all tables, ingests them in the correct
 * order (nodes before relationships), and clears the staleness flag.
 *
 * **When to Use:**
 * - After batch uploads (files uploaded with ingest_to_graph=false)
 * - After cascade file deletions (graph marked stale)
 * - To ensure graph consistency with DuckDB state
 * - Periodic full refresh
 *
 * **What Happens:**
 * 1. Discovers all tables for the graph from PostgreSQL registry
 * 2. Sorts tables (nodes before relationships)
 * 3. Ingests all tables from DuckDB to graph in order
 * 4. Clears staleness flag on success
 * 5. Returns detailed materialization report
 *
 * **Staleness Check:**
 * By default, only materializes if graph is stale (after deletions or missed ingestions).
 * Use `force=true` to rebuild regardless of staleness.
 *
 * **Rebuild Feature:**
 * Setting `rebuild=true` regenerates the entire graph database from scratch:
 * - Deletes existing graph database
 * - Recreates with fresh schema from active GraphSchema
 * - Ingests all data files
 * - Safe operation - DuckDB is source of truth
 * - Useful for schema changes or data corrections
 * - Graph marked as 'rebuilding' during process
 *
 * **Table Ordering:**
 * Node tables (PascalCase) are ingested before relationship tables (UPPERCASE) to
 * ensure referential integrity.
 *
 * **Error Handling:**
 * With `ignore_errors=true` (default), continues materializing even if individual
 * rows fail. Failed rows are logged but don't stop the process.
 *
 * **Concurrency Control:**
 * Only one materialization can run per graph at a time. If another materialization is in progress,
 * you'll receive a 409 Conflict error. The distributed lock automatically expires after
 * the configured TTL (default: 1 hour) to prevent deadlocks from failed materializations.
 *
 * **Performance:**
 * Full graph materialization can take minutes for large datasets. Consider running
 * during off-peak hours for production systems.
 *
 * **Credits:**
 * Materialization is included - no credit consumption
 */
export const materializeGraph = <ThrowOnError extends boolean = false>(options: Options<MaterializeGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<MaterializeGraphResponses, MaterializeGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/materialize',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Files in Graph
 * List all files in the graph with optional filtering.
 *
 * Get a complete inventory of files across all tables or filtered by table name,
 * status, or other criteria. Files are first-class resources with independent lifecycle.
 *
 * **Query Parameters:**
 * - `table_name` (optional): Filter by table name
 * - `status` (optional): Filter by upload status (uploaded, pending, failed, etc.)
 *
 * **Use Cases:**
 * - Monitor file upload progress across all tables
 * - Verify files are ready for ingestion
 * - Check file metadata and sizes
 * - Track storage usage per graph
 * - Identify failed or incomplete uploads
 * - Audit file provenance
 *
 * **Returned Metadata:**
 * - File ID, name, and format (parquet, csv, json)
 * - Size in bytes and row count (if available)
 * - Upload status and timestamps
 * - DuckDB and graph ingestion status
 * - Table association
 *
 * **File Lifecycle Tracking:**
 * Multi-layer status across S3 → DuckDB → Graph pipeline
 *
 * **Important Notes:**
 * - Files are graph-scoped, not table-scoped
 * - Use table_name parameter to filter by table
 * - File listing is included - no credit consumption
 */
export const listFiles = <ThrowOnError extends boolean = false>(options: Options<ListFilesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListFilesResponses, ListFilesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/files',
        ...options
    });
};

/**
 * Create File Upload
 * Generate presigned S3 URL for file upload.
 *
 * Initiate file upload by generating a secure, time-limited presigned S3 URL.
 * Files are first-class resources uploaded directly to S3.
 *
 * **Request Body:**
 * - `file_name`: Name of the file (1-255 characters)
 * - `file_format`: Format (parquet, csv, json)
 * - `table_name`: Table to associate file with
 *
 * **Upload Workflow:**
 * 1. Call this endpoint to get presigned URL
 * 2. PUT file directly to S3 URL
 * 3. Call PATCH /files/{file_id} with status='uploaded'
 * 4. Backend validates and stages in DuckDB immediately
 * 5. Background task ingests to graph
 *
 * **Supported Formats:**
 * - Parquet, CSV, JSON
 *
 * **Auto-Table Creation:**
 * Tables are automatically created if they don't exist.
 *
 * **Important Notes:**
 * - Presigned URLs expire (default: 1 hour)
 * - Files are graph-scoped, independent resources
 * - Upload URL generation is included - no credit consumption
 */
export const createFileUpload = <ThrowOnError extends boolean = false>(options: Options<CreateFileUploadData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateFileUploadResponses, CreateFileUploadErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/files',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete File
 * Delete file from all layers.
 *
 * Remove file from S3, database tracking, and optionally from DuckDB and graph.
 * Files are deleted by file_id, independent of table context.
 *
 * **Query Parameters:**
 * - `cascade` (optional, default=false): Delete from all layers including DuckDB
 *
 * **What Happens (cascade=false):**
 * 1. File deleted from S3
 * 2. Database record removed
 * 3. Table statistics updated
 *
 * **What Happens (cascade=true):**
 * 1. File data deleted from all DuckDB tables (by file_id)
 * 2. Graph marked as stale
 * 3. File deleted from S3
 * 4. Database record removed
 * 5. Table statistics updated
 *
 * **Use Cases:**
 * - Remove incorrect or duplicate files
 * - Clean up failed uploads
 * - Delete files before graph ingestion
 * - Surgical data removal with cascade
 *
 * **Security:**
 * - Write access required
 * - Shared repositories block deletions
 * - Full audit trail
 *
 * **Important:**
 * - Use cascade=true for immediate DuckDB cleanup
 * - Graph rebuild recommended after cascade deletion
 * - File deletion is included - no credit consumption
 */
export const deleteFile = <ThrowOnError extends boolean = false>(options: Options<DeleteFileData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteFileResponses, DeleteFileErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/files/{file_id}',
        ...options
    });
};

/**
 * Get File Information
 * Get detailed information about a specific file.
 *
 * Retrieve comprehensive metadata for a single file by file_id, independent of
 * table context. Files are first-class resources with complete lifecycle tracking.
 *
 * **Returned Information:**
 * - File ID, name, format, size
 * - Upload status and timestamps
 * - **Enhanced Multi-Layer Status** (new in this version):
 * - S3 layer: upload_status, uploaded_at, size_bytes, row_count
 * - DuckDB layer: duckdb_status, duckdb_staged_at, duckdb_row_count
 * - Graph layer: graph_status, graph_ingested_at
 * - Table association
 * - S3 location
 *
 * **Multi-Layer Pipeline Visibility:**
 * The `layers` object provides independent status tracking across the three-tier
 * data pipeline:
 * - **S3 (Immutable Source)**: File upload and validation
 * - **DuckDB (Mutable Staging)**: Immediate queryability with file provenance
 * - **Graph (Immutable View)**: Optional graph database materialization
 *
 * Each layer shows its own status, timestamp, and row count (where applicable),
 * enabling precise debugging and monitoring of the data ingestion flow.
 *
 * **Use Cases:**
 * - Validate file upload completion
 * - Monitor multi-layer ingestion progress in real-time
 * - Debug upload or staging issues at specific layers
 * - Verify file metadata and row counts
 * - Track file provenance through the pipeline
 * - Identify bottlenecks in the ingestion process
 *
 * **Note:**
 * File info retrieval is included - no credit consumption
 */
export const getFile = <ThrowOnError extends boolean = false>(options: Options<GetFileData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFileResponses, GetFileErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/files/{file_id}',
        ...options
    });
};

/**
 * Update File Status
 * Update file status and trigger processing.
 *
 * Update file status after upload completion. Setting status='uploaded' triggers
 * immediate DuckDB staging and optional graph ingestion.
 *
 * **Request Body:**
 * - `status`: New status (uploaded, disabled, failed)
 * - `ingest_to_graph` (optional): If true, auto-ingest to graph after DuckDB staging
 *
 * **What Happens (status='uploaded'):**
 * 1. File validated in S3
 * 2. Row count calculated
 * 3. DuckDB staging triggered immediately (Celery task)
 * 4. If ingest_to_graph=true, graph ingestion queued
 * 5. File queryable in DuckDB within seconds
 *
 * **Use Cases:**
 * - Signal upload completion
 * - Trigger immediate DuckDB staging
 * - Enable/disable files
 * - Mark failed uploads
 *
 * **Important:**
 * - Files must exist in S3 before marking uploaded
 * - DuckDB staging happens asynchronously
 * - Graph ingestion is optional (ingest_to_graph flag)
 */
export const updateFile = <ThrowOnError extends boolean = false>(options: Options<UpdateFileData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<UpdateFileResponses, UpdateFileErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/files/{file_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get User Graphs and Repositories
 * List all graph databases and shared repositories accessible to the current user.
 *
 * Returns a unified list of both user-created graphs and shared repositories (like SEC data)
 * that the user has access to, including their role/access level and selection status.
 *
 * **Returned Information:**
 * - Graph/Repository ID and display name
 * - User's role/access level (admin/member for graphs, read/write/admin for repositories)
 * - Selection status (only user graphs can be selected)
 * - Creation timestamp
 * - Repository type indicator (isRepository: true for shared repositories)
 *
 * **User Graphs (isRepository: false):**
 * - Collaborative workspaces that can be shared with other users
 * - Roles: `admin` (full access, can invite users) or `member` (read/write access)
 * - Can be selected as active workspace
 * - Graphs you create or have been invited to
 *
 * **Shared Repositories (isRepository: true):**
 * - Read-only data repositories like SEC filings, industry benchmarks
 * - Access levels: `read`, `write` (for data contributions), `admin`
 * - Cannot be selected (each has separate subscription)
 * - Require separate subscriptions (personal, cannot be shared)
 *
 * **Selected Graph Concept:**
 * The "selected" graph is the user's currently active workspace (user graphs only).
 * Many API operations default to the selected graph if no graph_id is provided.
 * Users can change their selected graph via `POST /v1/graphs/{graph_id}/select`.
 *
 * **Use Cases:**
 * - Display unified graph/repository selector in UI
 * - Show all accessible data sources (both owned graphs and subscribed repositories)
 * - Identify currently active workspace
 * - Filter by type (user graphs vs repositories)
 *
 * **Empty Response:**
 * New users receive an empty list with `selectedGraphId: null`. Users should create
 * a graph or subscribe to a repository.
 *
 * **Note:**
 * Graph listing is included - no credit consumption required.
 */
export const getGraphs = <ThrowOnError extends boolean = false>(options?: Options<GetGraphsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetGraphsResponses, GetGraphsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs',
        ...options
    });
};

/**
 * Create New Graph Database
 * Create a new graph database with specified schema and optionally an initial entity.
 *
 * This endpoint starts an asynchronous graph creation operation and returns
 * connection details for monitoring progress via Server-Sent Events (SSE).
 *
 * **Graph Creation Options:**
 *
 * 1. **Entity Graph with Initial Entity** (`initial_entity` provided, `create_entity=True`):
 * - Creates graph structure with entity schema extensions
 * - Populates an initial entity node with provided data
 * - Useful when you want a pre-configured entity to start with
 * - Example: Creating a company graph with the company already populated
 *
 * 2. **Entity Graph without Initial Entity** (`initial_entity=None`, `create_entity=False`):
 * - Creates graph structure with entity schema extensions
 * - Graph starts empty, ready for data import
 * - Useful for bulk data imports or custom workflows
 * - Example: Creating a graph structure before importing from CSV/API
 *
 * 3. **Generic Graph** (no `initial_entity` provided):
 * - Creates empty graph with custom schema extensions
 * - General-purpose knowledge graph
 * - Example: Analytics graphs, custom data models
 *
 * **Required Fields:**
 * - `metadata.graph_name`: Unique name for the graph
 * - `instance_tier`: Resource tier (kuzu-standard, kuzu-large, kuzu-xlarge)
 *
 * **Optional Fields:**
 * - `metadata.description`: Human-readable description of the graph's purpose
 * - `metadata.schema_extensions`: List of schema extensions (roboledger, roboinvestor, etc.)
 * - `tags`: Organizational tags (max 10)
 * - `initial_entity`: Entity data (required for entity graphs with initial data)
 * - `create_entity`: Whether to populate initial entity (default: true when initial_entity provided)
 *
 * **Monitoring Progress:**
 * Use the returned `operation_id` to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.onmessage = (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Progress:', data.progress_percent + '%');
 * };
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Events Emitted:**
 * - `operation_started`: Graph creation begins
 * - `operation_progress`: Schema loading, database setup, etc.
 * - `operation_completed`: Graph ready with connection details
 * - `operation_error`: Creation failed with error details
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: SSE connection limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - Clients should implement exponential backoff on errors
 *
 * **Response includes:**
 * - `operation_id`: Unique identifier for monitoring
 * - `_links.stream`: SSE endpoint for real-time updates
 * - `_links.status`: Point-in-time status check endpoint
 */
export const createGraph = <ThrowOnError extends boolean = false>(options: Options<CreateGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateGraphResponses, CreateGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Available Schema Extensions
 * List all available schema extensions for graph creation.
 *
 * Schema extensions provide pre-built industry-specific data models that extend
 * the base graph schema with specialized nodes, relationships, and properties.
 *
 * **Available Extensions:**
 * - **RoboLedger**: Complete accounting system with XBRL reporting, general ledger, and financial statements
 * - **RoboInvestor**: Investment portfolio management and tracking
 * - **RoboSCM**: Supply chain management and logistics
 * - **RoboFO**: Front office operations and CRM
 * - **RoboHRM**: Human resources management
 * - **RoboEPM**: Enterprise performance management
 * - **RoboReport**: Business intelligence and reporting
 *
 * **Extension Information:**
 * Each extension includes:
 * - Display name and description
 * - Node and relationship counts
 * - Context-aware capabilities (e.g., SEC repositories get different features than entity graphs)
 *
 * **Use Cases:**
 * - Browse available extensions before creating a graph
 * - Understand extension capabilities and data models
 * - Plan graph schema based on business requirements
 * - Combine multiple extensions for comprehensive data modeling
 *
 * **Note:**
 * Extension listing is included - no credit consumption required.
 */
export const getAvailableExtensions = <ThrowOnError extends boolean = false>(options?: Options<GetAvailableExtensionsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAvailableExtensionsResponses, GetAvailableExtensionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/extensions',
        ...options
    });
};

/**
 * Get Available Graph Tiers
 * List all available graph database tier configurations.
 *
 * This endpoint provides comprehensive technical specifications for each available
 * graph database tier, including instance types, resource limits, and features.
 *
 * **Tier Information:**
 * Each tier includes:
 * - Technical specifications (instance type, memory, storage)
 * - Resource limits (subgraphs, credits, rate limits)
 * - Feature list with capabilities
 * - Availability status
 *
 * **Available Tiers:**
 * - **kuzu-standard**: Multi-tenant entry-level tier
 * - **kuzu-large**: Dedicated professional tier with subgraph support
 * - **kuzu-xlarge**: Enterprise tier with maximum resources
 * - **neo4j-community-large**: Neo4j Community Edition (optional, if enabled)
 * - **neo4j-enterprise-xlarge**: Neo4j Enterprise Edition (optional, if enabled)
 *
 * **Use Cases:**
 * - Display tier options in graph creation UI
 * - Show technical specifications for tier selection
 * - Validate tier availability before graph creation
 * - Display feature comparisons
 *
 * **Note:**
 * Tier listing is included - no credit consumption required.
 */
export const getAvailableGraphTiers = <ThrowOnError extends boolean = false>(options?: Options<GetAvailableGraphTiersData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAvailableGraphTiersResponses, GetAvailableGraphTiersErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/tiers',
        ...options
    });
};

/**
 * Select Graph
 * Select a specific graph as the active workspace for the user.
 *
 * The selected graph becomes the default context for operations in client applications
 * and can be used to maintain user workspace preferences across sessions.
 *
 * **Functionality:**
 * - Sets the specified graph as the user's currently selected graph
 * - Deselects any previously selected graph (only one can be selected at a time)
 * - Persists selection across sessions until changed
 * - Returns confirmation with the selected graph ID
 *
 * **Requirements:**
 * - User must have access to the graph (as admin or member)
 * - Graph must exist and not be deleted
 * - User can only select graphs they have permission to access
 *
 * **Use Cases:**
 * - Switch between multiple graphs in a multi-graph environment
 * - Set default workspace after creating a new graph
 * - Restore user's preferred workspace on login
 * - Support graph context switching in client applications
 *
 * **Client Integration:**
 * Many client operations can default to the selected graph, simplifying API calls
 * by eliminating the need to specify graph_id repeatedly. Check the selected
 * graph with `GET /v1/graphs` which returns `selectedGraphId`.
 *
 * **Note:**
 * Graph selection is included - no credit consumption required.
 */
export const selectGraph = <ThrowOnError extends boolean = false>(options: Options<SelectGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SelectGraphResponses, SelectGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/select',
        ...options
    });
};

/**
 * Get Service Offerings
 * Get comprehensive information about all subscription offerings.
 *
 * This endpoint provides complete information about both graph database subscriptions
 * and shared repository subscriptions. This is the primary endpoint for frontend
 * applications to display subscription options.
 *
 * **Pricing Model:**
 * - Graph subscriptions are **per-graph** with infrastructure-based pricing
 * - Each graph you create has its own monthly subscription
 * - Organizations can have multiple graphs with different infrastructure tiers
 * - Credits are allocated per-graph, not shared across organization
 *
 * Includes:
 * - Graph infrastructure tiers (kuzu-standard, kuzu-large, kuzu-xlarge) - per-graph pricing
 * - Shared repository subscriptions (SEC, industry, economic data) - org-level
 * - Operation costs and credit information
 * - Features and capabilities for each tier
 * - Enabled/disabled status for repositories
 *
 * All data comes from the config-based systems to ensure accuracy with backend behavior.
 *
 * No authentication required - this is public service information.
 */
export const getServiceOfferings = <ThrowOnError extends boolean = false>(options?: Options<GetServiceOfferingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetServiceOfferingsResponses, GetServiceOfferingsErrors, ThrowOnError>({
        url: '/v1/offering',
        ...options
    });
};

/**
 * Stream Operation Events
 * Stream real-time events for an operation using Server-Sent Events (SSE).
 *
 * This endpoint provides real-time monitoring for all non-immediate operations including:
 * - Graph creation and management
 * - Agent analysis processing
 * - Database backups and restores
 * - Data synchronization tasks
 *
 * **Event Types:**
 * - `operation_started`: Operation began execution
 * - `operation_progress`: Progress update with details
 * - `operation_completed`: Operation finished successfully
 * - `operation_error`: Operation failed with error details
 * - `operation_cancelled`: Operation was cancelled
 *
 * **Features:**
 * - **Event Replay**: Use `from_sequence` parameter to replay missed events
 * - **Automatic Reconnection**: Client can reconnect and resume from last seen event
 * - **Real-time Updates**: Live progress updates during execution
 * - **Timeout Handling**: 30-second keepalive messages prevent connection timeouts
 * - **Graceful Degradation**: Automatic fallback if Redis is unavailable
 *
 * **Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic cleanup of stale connections
 * - Circuit breaker protection for Redis failures
 *
 * **Client Usage:**
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/abc123/stream');
 * eventSource.onmessage = (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Progress:', data);
 * };
 * eventSource.onerror = (error) => {
 * // Handle connection errors or rate limits
 * console.error('SSE Error:', error);
 * };
 * ```
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Connection limit or rate limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - Clients should implement exponential backoff on errors
 *
 * **No credits are consumed for SSE connections.**
 */
export const streamOperationEvents = <ThrowOnError extends boolean = false>(options: Options<StreamOperationEventsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StreamOperationEventsResponses, StreamOperationEventsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}/stream',
        ...options
    });
};

/**
 * Get Operation Status
 * Get current status and metadata for an operation.
 *
 * Returns detailed information including:
 * - Current status (pending, running, completed, failed, cancelled)
 * - Creation and update timestamps
 * - Operation type and associated graph
 * - Result data (for completed operations)
 * - Error details (for failed operations)
 *
 * This endpoint provides a point-in-time status check, while the `/stream` endpoint
 * provides real-time updates. Use this for polling or initial status checks.
 *
 * **No credits are consumed for status checks.**
 */
export const getOperationStatus = <ThrowOnError extends boolean = false>(options: Options<GetOperationStatusData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOperationStatusResponses, GetOperationStatusErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}/status',
        ...options
    });
};

/**
 * Cancel Operation
 * Cancel a pending or running operation.
 *
 * Cancels the specified operation if it's still in progress. Once cancelled,
 * the operation cannot be resumed and will emit a cancellation event to any
 * active SSE connections.
 *
 * **Note**: Completed or already failed operations cannot be cancelled.
 *
 * **No credits are consumed for cancellation requests.**
 */
export const cancelOperation = <ThrowOnError extends boolean = false>(options: Options<CancelOperationData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<CancelOperationResponses, CancelOperationErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}',
        ...options
    });
};

/**
 * Get Organization Customer Info
 * Get billing customer information for an organization including payment methods on file.
 *
 * Returns customer details, payment methods, and whether invoice billing is enabled.
 *
 * **Requirements:**
 * - User must be a member of the organization
 * - Sensitive payment details are only visible to owners
 */
export const getOrgBillingCustomer = <ThrowOnError extends boolean = false>(options: Options<GetOrgBillingCustomerData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOrgBillingCustomerResponses, GetOrgBillingCustomerErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/billing/customer/{org_id}',
        ...options
    });
};

/**
 * Create Customer Portal Session
 * Create a Stripe Customer Portal session for managing payment methods.
 *
 * The portal allows users to:
 * - Add new payment methods
 * - Remove existing payment methods
 * - Update default payment method
 * - View billing history
 *
 * The user will be redirected to Stripe's hosted portal page and returned to the billing page when done.
 *
 * **Requirements:**
 * - User must be an OWNER of the organization
 * - Organization must have a Stripe customer ID (i.e., has gone through checkout at least once)
 */
export const createPortalSession = <ThrowOnError extends boolean = false>(options: Options<CreatePortalSessionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreatePortalSessionResponses, CreatePortalSessionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/billing/customer/{org_id}/portal',
        ...options
    });
};

/**
 * List Organization Subscriptions
 * List all active and past subscriptions for an organization.
 *
 * Includes both graph and repository subscriptions with their status, pricing, and billing information.
 *
 * **Requirements:**
 * - User must be a member of the organization
 */
export const listOrgSubscriptions = <ThrowOnError extends boolean = false>(options: Options<ListOrgSubscriptionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListOrgSubscriptionsResponses, ListOrgSubscriptionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/billing/subscriptions/{org_id}',
        ...options
    });
};

/**
 * Get Organization Subscription Details
 * Get detailed information about a specific subscription.
 *
 * **Requirements:**
 * - User must be a member of the organization
 */
export const getOrgSubscription = <ThrowOnError extends boolean = false>(options: Options<GetOrgSubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOrgSubscriptionResponses, GetOrgSubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/billing/subscriptions/{org_id}/subscription/{subscription_id}',
        ...options
    });
};

/**
 * Cancel Organization Subscription
 * Cancel an organization subscription.
 *
 * The subscription will remain active until the end of the current billing period.
 *
 * **Requirements:**
 * - User must be an OWNER of the organization
 */
export const cancelOrgSubscription = <ThrowOnError extends boolean = false>(options: Options<CancelOrgSubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CancelOrgSubscriptionResponses, CancelOrgSubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/billing/subscriptions/{org_id}/subscription/{subscription_id}/cancel',
        ...options
    });
};

/**
 * List Organization Invoices
 * List payment history and invoices for an organization.
 *
 * Returns past invoices with payment status, amounts, and line items.
 *
 * **Requirements:**
 * - User must be a member of the organization
 * - Full invoice details are only visible to owners and admins
 */
export const listOrgInvoices = <ThrowOnError extends boolean = false>(options: Options<ListOrgInvoicesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListOrgInvoicesResponses, ListOrgInvoicesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/billing/invoices/{org_id}',
        ...options
    });
};

/**
 * Get Organization Upcoming Invoice
 * Get preview of the next invoice for an organization.
 *
 * Returns estimated charges for the next billing period.
 *
 * **Requirements:**
 * - User must be a member of the organization
 * - Full invoice details are only visible to owners and admins
 */
export const getOrgUpcomingInvoice = <ThrowOnError extends boolean = false>(options: Options<GetOrgUpcomingInvoiceData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOrgUpcomingInvoiceResponses, GetOrgUpcomingInvoiceErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/billing/invoices/{org_id}/upcoming',
        ...options
    });
};

/**
 * Create Payment Checkout Session
 * Create a Stripe checkout session for collecting payment method.
 *
 * This endpoint is used when an organization owner needs to add a payment method before
 * provisioning resources. It creates a pending subscription and redirects
 * to Stripe Checkout to collect payment details.
 *
 * **Flow:**
 * 1. Owner tries to create a graph but org has no payment method
 * 2. Frontend calls this endpoint with graph configuration
 * 3. Backend creates a subscription in PENDING_PAYMENT status for the user's org
 * 4. Returns Stripe Checkout URL
 * 5. User completes payment on Stripe
 * 6. Webhook activates subscription and provisions resource
 *
 * **Requirements:**
 * - User must be an OWNER of their organization
 * - Enterprise customers (with invoice_billing_enabled) should not call this endpoint.
 */
export const createCheckoutSession = <ThrowOnError extends boolean = false>(options: Options<CreateCheckoutSessionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateCheckoutSessionResponses, CreateCheckoutSessionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/billing/checkout',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Checkout Session Status
 * Poll the status of a checkout session.
 *
 * Frontend should poll this endpoint after user returns from Stripe Checkout
 * to determine when the resource is ready.
 *
 * **Status Values:**
 * - `pending_payment`: Waiting for payment to complete
 * - `provisioning`: Payment confirmed, resource being created
 * - `completed`: Resource is ready (resource_id will be set)
 * - `failed`: Something went wrong (error field will be set)
 *
 * **When status is 'completed':**
 * - For graphs: `resource_id` will be the graph_id, and `operation_id` can be used to monitor SSE progress
 * - For repositories: `resource_id` will be the repository name and access is immediately available
 */
export const getCheckoutStatus = <ThrowOnError extends boolean = false>(options: Options<GetCheckoutStatusData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCheckoutStatusResponses, GetCheckoutStatusErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/billing/checkout/{session_id}/status',
        ...options
    });
};