// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type { RegisterUserData, RegisterUserResponses, RegisterUserErrors, LoginUserData, LoginUserResponses, LoginUserErrors, LogoutUserData, LogoutUserResponses, LogoutUserErrors, GetCurrentAuthUserData, GetCurrentAuthUserResponses, GetCurrentAuthUserErrors, RefreshSessionData, RefreshSessionResponses, RefreshSessionErrors, GenerateSsoTokenData, GenerateSsoTokenResponses, GenerateSsoTokenErrors, SsoLoginData, SsoLoginResponses, SsoLoginErrors, SsoTokenExchangeData, SsoTokenExchangeResponses, SsoTokenExchangeErrors, CompleteSsoAuthData, CompleteSsoAuthResponses, CompleteSsoAuthErrors, GetPasswordPolicyData, GetPasswordPolicyResponses, CheckPasswordStrengthData, CheckPasswordStrengthResponses, CheckPasswordStrengthErrors, GetCaptchaConfigData, GetCaptchaConfigResponses, GetServiceStatusData, GetServiceStatusResponses, GetCurrentUserData, GetCurrentUserResponses, GetCurrentUserErrors, UpdateUserData, UpdateUserResponses, UpdateUserErrors, GetUserGraphsData, GetUserGraphsResponses, GetUserGraphsErrors, SelectUserGraphData, SelectUserGraphResponses, SelectUserGraphErrors, GetAllCreditSummariesData, GetAllCreditSummariesResponses, GetAllCreditSummariesErrors, UpdateUserPasswordData, UpdateUserPasswordResponses, UpdateUserPasswordErrors, ListUserApiKeysData, ListUserApiKeysResponses, ListUserApiKeysErrors, CreateUserApiKeyData, CreateUserApiKeyResponses, CreateUserApiKeyErrors, RevokeUserApiKeyData, RevokeUserApiKeyResponses, RevokeUserApiKeyErrors, UpdateUserApiKeyData, UpdateUserApiKeyResponses, UpdateUserApiKeyErrors, GetUserLimitsData, GetUserLimitsResponses, GetUserLimitsErrors, GetUserUsageData, GetUserUsageResponses, GetUserUsageErrors, GetAllSharedRepositoryLimitsData, GetAllSharedRepositoryLimitsResponses, GetAllSharedRepositoryLimitsErrors, GetSharedRepositoryLimitsData, GetSharedRepositoryLimitsResponses, GetSharedRepositoryLimitsErrors, GetUserUsageOverviewData, GetUserUsageOverviewResponses, GetUserUsageOverviewErrors, GetDetailedUserAnalyticsData, GetDetailedUserAnalyticsResponses, GetDetailedUserAnalyticsErrors, GetUserSharedSubscriptionsData, GetUserSharedSubscriptionsResponses, GetUserSharedSubscriptionsErrors, SubscribeToSharedRepositoryData, SubscribeToSharedRepositoryResponses, SubscribeToSharedRepositoryErrors, UpgradeSharedRepositorySubscriptionData, UpgradeSharedRepositorySubscriptionResponses, UpgradeSharedRepositorySubscriptionErrors, CancelSharedRepositorySubscriptionData, CancelSharedRepositorySubscriptionResponses, CancelSharedRepositorySubscriptionErrors, GetSharedRepositoryCreditsData, GetSharedRepositoryCreditsResponses, GetSharedRepositoryCreditsErrors, GetRepositoryCreditsData, GetRepositoryCreditsResponses, GetRepositoryCreditsErrors, GetConnectionOptionsData, GetConnectionOptionsResponses, GetConnectionOptionsErrors, SyncConnectionData, SyncConnectionResponses, SyncConnectionErrors, CreateLinkTokenData, CreateLinkTokenResponses, CreateLinkTokenErrors, ExchangeLinkTokenData, ExchangeLinkTokenResponses, ExchangeLinkTokenErrors, InitOAuthData, InitOAuthResponses, InitOAuthErrors, OauthCallbackData, OauthCallbackResponses, OauthCallbackErrors, ListConnectionsData, ListConnectionsResponses, ListConnectionsErrors, CreateConnectionData, CreateConnectionResponses, CreateConnectionErrors, DeleteConnectionData, DeleteConnectionResponses, DeleteConnectionErrors, GetConnectionData, GetConnectionResponses, GetConnectionErrors, AutoSelectAgentData, AutoSelectAgentResponses, AutoSelectAgentErrors, ExecuteSpecificAgentData, ExecuteSpecificAgentResponses, ExecuteSpecificAgentErrors, BatchProcessQueriesData, BatchProcessQueriesResponses, BatchProcessQueriesErrors, ListAgentsData, ListAgentsResponses, ListAgentsErrors, GetAgentMetadataData, GetAgentMetadataResponses, GetAgentMetadataErrors, RecommendAgentData, RecommendAgentResponses, RecommendAgentErrors, ListMcpToolsData, ListMcpToolsResponses, ListMcpToolsErrors, CallMcpToolData, CallMcpToolResponses, CallMcpToolErrors, ListBackupsData, ListBackupsResponses, ListBackupsErrors, CreateBackupData, CreateBackupResponses, CreateBackupErrors, ExportBackupData, ExportBackupResponses, ExportBackupErrors, GetBackupDownloadUrlData, GetBackupDownloadUrlResponses, GetBackupDownloadUrlErrors, RestoreBackupData, RestoreBackupResponses, RestoreBackupErrors, GetBackupStatsData, GetBackupStatsResponses, GetBackupStatsErrors, GetGraphMetricsData, GetGraphMetricsResponses, GetGraphMetricsErrors, GetGraphUsageStatsData, GetGraphUsageStatsResponses, GetGraphUsageStatsErrors, ExecuteCypherQueryData, ExecuteCypherQueryResponses, ExecuteCypherQueryErrors, GetGraphSchemaInfoData, GetGraphSchemaInfoResponses, GetGraphSchemaInfoErrors, ValidateSchemaData, ValidateSchemaResponses, ValidateSchemaErrors, ExportGraphSchemaData, ExportGraphSchemaResponses, ExportGraphSchemaErrors, ListSchemaExtensionsData, ListSchemaExtensionsResponses, ListSchemaExtensionsErrors, GetCurrentGraphBillData, GetCurrentGraphBillResponses, GetCurrentGraphBillErrors, GetGraphUsageDetailsData, GetGraphUsageDetailsResponses, GetGraphUsageDetailsErrors, GetGraphBillingHistoryData, GetGraphBillingHistoryResponses, GetGraphBillingHistoryErrors, GetGraphMonthlyBillData, GetGraphMonthlyBillResponses, GetGraphMonthlyBillErrors, GetCreditSummaryData, GetCreditSummaryResponses, GetCreditSummaryErrors, ListCreditTransactionsData, ListCreditTransactionsResponses, ListCreditTransactionsErrors, CheckCreditBalanceData, CheckCreditBalanceResponses, CheckCreditBalanceErrors, GetStorageUsageData, GetStorageUsageResponses, GetStorageUsageErrors, CheckStorageLimitsData, CheckStorageLimitsResponses, CheckStorageLimitsErrors, GetDatabaseHealthData, GetDatabaseHealthResponses, GetDatabaseHealthErrors, GetDatabaseInfoData, GetDatabaseInfoResponses, GetDatabaseInfoErrors, GetGraphLimitsData, GetGraphLimitsResponses, GetGraphLimitsErrors, ListSubgraphsData, ListSubgraphsResponses, ListSubgraphsErrors, CreateSubgraphData, CreateSubgraphResponses, CreateSubgraphErrors, DeleteSubgraphData, DeleteSubgraphResponses, DeleteSubgraphErrors, GetSubgraphInfoData, GetSubgraphInfoResponses, GetSubgraphInfoErrors, GetSubgraphQuotaData, GetSubgraphQuotaResponses, GetSubgraphQuotaErrors, CopyDataToGraphData, CopyDataToGraphResponses, CopyDataToGraphErrors, CreateGraphData, CreateGraphResponses, CreateGraphErrors, GetAvailableExtensionsData, GetAvailableExtensionsResponses, GetServiceOfferingsData, GetServiceOfferingsResponses, GetServiceOfferingsErrors, StreamOperationEventsData, StreamOperationEventsResponses, StreamOperationEventsErrors, GetOperationStatusData, GetOperationStatusResponses, GetOperationStatusErrors, CancelOperationData, CancelOperationResponses, CancelOperationErrors } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Register New User
 * Register a new user account with email and password. Security controls vary by environment: CAPTCHA and email verification are disabled in development for API testing, but required in production.
 */
export const registerUser = <ThrowOnError extends boolean = false>(options: Options<RegisterUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RegisterUserResponses, RegisterUserErrors, ThrowOnError>({
        url: '/v1/auth/register',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * User Login
 * Authenticate user with email and password.
 */
export const loginUser = <ThrowOnError extends boolean = false>(options: Options<LoginUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<LoginUserResponses, LoginUserErrors, ThrowOnError>({
        url: '/v1/auth/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * User Logout
 * Logout user and invalidate session.
 */
export const logoutUser = <ThrowOnError extends boolean = false>(options?: Options<LogoutUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<LogoutUserResponses, LogoutUserErrors, ThrowOnError>({
        url: '/v1/auth/logout',
        ...options
    });
};

/**
 * Get Current User
 * Get current authenticated user from session.
 */
export const getCurrentAuthUser = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentAuthUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCurrentAuthUserResponses, GetCurrentAuthUserErrors, ThrowOnError>({
        url: '/v1/auth/me',
        ...options
    });
};

/**
 * Refresh Session
 * Refresh user session and extend authentication token.
 */
export const refreshSession = <ThrowOnError extends boolean = false>(options?: Options<RefreshSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RefreshSessionResponses, RefreshSessionErrors, ThrowOnError>({
        url: '/v1/auth/refresh',
        ...options
    });
};

/**
 * Generate SSO Token
 * Generate a temporary SSO token for cross-app authentication.
 */
export const generateSsoToken = <ThrowOnError extends boolean = false>(options?: Options<GenerateSsoTokenData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GenerateSsoTokenResponses, GenerateSsoTokenErrors, ThrowOnError>({
        url: '/v1/auth/sso-token',
        ...options
    });
};

/**
 * SSO Login
 * Authenticate user with SSO token and establish session.
 */
export const ssoLogin = <ThrowOnError extends boolean = false>(options: Options<SsoLoginData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SsoLoginResponses, SsoLoginErrors, ThrowOnError>({
        url: '/v1/auth/sso-login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * SSO Token Exchange
 * Exchange SSO token for secure session handoff to target application.
 */
export const ssoTokenExchange = <ThrowOnError extends boolean = false>(options: Options<SsoTokenExchangeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SsoTokenExchangeResponses, SsoTokenExchangeErrors, ThrowOnError>({
        url: '/v1/auth/sso-exchange',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Complete SSO Authentication
 * Complete SSO authentication using session ID from secure handoff.
 */
export const completeSsoAuth = <ThrowOnError extends boolean = false>(options: Options<CompleteSsoAuthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CompleteSsoAuthResponses, CompleteSsoAuthErrors, ThrowOnError>({
        url: '/v1/auth/sso-complete',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Password Policy
 * Get current password policy requirements for frontend validation
 */
export const getPasswordPolicy = <ThrowOnError extends boolean = false>(options?: Options<GetPasswordPolicyData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetPasswordPolicyResponses, unknown, ThrowOnError>({
        url: '/v1/auth/password/policy',
        ...options
    });
};

/**
 * Check Password Strength
 * Check password strength and get validation feedback
 */
export const checkPasswordStrength = <ThrowOnError extends boolean = false>(options: Options<CheckPasswordStrengthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CheckPasswordStrengthResponses, CheckPasswordStrengthErrors, ThrowOnError>({
        url: '/v1/auth/password/check',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get CAPTCHA Configuration
 * Get CAPTCHA configuration including site key and whether CAPTCHA is required.
 */
export const getCaptchaConfig = <ThrowOnError extends boolean = false>(options?: Options<GetCaptchaConfigData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCaptchaConfigResponses, unknown, ThrowOnError>({
        url: '/v1/auth/captcha/config',
        ...options
    });
};

/**
 * Health Check
 * Service health check endpoint for monitoring and load balancers
 */
export const getServiceStatus = <ThrowOnError extends boolean = false>(options?: Options<GetServiceStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetServiceStatusResponses, unknown, ThrowOnError>({
        url: '/v1/status',
        ...options
    });
};

/**
 * Get Current User
 * Returns information about the currently authenticated user.
 */
export const getCurrentUser = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCurrentUserResponses, GetCurrentUserErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user',
        ...options
    });
};

/**
 * Update User Profile
 * Update the current user's profile information.
 */
export const updateUser = <ThrowOnError extends boolean = false>(options: Options<UpdateUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserResponses, UpdateUserErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get User Graphs
 * Get all graph databases accessible to the current user.
 */
export const getUserGraphs = <ThrowOnError extends boolean = false>(options?: Options<GetUserGraphsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserGraphsResponses, GetUserGraphsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/graphs',
        ...options
    });
};

/**
 * Select User Graph
 * Select a specific graph as the active graph for the user.
 */
export const selectUserGraph = <ThrowOnError extends boolean = false>(options: Options<SelectUserGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SelectUserGraphResponses, SelectUserGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/graphs/{graph_id}/select',
        ...options
    });
};

/**
 * Get All Credit Summaries
 * Get credit summaries for all graphs owned by the user.
 *
 * This endpoint provides a consolidated view of credit usage across
 * all graphs where the user has access, helping to monitor overall
 * credit consumption and plan usage.
 *
 * No credits are consumed for viewing summaries.
 */
export const getAllCreditSummaries = <ThrowOnError extends boolean = false>(options?: Options<GetAllCreditSummariesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAllCreditSummariesResponses, GetAllCreditSummariesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/credits',
        ...options
    });
};

/**
 * Update Password
 * Update the current user's password.
 */
export const updateUserPassword = <ThrowOnError extends boolean = false>(options: Options<UpdateUserPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserPasswordResponses, UpdateUserPasswordErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/password',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List API Keys
 * Get all API keys for the current user.
 */
export const listUserApiKeys = <ThrowOnError extends boolean = false>(options?: Options<ListUserApiKeysData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ListUserApiKeysResponses, ListUserApiKeysErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys',
        ...options
    });
};

/**
 * Create API Key
 * Create a new API key for the current user.
 */
export const createUserApiKey = <ThrowOnError extends boolean = false>(options: Options<CreateUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateUserApiKeyResponses, CreateUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Revoke API Key
 * Revoke (deactivate) an API key.
 */
export const revokeUserApiKey = <ThrowOnError extends boolean = false>(options: Options<RevokeUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<RevokeUserApiKeyResponses, RevokeUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys/{api_key_id}',
        ...options
    });
};

/**
 * Update API Key
 * Update an API key's name or description.
 */
export const updateUserApiKey = <ThrowOnError extends boolean = false>(options: Options<UpdateUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserApiKeyResponses, UpdateUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys/{api_key_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get user limits
 * Retrieve current limits and restrictions for the authenticated user
 */
export const getUserLimits = <ThrowOnError extends boolean = false>(options?: Options<GetUserLimitsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserLimitsResponses, GetUserLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits',
        ...options
    });
};

/**
 * Get user usage statistics
 * Retrieve current usage statistics and remaining limits for the authenticated user
 */
export const getUserUsage = <ThrowOnError extends boolean = false>(options?: Options<GetUserUsageData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserUsageResponses, GetUserUsageErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits/usage',
        ...options
    });
};

/**
 * Get all shared repository limits
 * Get rate limit status for all shared repositories the user has access to.
 */
export const getAllSharedRepositoryLimits = <ThrowOnError extends boolean = false>(options?: Options<GetAllSharedRepositoryLimitsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAllSharedRepositoryLimitsResponses, GetAllSharedRepositoryLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits/shared-repositories/summary',
        ...options
    });
};

/**
 * Get shared repository rate limit status
 * Get current rate limit status and usage for a shared repository.
 *
 * Returns:
 * - Current usage across different time windows
 * - Rate limits based on subscription tier
 * - Remaining quota
 * - Reset times
 *
 * Note: All queries are FREE - this only shows rate limit status.
 */
export const getSharedRepositoryLimits = <ThrowOnError extends boolean = false>(options: Options<GetSharedRepositoryLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSharedRepositoryLimitsResponses, GetSharedRepositoryLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits/shared-repositories/{repository}',
        ...options
    });
};

/**
 * Get User Usage Overview
 * Get a high-level overview of usage statistics for the current user.
 */
export const getUserUsageOverview = <ThrowOnError extends boolean = false>(options?: Options<GetUserUsageOverviewData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserUsageOverviewResponses, GetUserUsageOverviewErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/analytics/overview',
        ...options
    });
};

/**
 * Get Detailed User Analytics
 * Get comprehensive analytics for the current user including API usage and recent activity.
 */
export const getDetailedUserAnalytics = <ThrowOnError extends boolean = false>(options?: Options<GetDetailedUserAnalyticsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetDetailedUserAnalyticsResponses, GetDetailedUserAnalyticsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/analytics/detailed',
        ...options
    });
};

/**
 * Get User Subscriptions
 * Retrieve user's current shared repository subscriptions with detailed information
 */
export const getUserSharedSubscriptions = <ThrowOnError extends boolean = false>(options?: Options<GetUserSharedSubscriptionsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserSharedSubscriptionsResponses, GetUserSharedSubscriptionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories',
        ...options
    });
};

/**
 * Subscribe to Shared Repository
 * Create a new subscription to a shared repository add-on with specified tier
 */
export const subscribeToSharedRepository = <ThrowOnError extends boolean = false>(options: Options<SubscribeToSharedRepositoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SubscribeToSharedRepositoryResponses, SubscribeToSharedRepositoryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/subscribe',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Upgrade Subscription Tier
 * Upgrade a subscription to a higher tier with immediate credit adjustment
 */
export const upgradeSharedRepositorySubscription = <ThrowOnError extends boolean = false>(options: Options<UpgradeSharedRepositorySubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpgradeSharedRepositorySubscriptionResponses, UpgradeSharedRepositorySubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/{subscription_id}/upgrade',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Cancel Subscription
 * Cancel a shared repository subscription and disable associated credit pool
 */
export const cancelSharedRepositorySubscription = <ThrowOnError extends boolean = false>(options: Options<CancelSharedRepositorySubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<CancelSharedRepositorySubscriptionResponses, CancelSharedRepositorySubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/{subscription_id}',
        ...options
    });
};

/**
 * Get Credit Balances
 * Retrieve credit balances for all shared repository subscriptions
 */
export const getSharedRepositoryCredits = <ThrowOnError extends boolean = false>(options?: Options<GetSharedRepositoryCreditsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetSharedRepositoryCreditsResponses, GetSharedRepositoryCreditsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/credits',
        ...options
    });
};

/**
 * Get Repository Credits
 * Get credit balance for a specific shared repository
 */
export const getRepositoryCredits = <ThrowOnError extends boolean = false>(options: Options<GetRepositoryCreditsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetRepositoryCreditsResponses, GetRepositoryCreditsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/credits/{repository}',
        ...options
    });
};

/**
 * List Connection Options
 * Get metadata about all available data connection providers.
 *
 * This endpoint returns comprehensive information about each supported provider:
 *
 * **SEC EDGAR**: Public entity financial filings
 * - No authentication required (public data)
 * - 10-K, 10-Q, 8-K reports with XBRL data
 * - Historical and real-time filing access
 *
 * **QuickBooks Online**: Full accounting system integration
 * - OAuth 2.0 authentication
 * - Chart of accounts, transactions, trial balance
 * - Real-time sync capabilities
 *
 * **Plaid**: Bank account connections
 * - Secure bank authentication via Plaid Link
 * - Transaction history and balances
 * - Multi-account support
 *
 * No credits are consumed for viewing connection options.
 */
export const getConnectionOptions = <ThrowOnError extends boolean = false>(options: Options<GetConnectionOptionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetConnectionOptionsResponses, GetConnectionOptionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections/options',
        ...options
    });
};

/**
 * Sync Connection
 * Trigger a data synchronization for the connection.
 *
 * Initiates data sync based on provider type:
 *
 * **SEC Sync**:
 * - Downloads latest filings from EDGAR
 * - Parses XBRL data and updates graph
 * - Typically completes in 5-10 minutes
 *
 * **QuickBooks Sync**:
 * - Fetches latest transactions and balances
 * - Updates chart of accounts
 * - Generates fresh trial balance
 * - Duration depends on data volume
 *
 * **Plaid Sync**:
 * - Retrieves recent bank transactions
 * - Updates account balances
 * - Categorizes new transactions
 *
 * Note:
 * This operation is FREE - no credit consumption required.
 *
 * Returns a task ID for monitoring sync progress.
 */
export const syncConnection = <ThrowOnError extends boolean = false>(options: Options<SyncConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SyncConnectionResponses, SyncConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections/{connection_id}/sync',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Link Token
 * Create a link token for embedded authentication providers.
 *
 * This endpoint generates a temporary token used to initialize embedded authentication UI.
 *
 * Currently supported providers:
 * - **Plaid**: Bank account connections with real-time transaction access
 *
 * The link token:
 * - Expires after 4 hours
 * - Is single-use only
 * - Must be used with the matching frontend SDK
 * - Includes user and entity context
 *
 * No credits are consumed for creating link tokens.
 */
export const createLinkToken = <ThrowOnError extends boolean = false>(options: Options<CreateLinkTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateLinkTokenResponses, CreateLinkTokenErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections/link/token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Exchange Link Token
 * Exchange a public token for permanent access credentials.
 *
 * This completes the embedded authentication flow after user authorization.
 *
 * The exchange process:
 * 1. Validates the temporary public token
 * 2. Exchanges it for permanent access credentials
 * 3. Updates the connection with account information
 * 4. Optionally triggers initial data sync
 *
 * Supported providers:
 * - **Plaid**: Exchanges Plaid Link public token for access token
 *
 * Security:
 * - Public tokens expire after 30 minutes
 * - Each token can only be exchanged once
 * - Full audit trail is maintained
 *
 * No credits are consumed for token exchange.
 */
export const exchangeLinkToken = <ThrowOnError extends boolean = false>(options: Options<ExchangeLinkTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExchangeLinkTokenResponses, ExchangeLinkTokenErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections/link/exchange',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Init Oauth
 * Initialize OAuth flow for a connection.
 *
 * This generates an authorization URL that the frontend should redirect the user to.
 * Currently supports: QuickBooks
 */
export const initOAuth = <ThrowOnError extends boolean = false>(options: Options<InitOAuthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<InitOAuthResponses, InitOAuthErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections/oauth/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * OAuth Callback
 * Handle OAuth callback from provider after user authorization.
 *
 * This endpoint completes the OAuth flow:
 * 1. Validates the OAuth state parameter
 * 2. Exchanges authorization code for access tokens
 * 3. Stores tokens securely
 * 4. Updates connection status
 * 5. Optionally triggers initial sync
 *
 * Supported providers:
 * - **QuickBooks**: Accounting data integration
 *
 * Security measures:
 * - State validation prevents CSRF attacks
 * - User context is verified
 * - Tokens are encrypted before storage
 * - Full audit trail is maintained
 *
 * No credits are consumed for OAuth callbacks.
 */
export const oauthCallback = <ThrowOnError extends boolean = false>(options: Options<OauthCallbackData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<OauthCallbackResponses, OauthCallbackErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections/oauth/callback/{provider}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Connections
 * List all data connections in the graph.
 *
 * Returns active and inactive connections with their current status.
 * Connections can be filtered by:
 * - **Entity**: Show connections for a specific entity
 * - **Provider**: Filter by connection type (sec, quickbooks, plaid)
 *
 * Each connection shows:
 * - Current sync status and health
 * - Last successful sync timestamp
 * - Configuration metadata
 * - Error messages if any
 *
 * No credits are consumed for listing connections.
 */
export const listConnections = <ThrowOnError extends boolean = false>(options: Options<ListConnectionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListConnectionsResponses, ListConnectionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections',
        ...options
    });
};

/**
 * Create Connection
 * Create a new data connection for external system integration.
 *
 * This endpoint initiates connections to external data sources:
 *
 * **SEC Connections**:
 * - Provide entity CIK for automatic filing retrieval
 * - No authentication needed
 * - Begins immediate data sync
 *
 * **QuickBooks Connections**:
 * - Returns OAuth URL for authorization
 * - Requires admin permissions in QuickBooks
 * - Complete with OAuth callback
 *
 * **Plaid Connections**:
 * - Returns Plaid Link token
 * - User completes bank authentication
 * - Exchange public token for access
 *
 * Note:
 * This operation is FREE - no credit consumption required.
 */
export const createConnection = <ThrowOnError extends boolean = false>(options: Options<CreateConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateConnectionResponses, CreateConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Connection
 * Delete a data connection and clean up related resources.
 *
 * This operation:
 * - Removes the connection configuration
 * - Preserves any imported data in the graph
 * - Performs provider-specific cleanup
 * - Revokes stored credentials
 *
 * Note:
 * This operation is FREE - no credit consumption required.
 *
 * Only users with admin role can delete connections.
 */
export const deleteConnection = <ThrowOnError extends boolean = false>(options: Options<DeleteConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteConnectionResponses, DeleteConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections/{connection_id}',
        ...options
    });
};

/**
 * Get Connection
 * Get detailed information about a specific connection.
 *
 * Returns comprehensive connection details including:
 * - Current status and health indicators
 * - Authentication state
 * - Sync history and statistics
 * - Error details if any
 * - Provider-specific metadata
 *
 * No credits are consumed for viewing connection details.
 */
export const getConnection = <ThrowOnError extends boolean = false>(options: Options<GetConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetConnectionResponses, GetConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/connections/{connection_id}',
        ...options
    });
};

/**
 * Auto-select agent for query
 * Automatically select the best agent for your query.
 *
 * The orchestrator will:
 * 1. Enrich context with RAG if enabled
 * 2. Evaluate all available agents
 * 3. Select the best match based on confidence scores
 * 4. Execute the query with the selected agent
 *
 * Use this endpoint when you want the system to intelligently route your query.
 */
export const autoSelectAgent = <ThrowOnError extends boolean = false>(options: Options<AutoSelectAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<AutoSelectAgentResponses, AutoSelectAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/agent',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Execute specific agent
 * Execute a specific agent type directly.
 *
 * Available agents:
 * - **financial**: Financial analysis, SEC filings, accounting data
 * - **research**: Deep research and comprehensive analysis
 * - **rag**: Fast retrieval without AI (no credits required)
 *
 * Use this endpoint when you know which agent you want to use.
 */
export const executeSpecificAgent = <ThrowOnError extends boolean = false>(options: Options<ExecuteSpecificAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecuteSpecificAgentResponses, ExecuteSpecificAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/agent/{agent_type}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Batch process multiple queries
 * Process multiple queries either sequentially or in parallel.
 *
 * **Features:**
 * - Process up to 10 queries in a single request
 * - Sequential or parallel execution modes
 * - Automatic error handling per query
 * - Credit checking before execution
 *
 * **Use Cases:**
 * - Bulk analysis of multiple entities
 * - Comparative analysis across queries
 * - Automated report generation
 *
 * Returns individual results for each query with execution metrics.
 */
export const batchProcessQueries = <ThrowOnError extends boolean = false>(options: Options<BatchProcessQueriesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BatchProcessQueriesResponses, BatchProcessQueriesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/agent/batch',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List available agents
 * Get a comprehensive list of all available agents with their metadata.
 *
 * **Returns:**
 * - Agent types and names
 * - Capabilities and supported modes
 * - Version information
 * - Credit requirements
 *
 * Use the optional `capability` filter to find agents with specific capabilities.
 */
export const listAgents = <ThrowOnError extends boolean = false>(options: Options<ListAgentsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListAgentsResponses, ListAgentsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/agent/list',
        ...options
    });
};

/**
 * Get agent metadata
 * Get comprehensive metadata for a specific agent type.
 *
 * **Returns:**
 * - Agent name and description
 * - Version information
 * - Supported capabilities and modes
 * - Credit requirements
 * - Author and tags
 * - Configuration options
 *
 * Use this to understand agent capabilities before execution.
 */
export const getAgentMetadata = <ThrowOnError extends boolean = false>(options: Options<GetAgentMetadataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetAgentMetadataResponses, GetAgentMetadataErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/agent/{agent_type}/metadata',
        ...options
    });
};

/**
 * Get agent recommendations
 * Get intelligent agent recommendations for a specific query.
 *
 * **How it works:**
 * 1. Analyzes query content and structure
 * 2. Evaluates agent capabilities
 * 3. Calculates confidence scores
 * 4. Returns ranked recommendations
 *
 * **Use this when:**
 * - Unsure which agent to use
 * - Need to understand agent suitability
 * - Want confidence scores for decision making
 *
 * Returns top agents ranked by confidence with explanations.
 */
export const recommendAgent = <ThrowOnError extends boolean = false>(options: Options<RecommendAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RecommendAgentResponses, RecommendAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/agent/recommend',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List MCP Tools
 * Get available Model Context Protocol tools for graph analysis.
 *
 * This endpoint returns a comprehensive list of MCP tools optimized for AI agents:
 * - Tool schemas with detailed parameter documentation
 * - Context-aware descriptions based on graph type
 * - Capability indicators for streaming and progress
 *
 * The tool list is customized based on:
 * - Graph type (shared repository vs user graph)
 * - User permissions and subscription tier
 * - Backend capabilities (Kuzu, Neo4j, etc.)
 *
 * Credit consumption:
 * - Listing tools is FREE to encourage exploration
 * - Tool execution costs vary by operation complexity
 */
export const listMcpTools = <ThrowOnError extends boolean = false>(options: Options<ListMcpToolsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListMcpToolsResponses, ListMcpToolsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/mcp/tools',
        ...options
    });
};

/**
 * Execute MCP Tool
 * Execute an MCP tool with intelligent response optimization.
 *
 * This endpoint automatically selects the best execution strategy based on:
 * - Tool type and estimated complexity
 * - Client capabilities (AI agent detection)
 * - System load and queue status
 * - Graph type (shared repository vs user graph)
 *
 * **Response Formats:**
 * - **JSON**: Direct response for small/fast operations
 * - **SSE**: Server-Sent Events for progress monitoring
 * - **NDJSON**: Newline-delimited JSON for streaming
 * - **Queued**: Asynchronous execution with status monitoring
 *
 * **SSE Streaming Support:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation to direct response if SSE unavailable
 * - Progress events for long-running operations
 *
 * **AI Agent Optimization:**
 * The Node.js MCP client transparently handles all response formats,
 * presenting a unified interface to AI agents. Streaming responses are
 * automatically aggregated for seamless consumption.
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Connection limit or rate limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - `408 Request Timeout`: Tool execution exceeded timeout
 * - Clients should implement exponential backoff on errors
 *
 * **Note:**
 * MCP tool calls are currently FREE and do not consume credits.
 */
export const callMcpTool = <ThrowOnError extends boolean = false>(options: Options<CallMcpToolData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CallMcpToolResponses, CallMcpToolErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/mcp/call-tool',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Kuzu graph backups
 * List all backups for the specified graph database
 */
export const listBackups = <ThrowOnError extends boolean = false>(options: Options<ListBackupsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListBackupsResponses, ListBackupsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/backups',
        ...options
    });
};

/**
 * Create Backup
 * Create a backup of the graph database.
 *
 * Creates a complete backup of the Kuzu database (.kuzu file) with:
 * - **Format**: Full database backup only (complete .kuzu file)
 * - **Compression**: Always enabled for optimal storage
 * - **Encryption**: Optional AES-256 encryption for security
 * - **Retention**: Configurable retention period (1-2555 days)
 *
 * **Backup Features:**
 * - **Complete Backup**: Full database file backup
 * - **Consistency**: Point-in-time consistent snapshot
 * - **Download Support**: Unencrypted backups can be downloaded
 * - **Restore Support**: Future support for encrypted backup restoration
 *
 * **Progress Monitoring:**
 * Use the returned operation_id to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.addEventListener('operation_progress', (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Backup progress:', data.progress_percent + '%');
 * });
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Important Notes:**
 * - Only full_dump format is supported (no CSV/JSON exports)
 * - Compression is always enabled
 * - Encrypted backups cannot be downloaded (security measure)
 * - All backups are stored securely in cloud storage
 *
 * **Credit Consumption:**
 * - Base cost: 25.0 credits
 * - Large databases (>10GB): 50.0 credits
 * - Multiplied by graph tier
 *
 * Returns operation details for SSE monitoring.
 */
export const createBackup = <ThrowOnError extends boolean = false>(options: Options<CreateBackupData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateBackupResponses, CreateBackupErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/backups',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Export Kuzu backup for download
 * Export a backup file for download (only available for non-encrypted, compressed .kuzu backups)
 */
export const exportBackup = <ThrowOnError extends boolean = false>(options: Options<ExportBackupData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExportBackupResponses, ExportBackupErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/backups/{backup_id}/export',
        ...options
    });
};

/**
 * Get temporary download URL for backup
 * Generate a temporary download URL for a backup (unencrypted, compressed .kuzu files only)
 */
export const getBackupDownloadUrl = <ThrowOnError extends boolean = false>(options: Options<GetBackupDownloadUrlData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetBackupDownloadUrlResponses, GetBackupDownloadUrlErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/backups/{backup_id}/download',
        ...options
    });
};

/**
 * Restore Encrypted Backup
 * Restore a graph database from an encrypted backup.
 *
 * Restores a complete Kuzu database from an encrypted backup:
 * - **Format**: Only full_dump backups can be restored
 * - **Encryption**: Only encrypted backups can be restored (security requirement)
 * - **System Backup**: Creates automatic backup of existing database before restore
 * - **Verification**: Optionally verifies database integrity after restore
 *
 * **Restore Features:**
 * - **Atomic Operation**: Complete replacement of database
 * - **Rollback Protection**: System backup created before restore
 * - **Data Integrity**: Verification ensures successful restore
 * - **Security**: Only encrypted backups to prevent data tampering
 *
 * **Progress Monitoring:**
 * Use the returned operation_id to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.addEventListener('operation_progress', (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Restore progress:', data.message);
 * });
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Important Notes:**
 * - Only encrypted backups can be restored (security measure)
 * - Existing database is backed up to S3 before restore
 * - Restore is a destructive operation - existing data is replaced
 * - System backups are stored separately for recovery
 *
 * **Credit Consumption:**
 * - Base cost: 100.0 credits
 * - Large databases (>10GB): 200.0 credits
 * - Multiplied by graph tier
 *
 * Returns operation details for SSE monitoring.
 */
export const restoreBackup = <ThrowOnError extends boolean = false>(options: Options<RestoreBackupData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RestoreBackupResponses, RestoreBackupErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/backups/restore',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get backup statistics
 * Get comprehensive backup statistics for the specified graph database
 */
export const getBackupStats = <ThrowOnError extends boolean = false>(options: Options<GetBackupStatsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetBackupStatsResponses, GetBackupStatsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/backups/stats',
        ...options
    });
};

/**
 * Get Graph Metrics
 * Get comprehensive metrics for the graph database.
 *
 * Provides detailed analytics including:
 * - **Node Statistics**: Counts by type (Entity, Report, Account, Transaction)
 * - **Relationship Metrics**: Connection counts and patterns
 * - **Data Quality**: Completeness scores and validation results
 * - **Performance Metrics**: Query response times and database health
 * - **Storage Analytics**: Database size and growth trends
 *
 * This data helps with:
 * - Monitoring data completeness
 * - Identifying data quality issues
 * - Capacity planning
 * - Performance optimization
 *
 * Note:
 * This operation is FREE - no credit consumption required.
 */
export const getGraphMetrics = <ThrowOnError extends boolean = false>(options: Options<GetGraphMetricsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphMetricsResponses, GetGraphMetricsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/analytics',
        ...options
    });
};

/**
 * Get Usage Statistics
 * Get detailed usage statistics for the graph.
 *
 * Provides temporal usage patterns including:
 * - **Query Volume**: API calls per day/hour
 * - **Credit Consumption**: Usage patterns and trends
 * - **Operation Breakdown**: Usage by operation type
 * - **User Activity**: Access patterns by user role
 * - **Peak Usage Times**: Identify high-activity periods
 *
 * Time ranges available:
 * - Last 24 hours (hourly breakdown)
 * - Last 7 days (daily breakdown)
 * - Last 30 days (daily breakdown)
 * - Custom date ranges
 *
 * Useful for:
 * - Capacity planning
 * - Cost optimization
 * - Usage trend analysis
 * - Performance tuning
 *
 * Note:
 * This operation is FREE - no credit consumption required.
 */
export const getGraphUsageStats = <ThrowOnError extends boolean = false>(options: Options<GetGraphUsageStatsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphUsageStatsResponses, GetGraphUsageStatsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/analytics/usage',
        ...options
    });
};

/**
 * Execute Cypher Query
 * Execute a Cypher query with intelligent response optimization.
 *
 * This endpoint automatically selects the best execution strategy based on:
 * - Query characteristics (size, complexity)
 * - Client capabilities (SSE, NDJSON, JSON)
 * - System load (queue status, concurrent queries)
 * - User preferences (mode parameter, headers)
 *
 * **Response Modes:**
 * - `auto` (default): Intelligent automatic selection
 * - `sync`: Force synchronous JSON response (best for testing)
 * - `async`: Force queued response with SSE monitoring endpoints (no polling needed)
 * - `stream`: Force streaming response (SSE or NDJSON)
 *
 * **Client Detection:**
 * - Automatically detects testing tools (Postman, Swagger UI)
 * - Adjusts behavior for better interactive experience
 * - Respects Accept and Prefer headers for capabilities
 *
 * **Streaming Support (SSE):**
 * - Real-time events with progress updates
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 * - 30-second keepalive to prevent timeouts
 *
 * **Streaming Support (NDJSON):**
 * - Efficient line-delimited JSON for large results
 * - Automatic chunking (configurable 10-10000 rows)
 * - No connection limits (stateless streaming)
 *
 * **Queue Management:**
 * - Automatic queuing under high load
 * - Real-time monitoring via SSE events (no polling needed)
 * - Priority based on subscription tier
 * - Queue position and progress updates pushed via SSE
 * - Connect to returned `/v1/operations/{id}/stream` endpoint for updates
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Rate limit or connection limit exceeded
 * - `503 Service Unavailable`: Circuit breaker open or SSE disabled
 * - Clients should implement exponential backoff
 *
 * **Note:**
 * Query operations are FREE - no credit consumption required.
 * Queue position is based on subscription tier for priority.
 */
export const executeCypherQuery = <ThrowOnError extends boolean = false>(options: Options<ExecuteCypherQueryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecuteCypherQueryResponses, ExecuteCypherQueryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/query',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Runtime Graph Schema Information
 * Get runtime schema information for the specified graph database.
 *
 * This endpoint inspects the actual graph database structure and returns:
 * - **Node Labels**: All node types currently in the database
 * - **Relationship Types**: All relationship types currently in the database
 * - **Node Properties**: Properties for each node type (limited to first 10 for performance)
 *
 * This is different from custom schema management - it shows what actually exists in the database,
 * useful for understanding the current graph structure before writing queries.
 *
 * This operation is FREE - no credit consumption required.
 */
export const getGraphSchemaInfo = <ThrowOnError extends boolean = false>(options: Options<GetGraphSchemaInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphSchemaInfoResponses, GetGraphSchemaInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/schema/info',
        ...options
    });
};

/**
 * Validate Schema
 * Validate a custom schema definition before deployment.
 *
 * This endpoint performs comprehensive validation including:
 * - **Structure Validation**: Ensures proper JSON/YAML format
 * - **Type Checking**: Validates data types (STRING, INT, DOUBLE, etc.)
 * - **Constraint Verification**: Checks primary keys and unique constraints
 * - **Relationship Integrity**: Validates node references in relationships
 * - **Naming Conventions**: Ensures valid identifiers
 * - **Compatibility**: Checks against existing extensions if specified
 *
 * Supported formats:
 * - JSON schema definitions
 * - YAML schema definitions
 * - Direct dictionary format
 *
 * Validation helps prevent:
 * - Schema deployment failures
 * - Data integrity issues
 * - Performance problems
 * - Naming conflicts
 *
 * This operation is FREE - no credit consumption required.
 */
export const validateSchema = <ThrowOnError extends boolean = false>(options: Options<ValidateSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ValidateSchemaResponses, ValidateSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/schema/validate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Export Graph Schema
 * Export the schema of an existing graph in JSON, YAML, or Cypher format
 */
export const exportGraphSchema = <ThrowOnError extends boolean = false>(options: Options<ExportGraphSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ExportGraphSchemaResponses, ExportGraphSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/schema/export',
        ...options
    });
};

/**
 * List Available Schema Extensions
 * Get list of available schema extensions and compatibility groups
 */
export const listSchemaExtensions = <ThrowOnError extends boolean = false>(options: Options<ListSchemaExtensionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListSchemaExtensionsResponses, ListSchemaExtensionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/schema/extensions',
        ...options
    });
};

/**
 * Get Current Bill
 * Get current month's billing details for the graph.
 *
 * Returns comprehensive billing information including:
 * - **Credit Usage**: Consumed vs. allocated credits
 * - **Storage Charges**: Current storage usage and costs
 * - **Subscription Tier**: Current plan and features
 * - **Pro-rated Charges**: If plan changed mid-month
 * - **Estimated Total**: Current charges to date
 *
 * Billing calculations are updated hourly. Storage is measured in GB-months.
 *
 *  No credits are consumed for viewing billing information.
 */
export const getCurrentGraphBill = <ThrowOnError extends boolean = false>(options: Options<GetCurrentGraphBillData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCurrentGraphBillResponses, GetCurrentGraphBillErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/billing/current',
        ...options
    });
};

/**
 * Get Usage Details
 * Get detailed usage metrics for the graph.
 *
 * Provides granular usage information including:
 * - **Daily Credit Consumption**: Track credit usage patterns
 * - **Storage Growth**: Monitor database size over time
 * - **Operation Breakdown**: Credits by operation type
 * - **Peak Usage Times**: Identify high-activity periods
 * - **API Call Volumes**: Request counts and patterns
 *
 * Useful for:
 * - Optimizing credit consumption
 * - Capacity planning
 * - Usage trend analysis
 * - Cost optimization
 *
 *  No credits are consumed for viewing usage details.
 */
export const getGraphUsageDetails = <ThrowOnError extends boolean = false>(options: Options<GetGraphUsageDetailsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphUsageDetailsResponses, GetGraphUsageDetailsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/billing/usage',
        ...options
    });
};

/**
 * Get Billing History
 * Get billing history for the graph.
 *
 * Returns a chronological list of monthly bills, perfect for:
 * - Tracking spending trends over time
 * - Identifying usage patterns
 * - Budget forecasting
 * - Financial reporting
 *
 * Each month includes:
 * - Credit usage and overages
 * - Storage charges
 * - Total charges
 * - Usage metrics
 *
 *  No credits are consumed for viewing billing history.
 */
export const getGraphBillingHistory = <ThrowOnError extends boolean = false>(options: Options<GetGraphBillingHistoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphBillingHistoryResponses, GetGraphBillingHistoryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/billing/history',
        ...options
    });
};

/**
 * Get Monthly Bill
 * Get billing details for a specific month.
 *
 * Retrieve historical billing information for any previous month.
 * Useful for:
 * - Reconciling past charges
 * - Tracking usage trends
 * - Expense reporting
 * - Budget analysis
 *
 * Returns the same detailed breakdown as the current bill endpoint.
 *
 *  No credits are consumed for viewing billing history.
 */
export const getGraphMonthlyBill = <ThrowOnError extends boolean = false>(options: Options<GetGraphMonthlyBillData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphMonthlyBillResponses, GetGraphMonthlyBillErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/billing/history/{year}/{month}',
        ...options
    });
};

/**
 * Get Credit Summary
 * Retrieve comprehensive credit usage summary for the specified graph.
 *
 * This endpoint provides:
 * - Current credit balance and monthly allocation
 * - Credit consumption metrics for the current month
 * - Graph tier and credit multiplier information
 * - Usage percentage to help monitor credit consumption
 *
 * No credits are consumed for checking credit status.
 */
export const getCreditSummary = <ThrowOnError extends boolean = false>(options: Options<GetCreditSummaryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCreditSummaryResponses, GetCreditSummaryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/credits/summary',
        ...options
    });
};

/**
 * List Credit Transactions
 * Retrieve detailed credit transaction history for the specified graph.
 *
 * This enhanced endpoint provides:
 * - Detailed transaction records with idempotency information
 * - Summary by operation type to identify high-consumption operations
 * - Date range filtering for analysis
 * - Metadata search capabilities
 *
 * Transaction types include:
 * - ALLOCATION: Monthly credit allocations
 * - CONSUMPTION: Credit usage for operations
 * - BONUS: Bonus credits added by admins
 * - REFUND: Credit refunds
 *
 * No credits are consumed for viewing transaction history.
 */
export const listCreditTransactions = <ThrowOnError extends boolean = false>(options: Options<ListCreditTransactionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListCreditTransactionsResponses, ListCreditTransactionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/credits/transactions',
        ...options
    });
};

/**
 * Check Credit Balance
 * Check if the graph has sufficient credits for a planned operation.
 *
 * This endpoint allows you to verify credit availability before performing
 * an operation, helping prevent failed operations due to insufficient credits.
 *
 * The check considers:
 * - Base operation cost
 * - Graph tier multiplier
 * - Current credit balance
 *
 * No credits are consumed for checking availability.
 */
export const checkCreditBalance = <ThrowOnError extends boolean = false>(options: Options<CheckCreditBalanceData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<CheckCreditBalanceResponses, CheckCreditBalanceErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/credits/balance/check',
        ...options
    });
};

/**
 * Get Storage Usage
 * Get storage usage history for a graph.
 *
 * Returns detailed storage usage information including:
 * - Daily average storage consumption
 * - Storage trends over time
 * - Credit costs for storage
 * - Current storage billing information
 *
 * This endpoint helps users understand their storage patterns
 * and associated credit costs.
 */
export const getStorageUsage = <ThrowOnError extends boolean = false>(options: Options<GetStorageUsageData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetStorageUsageResponses, GetStorageUsageErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/credits/storage/usage',
        ...options
    });
};

/**
 * Check Storage Limits
 * Check storage limits and usage for a graph.
 *
 * Returns comprehensive storage limit information including:
 * - Current storage usage
 * - Effective limit (override or default)
 * - Usage percentage and warnings
 * - Recommendations for limit management
 *
 * This endpoint helps users monitor storage usage and plan for potential
 * limit increases. No credits are consumed for checking storage limits.
 */
export const checkStorageLimits = <ThrowOnError extends boolean = false>(options: Options<CheckStorageLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<CheckStorageLimitsResponses, CheckStorageLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/credits/storage/limits',
        ...options
    });
};

/**
 * Database Health Check
 * Get comprehensive health information for the graph database.
 *
 * Returns detailed health metrics including:
 * - **Connection Status**: Database connectivity and responsiveness
 * - **Performance Metrics**: Query execution times and throughput
 * - **Resource Usage**: Memory and storage utilization
 * - **Error Monitoring**: Recent error rates and patterns
 * - **Uptime Statistics**: Service availability metrics
 *
 * Health indicators:
 * - **Status**: healthy, degraded, or unhealthy
 * - **Query Performance**: Average execution times
 * - **Error Rates**: Recent failure percentages
 * - **Resource Usage**: Memory and storage consumption
 * - **Alerts**: Active warnings or issues
 *
 * This endpoint provides essential monitoring data for operational visibility.
 */
export const getDatabaseHealth = <ThrowOnError extends boolean = false>(options: Options<GetDatabaseHealthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetDatabaseHealthResponses, GetDatabaseHealthErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/health',
        ...options
    });
};

/**
 * Database Information
 * Get comprehensive database information and statistics.
 *
 * Returns detailed database metrics including:
 * - **Database Metadata**: Name, path, size, and timestamps
 * - **Schema Information**: Node labels, relationship types, and counts
 * - **Storage Statistics**: Database size and usage metrics
 * - **Data Composition**: Node and relationship counts
 * - **Backup Information**: Available backups and last backup date
 * - **Configuration**: Read-only status and schema version
 *
 * Database statistics:
 * - **Size**: Storage usage in bytes and MB
 * - **Content**: Node and relationship counts
 * - **Schema**: Available labels and relationship types
 * - **Backup Status**: Backup availability and recency
 * - **Timestamps**: Creation and modification dates
 *
 * This endpoint provides essential database information for capacity planning and monitoring.
 */
export const getDatabaseInfo = <ThrowOnError extends boolean = false>(options: Options<GetDatabaseInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetDatabaseInfoResponses, GetDatabaseInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/info',
        ...options
    });
};

/**
 * Get Graph Operational Limits
 * Get comprehensive operational limits for the graph database.
 *
 * Returns all operational limits that apply to this graph including:
 * - **Storage Limits**: Maximum storage size and current usage
 * - **Query Limits**: Timeouts, complexity, row limits
 * - **Copy/Ingestion Limits**: File sizes, timeouts, concurrent operations
 * - **Backup Limits**: Frequency, retention, size limits
 * - **Rate Limits**: Requests per minute/hour based on tier
 * - **Credit Limits**: AI operation credits (if applicable)
 *
 * This unified endpoint provides all limits in one place for easier client integration.
 *
 * **Note**: Limits vary based on subscription tier (Standard, Enterprise, Premium).
 */
export const getGraphLimits = <ThrowOnError extends boolean = false>(options: Options<GetGraphLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphLimitsResponses, GetGraphLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/limits',
        ...options
    });
};

/**
 * List Subgraphs
 * List all subgraphs for a parent graph.
 *
 * **Requirements:**
 * - Valid authentication
 * - Parent graph must exist and be accessible to the user
 * - User must have at least 'read' permission on the parent graph
 *
 * **Returns:**
 * - List of all subgraphs for the parent graph
 * - Each subgraph includes its ID, name, description, type, status, and creation date
 */
export const listSubgraphs = <ThrowOnError extends boolean = false>(options: Options<ListSubgraphsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListSubgraphsResponses, ListSubgraphsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/subgraphs',
        ...options
    });
};

/**
 * Create Subgraph
 * Create a new subgraph within a parent graph.
 *
 * **Requirements:**
 * - Valid authentication
 * - Parent graph must exist and be accessible to the user
 * - User must have 'admin' permission on the parent graph
 * - Parent graph tier must support subgraphs (Enterprise or Premium only)
 * - Must be within subgraph quota limits
 * - Subgraph name must be unique within the parent graph
 *
 * **Returns:**
 * - Created subgraph details including its unique ID
 */
export const createSubgraph = <ThrowOnError extends boolean = false>(options: Options<CreateSubgraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateSubgraphResponses, CreateSubgraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/subgraphs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Subgraph
 * Delete a subgraph database.
 *
 * **Requirements:**
 * - Must be a valid subgraph (not parent graph)
 * - User must have admin access to parent graph
 * - Optional backup before deletion
 *
 * **Deletion Options:**
 * - `force`: Delete even if contains data
 * - `backup_first`: Create backup before deletion
 *
 * **Warning:**
 * Deletion is permanent unless backup is created.
 * All data in the subgraph will be lost.
 *
 * **Backup Location:**
 * If backup requested, stored in S3 at:
 * `s3://robosystems-backups/{instance_id}/{database_name}_{timestamp}.backup`
 */
export const deleteSubgraph = <ThrowOnError extends boolean = false>(options: Options<DeleteSubgraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteSubgraphResponses, DeleteSubgraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/subgraphs/{subgraph_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Subgraph Details
 * Get detailed information about a specific subgraph.
 *
 * **Requirements:**
 * - User must have read access to parent graph
 *
 * **Response includes:**
 * - Full subgraph metadata
 * - Database statistics (nodes, edges)
 * - Size information
 * - Schema configuration
 * - Creation/modification timestamps
 * - Last access time (when available)
 *
 * **Statistics:**
 * Real-time statistics queried from Kuzu:
 * - Node count
 * - Edge count
 * - Database size on disk
 * - Schema information
 */
export const getSubgraphInfo = <ThrowOnError extends boolean = false>(options: Options<GetSubgraphInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSubgraphInfoResponses, GetSubgraphInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/subgraphs/{subgraph_id}/info',
        ...options
    });
};

/**
 * Get Subgraph Quota
 * Get subgraph quota and usage information for a parent graph.
 *
 * **Shows:**
 * - Current subgraph count
 * - Maximum allowed subgraphs per tier
 * - Remaining capacity
 * - Total size usage across all subgraphs
 *
 * **Tier Limits:**
 * - Standard: 0 subgraphs (not supported)
 * - Enterprise: Configurable limit (default: 10 subgraphs)
 * - Premium: Unlimited subgraphs
 * - Limits are defined in deployment configuration
 *
 * **Size Tracking:**
 * Provides aggregate size metrics when available.
 * Individual subgraph sizes shown in list endpoint.
 */
export const getSubgraphQuota = <ThrowOnError extends boolean = false>(options: Options<GetSubgraphQuotaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSubgraphQuotaResponses, GetSubgraphQuotaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/subgraphs/quota',
        ...options
    });
};

/**
 * Copy Data to Graph
 * Copy data from external sources into the graph database.
 *
 * This endpoint supports multiple data sources through a unified interface:
 * - **S3**: Copy from S3 buckets with user-provided credentials
 * - **URL** (future): Copy from HTTP(S) URLs
 * - **DataFrame** (future): Copy from uploaded DataFrames
 *
 * **Security:**
 * - Requires write permissions to the target graph
 * - **Not allowed on shared repositories** (sec, industry, economic) - these are read-only
 * - User must provide their own AWS credentials for S3 access
 * - All operations are logged for audit purposes
 *
 * **Tier Limits:**
 * - Standard: 10GB max file size, 15 min timeout
 * - Enterprise: 50GB max file size, 30 min timeout
 * - Premium: 100GB max file size, 60 min timeout
 *
 * **Copy Options:**
 * - `ignore_errors`: Skip duplicate/invalid rows (enables upsert-like behavior). Note: When enabled, row counts may not be accurately reported
 * - `extended_timeout`: Use extended timeout for large datasets
 * - `validate_schema`: Validate source schema against target table
 *
 * **Asynchronous Execution with SSE:**
 * For large data imports, this endpoint returns immediately with an operation ID
 * and SSE monitoring endpoint. Connect to the returned stream URL for real-time updates:
 *
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.onmessage = (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Progress:', data.message);
 * };
 * ```
 *
 * **SSE Events Emitted:**
 * - `operation_started`: Copy operation begins
 * - `operation_progress`: Progress updates during data transfer
 * - `operation_completed`: Copy successful with statistics
 * - `operation_error`: Copy failed with error details
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Error Handling:**
 * - `403 Forbidden`: Attempted copy to shared repository
 * - `408 Request Timeout`: Operation exceeded timeout limit
 * - `429 Too Many Requests`: Rate limit exceeded
 * - `503 Service Unavailable`: Circuit breaker open or service unavailable
 * - Clients should implement exponential backoff on errors
 *
 * **Note:**
 * Copy operations are FREE - no credit consumption required.
 * All copy operations are performed asynchronously with progress monitoring.
 */
export const copyDataToGraph = <ThrowOnError extends boolean = false>(options: Options<CopyDataToGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CopyDataToGraphResponses, CopyDataToGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/{graph_id}/copy',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create New Graph Database
 * Create a new graph database with specified schema and optionally an initial entity.
 *
 * This endpoint starts an asynchronous graph creation operation and returns
 * connection details for monitoring progress via Server-Sent Events (SSE).
 *
 * **Operation Types:**
 * - **Generic Graph**: Creates empty graph with schema extensions
 * - **Entity Graph**: Creates graph with initial entity data
 *
 * **Monitoring Progress:**
 * Use the returned `operation_id` to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.onmessage = (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Progress:', data.progress_percent + '%');
 * };
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Events Emitted:**
 * - `operation_started`: Graph creation begins
 * - `operation_progress`: Schema loading, database setup, etc.
 * - `operation_completed`: Graph ready with connection details
 * - `operation_error`: Creation failed with error details
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: SSE connection limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - Clients should implement exponential backoff on errors
 *
 * **Response includes:**
 * - `operation_id`: Unique identifier for monitoring
 * - `_links.stream`: SSE endpoint for real-time updates
 * - `_links.status`: Point-in-time status check endpoint
 */
export const createGraph = <ThrowOnError extends boolean = false>(options: Options<CreateGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateGraphResponses, CreateGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/create/graph',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Available Schema Extensions
 * List all available schema extensions for graph creation
 */
export const getAvailableExtensions = <ThrowOnError extends boolean = false>(options?: Options<GetAvailableExtensionsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAvailableExtensionsResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/create/graph/extensions',
        ...options
    });
};

/**
 * Get Service Offerings
 * Get comprehensive information about all subscription offerings.
 *
 * This endpoint provides complete information about both graph database subscriptions
 * and shared repository subscriptions. This is the primary endpoint for frontend
 * applications to display subscription options.
 *
 * Includes:
 * - Graph subscription tiers (standard, enterprise, premium)
 * - Shared repository subscriptions (SEC, industry, economic data)
 * - Operation costs and credit information
 * - Features and capabilities for each tier
 * - Enabled/disabled status for repositories
 *
 * All data comes from the config-based systems to ensure accuracy with backend behavior.
 *
 * No authentication required - this is public service information.
 */
export const getServiceOfferings = <ThrowOnError extends boolean = false>(options?: Options<GetServiceOfferingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetServiceOfferingsResponses, GetServiceOfferingsErrors, ThrowOnError>({
        url: '/v1/offering',
        ...options
    });
};

/**
 * Stream Operation Events
 * Stream real-time events for an operation using Server-Sent Events (SSE).
 *
 * This endpoint provides real-time monitoring for all non-immediate operations including:
 * - Graph creation and management
 * - Agent analysis processing
 * - Database backups and restores
 * - Data synchronization tasks
 *
 * **Event Types:**
 * - `operation_started`: Operation began execution
 * - `operation_progress`: Progress update with details
 * - `operation_completed`: Operation finished successfully
 * - `operation_error`: Operation failed with error details
 * - `operation_cancelled`: Operation was cancelled
 *
 * **Features:**
 * - **Event Replay**: Use `from_sequence` parameter to replay missed events
 * - **Automatic Reconnection**: Client can reconnect and resume from last seen event
 * - **Real-time Updates**: Live progress updates during execution
 * - **Timeout Handling**: 30-second keepalive messages prevent connection timeouts
 * - **Graceful Degradation**: Automatic fallback if Redis is unavailable
 *
 * **Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic cleanup of stale connections
 * - Circuit breaker protection for Redis failures
 *
 * **Client Usage:**
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/abc123/stream');
 * eventSource.onmessage = (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Progress:', data);
 * };
 * eventSource.onerror = (error) => {
 * // Handle connection errors or rate limits
 * console.error('SSE Error:', error);
 * };
 * ```
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Connection limit or rate limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - Clients should implement exponential backoff on errors
 *
 * **No credits are consumed for SSE connections.**
 */
export const streamOperationEvents = <ThrowOnError extends boolean = false>(options: Options<StreamOperationEventsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StreamOperationEventsResponses, StreamOperationEventsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}/stream',
        ...options
    });
};

/**
 * Get Operation Status
 * Get current status and metadata for an operation.
 *
 * Returns detailed information including:
 * - Current status (pending, running, completed, failed, cancelled)
 * - Creation and update timestamps
 * - Operation type and associated graph
 * - Result data (for completed operations)
 * - Error details (for failed operations)
 *
 * This endpoint provides a point-in-time status check, while the `/stream` endpoint
 * provides real-time updates. Use this for polling or initial status checks.
 *
 * **No credits are consumed for status checks.**
 */
export const getOperationStatus = <ThrowOnError extends boolean = false>(options: Options<GetOperationStatusData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOperationStatusResponses, GetOperationStatusErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}/status',
        ...options
    });
};

/**
 * Cancel Operation
 * Cancel a pending or running operation.
 *
 * Cancels the specified operation if it's still in progress. Once cancelled,
 * the operation cannot be resumed and will emit a cancellation event to any
 * active SSE connections.
 *
 * **Note**: Completed or already failed operations cannot be cancelled.
 *
 * **No credits are consumed for cancellation requests.**
 */
export const cancelOperation = <ThrowOnError extends boolean = false>(options: Options<CancelOperationData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<CancelOperationResponses, CancelOperationErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}',
        ...options
    });
};