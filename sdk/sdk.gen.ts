// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type { RegisterUserData, RegisterUserResponses, RegisterUserErrors, LoginUserData, LoginUserResponses, LoginUserErrors, LogoutUserData, LogoutUserResponses, GetCurrentAuthUserData, GetCurrentAuthUserResponses, GetCurrentAuthUserErrors, RefreshAuthSessionData, RefreshAuthSessionResponses, RefreshAuthSessionErrors, ResendVerificationEmailData, ResendVerificationEmailResponses, ResendVerificationEmailErrors, VerifyEmailData, VerifyEmailResponses, VerifyEmailErrors, GetPasswordPolicyData, GetPasswordPolicyResponses, CheckPasswordStrengthData, CheckPasswordStrengthResponses, CheckPasswordStrengthErrors, ForgotPasswordData, ForgotPasswordResponses, ForgotPasswordErrors, ValidateResetTokenData, ValidateResetTokenResponses, ValidateResetTokenErrors, ResetPasswordData, ResetPasswordResponses, ResetPasswordErrors, GenerateSsoTokenData, GenerateSsoTokenResponses, GenerateSsoTokenErrors, SsoTokenExchangeData, SsoTokenExchangeResponses, SsoTokenExchangeErrors, CompleteSsoAuthData, CompleteSsoAuthResponses, CompleteSsoAuthErrors, GetCaptchaConfigData, GetCaptchaConfigResponses, GetServiceStatusData, GetServiceStatusResponses, GetCurrentUserData, GetCurrentUserResponses, UpdateUserData, UpdateUserResponses, UpdateUserErrors, GetAllCreditSummariesData, GetAllCreditSummariesResponses, GetAllCreditSummariesErrors, UpdateUserPasswordData, UpdateUserPasswordResponses, UpdateUserPasswordErrors, ListUserApiKeysData, ListUserApiKeysResponses, CreateUserApiKeyData, CreateUserApiKeyResponses, CreateUserApiKeyErrors, RevokeUserApiKeyData, RevokeUserApiKeyResponses, RevokeUserApiKeyErrors, UpdateUserApiKeyData, UpdateUserApiKeyResponses, UpdateUserApiKeyErrors, GetUserLimitsData, GetUserLimitsResponses, GetUserLimitsErrors, GetUserUsageData, GetUserUsageResponses, GetAllSharedRepositoryLimitsData, GetAllSharedRepositoryLimitsResponses, GetSharedRepositoryLimitsData, GetSharedRepositoryLimitsResponses, GetSharedRepositoryLimitsErrors, GetUserUsageOverviewData, GetUserUsageOverviewResponses, GetDetailedUserAnalyticsData, GetDetailedUserAnalyticsResponses, GetDetailedUserAnalyticsErrors, GetUserSharedSubscriptionsData, GetUserSharedSubscriptionsResponses, GetUserSharedSubscriptionsErrors, SubscribeToSharedRepositoryData, SubscribeToSharedRepositoryResponses, SubscribeToSharedRepositoryErrors, UpgradeSharedRepositorySubscriptionData, UpgradeSharedRepositorySubscriptionResponses, UpgradeSharedRepositorySubscriptionErrors, CancelSharedRepositorySubscriptionData, CancelSharedRepositorySubscriptionResponses, CancelSharedRepositorySubscriptionErrors, GetSharedRepositoryCreditsData, GetSharedRepositoryCreditsResponses, GetSharedRepositoryCreditsErrors, GetRepositoryCreditsData, GetRepositoryCreditsResponses, GetRepositoryCreditsErrors, ListConnectionsData, ListConnectionsResponses, ListConnectionsErrors, CreateConnectionData, CreateConnectionResponses, CreateConnectionErrors, GetConnectionOptionsData, GetConnectionOptionsResponses, GetConnectionOptionsErrors, ExchangeLinkTokenData, ExchangeLinkTokenResponses, ExchangeLinkTokenErrors, CreateLinkTokenData, CreateLinkTokenResponses, CreateLinkTokenErrors, InitOAuthData, InitOAuthResponses, InitOAuthErrors, OauthCallbackData, OauthCallbackResponses, OauthCallbackErrors, DeleteConnectionData, DeleteConnectionResponses, DeleteConnectionErrors, GetConnectionData, GetConnectionResponses, GetConnectionErrors, SyncConnectionData, SyncConnectionResponses, SyncConnectionErrors, AutoSelectAgentData, AutoSelectAgentResponses, AutoSelectAgentErrors, ExecuteSpecificAgentData, ExecuteSpecificAgentResponses, ExecuteSpecificAgentErrors, BatchProcessQueriesData, BatchProcessQueriesResponses, BatchProcessQueriesErrors, ListAgentsData, ListAgentsResponses, ListAgentsErrors, GetAgentMetadataData, GetAgentMetadataResponses, GetAgentMetadataErrors, RecommendAgentData, RecommendAgentResponses, RecommendAgentErrors, ListMcpToolsData, ListMcpToolsResponses, ListMcpToolsErrors, CallMcpToolData, CallMcpToolResponses, CallMcpToolErrors, ListBackupsData, ListBackupsResponses, ListBackupsErrors, CreateBackupData, CreateBackupResponses, CreateBackupErrors, GetBackupDownloadUrlData, GetBackupDownloadUrlResponses, GetBackupDownloadUrlErrors, RestoreBackupData, RestoreBackupResponses, RestoreBackupErrors, GetBackupStatsData, GetBackupStatsResponses, GetBackupStatsErrors, GetGraphMetricsData, GetGraphMetricsResponses, GetGraphMetricsErrors, GetGraphUsageStatsData, GetGraphUsageStatsResponses, GetGraphUsageStatsErrors, ExecuteCypherQueryData, ExecuteCypherQueryResponses, ExecuteCypherQueryErrors, GetGraphSchemaData, GetGraphSchemaResponses, GetGraphSchemaErrors, ExportGraphSchemaData, ExportGraphSchemaResponses, ExportGraphSchemaErrors, ValidateSchemaData, ValidateSchemaResponses, ValidateSchemaErrors, GetCurrentGraphBillData, GetCurrentGraphBillResponses, GetCurrentGraphBillErrors, GetGraphUsageDetailsData, GetGraphUsageDetailsResponses, GetGraphUsageDetailsErrors, GetGraphBillingHistoryData, GetGraphBillingHistoryResponses, GetGraphBillingHistoryErrors, GetGraphMonthlyBillData, GetGraphMonthlyBillResponses, GetGraphMonthlyBillErrors, GetCreditSummaryData, GetCreditSummaryResponses, GetCreditSummaryErrors, ListCreditTransactionsData, ListCreditTransactionsResponses, ListCreditTransactionsErrors, CheckCreditBalanceData, CheckCreditBalanceResponses, CheckCreditBalanceErrors, GetStorageUsageData, GetStorageUsageResponses, GetStorageUsageErrors, CheckStorageLimitsData, CheckStorageLimitsResponses, CheckStorageLimitsErrors, GetDatabaseHealthData, GetDatabaseHealthResponses, GetDatabaseHealthErrors, GetDatabaseInfoData, GetDatabaseInfoResponses, GetDatabaseInfoErrors, GetGraphLimitsData, GetGraphLimitsResponses, GetGraphLimitsErrors, ListSubgraphsData, ListSubgraphsResponses, ListSubgraphsErrors, CreateSubgraphData, CreateSubgraphResponses, CreateSubgraphErrors, DeleteSubgraphData, DeleteSubgraphResponses, DeleteSubgraphErrors, GetSubgraphInfoData, GetSubgraphInfoResponses, GetSubgraphInfoErrors, GetSubgraphQuotaData, GetSubgraphQuotaResponses, GetSubgraphQuotaErrors, ListTablesData, ListTablesResponses, ListTablesErrors, ListTableFilesData, ListTableFilesResponses, ListTableFilesErrors, GetUploadUrlData, GetUploadUrlResponses, GetUploadUrlErrors, DeleteFileData, DeleteFileResponses, DeleteFileErrors, GetFileInfoData, GetFileInfoResponses, GetFileInfoErrors, UpdateFileStatusData, UpdateFileStatusResponses, UpdateFileStatusErrors, IngestTablesData, IngestTablesResponses, IngestTablesErrors, QueryTablesData, QueryTablesResponses, QueryTablesErrors, GetGraphsData, GetGraphsResponses, GetGraphsErrors, CreateGraphData, CreateGraphResponses, CreateGraphErrors, GetAvailableExtensionsData, GetAvailableExtensionsResponses, GetAvailableExtensionsErrors, GetAvailableGraphTiersData, GetAvailableGraphTiersResponses, GetAvailableGraphTiersErrors, SelectGraphData, SelectGraphResponses, SelectGraphErrors, GetServiceOfferingsData, GetServiceOfferingsResponses, GetServiceOfferingsErrors, StreamOperationEventsData, StreamOperationEventsResponses, StreamOperationEventsErrors, GetOperationStatusData, GetOperationStatusResponses, GetOperationStatusErrors, CancelOperationData, CancelOperationResponses, CancelOperationErrors } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Register New User
 * Register a new user account with email and password. Security controls vary by environment: CAPTCHA and email verification are disabled in development for API testing, but required in production.
 */
export const registerUser = <ThrowOnError extends boolean = false>(options: Options<RegisterUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RegisterUserResponses, RegisterUserErrors, ThrowOnError>({
        url: '/v1/auth/register',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * User Login
 * Authenticate user with email and password.
 */
export const loginUser = <ThrowOnError extends boolean = false>(options: Options<LoginUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<LoginUserResponses, LoginUserErrors, ThrowOnError>({
        url: '/v1/auth/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * User Logout
 * Logout user and invalidate session.
 */
export const logoutUser = <ThrowOnError extends boolean = false>(options?: Options<LogoutUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<LogoutUserResponses, unknown, ThrowOnError>({
        url: '/v1/auth/logout',
        ...options
    });
};

/**
 * Get Current User
 * Get the currently authenticated user.
 */
export const getCurrentAuthUser = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentAuthUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCurrentAuthUserResponses, GetCurrentAuthUserErrors, ThrowOnError>({
        url: '/v1/auth/me',
        ...options
    });
};

/**
 * Refresh Session
 * Refresh authentication session with a new JWT token.
 */
export const refreshAuthSession = <ThrowOnError extends boolean = false>(options?: Options<RefreshAuthSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RefreshAuthSessionResponses, RefreshAuthSessionErrors, ThrowOnError>({
        url: '/v1/auth/refresh',
        ...options
    });
};

/**
 * Resend Email Verification
 * Resend verification email to the authenticated user. Rate limited to 3 per hour.
 */
export const resendVerificationEmail = <ThrowOnError extends boolean = false>(options?: Options<ResendVerificationEmailData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ResendVerificationEmailResponses, ResendVerificationEmailErrors, ThrowOnError>({
        url: '/v1/auth/email/resend',
        ...options
    });
};

/**
 * Verify Email
 * Verify email address with token from email link. Returns JWT for auto-login.
 */
export const verifyEmail = <ThrowOnError extends boolean = false>(options: Options<VerifyEmailData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<VerifyEmailResponses, VerifyEmailErrors, ThrowOnError>({
        url: '/v1/auth/email/verify',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Password Policy
 * Get current password policy requirements for frontend validation
 */
export const getPasswordPolicy = <ThrowOnError extends boolean = false>(options?: Options<GetPasswordPolicyData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetPasswordPolicyResponses, unknown, ThrowOnError>({
        url: '/v1/auth/password/policy',
        ...options
    });
};

/**
 * Check Password Strength
 * Check password strength and get validation feedback
 */
export const checkPasswordStrength = <ThrowOnError extends boolean = false>(options: Options<CheckPasswordStrengthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CheckPasswordStrengthResponses, CheckPasswordStrengthErrors, ThrowOnError>({
        url: '/v1/auth/password/check',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Forgot Password
 * Request password reset email. Always returns success to prevent email enumeration.
 */
export const forgotPassword = <ThrowOnError extends boolean = false>(options: Options<ForgotPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ForgotPasswordResponses, ForgotPasswordErrors, ThrowOnError>({
        url: '/v1/auth/password/forgot',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Validate Reset Token
 * Check if a password reset token is valid without consuming it.
 */
export const validateResetToken = <ThrowOnError extends boolean = false>(options: Options<ValidateResetTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ValidateResetTokenResponses, ValidateResetTokenErrors, ThrowOnError>({
        url: '/v1/auth/password/reset/validate',
        ...options
    });
};

/**
 * Reset Password
 * Reset password with token from email. Returns JWT for auto-login.
 */
export const resetPassword = <ThrowOnError extends boolean = false>(options: Options<ResetPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ResetPasswordResponses, ResetPasswordErrors, ThrowOnError>({
        url: '/v1/auth/password/reset',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Generate SSO Token
 * Generate a temporary SSO token for cross-app authentication.
 */
export const generateSsoToken = <ThrowOnError extends boolean = false>(options?: Options<GenerateSsoTokenData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GenerateSsoTokenResponses, GenerateSsoTokenErrors, ThrowOnError>({
        url: '/v1/auth/sso-token',
        ...options
    });
};

/**
 * SSO Token Exchange
 * Exchange SSO token for secure session handoff to target application.
 */
export const ssoTokenExchange = <ThrowOnError extends boolean = false>(options: Options<SsoTokenExchangeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SsoTokenExchangeResponses, SsoTokenExchangeErrors, ThrowOnError>({
        url: '/v1/auth/sso-exchange',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Complete SSO Authentication
 * Complete SSO authentication using session ID from secure handoff.
 */
export const completeSsoAuth = <ThrowOnError extends boolean = false>(options: Options<CompleteSsoAuthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CompleteSsoAuthResponses, CompleteSsoAuthErrors, ThrowOnError>({
        url: '/v1/auth/sso-complete',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get CAPTCHA Configuration
 * Get CAPTCHA configuration including site key and whether CAPTCHA is required.
 */
export const getCaptchaConfig = <ThrowOnError extends boolean = false>(options?: Options<GetCaptchaConfigData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCaptchaConfigResponses, unknown, ThrowOnError>({
        url: '/v1/auth/captcha/config',
        ...options
    });
};

/**
 * Health Check
 * Service health check endpoint for monitoring and load balancers
 */
export const getServiceStatus = <ThrowOnError extends boolean = false>(options?: Options<GetServiceStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetServiceStatusResponses, unknown, ThrowOnError>({
        url: '/v1/status',
        ...options
    });
};

/**
 * Get Current User
 * Returns information about the currently authenticated user.
 */
export const getCurrentUser = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCurrentUserResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user',
        ...options
    });
};

/**
 * Update User Profile
 * Update the current user's profile information.
 */
export const updateUser = <ThrowOnError extends boolean = false>(options: Options<UpdateUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserResponses, UpdateUserErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get All Credit Summaries
 * Get credit summaries for all graphs owned by the user.
 *
 * This endpoint provides a consolidated view of credit usage across
 * all graphs where the user has access, helping to monitor overall
 * credit consumption and plan usage.
 *
 * No credits are consumed for viewing summaries.
 */
export const getAllCreditSummaries = <ThrowOnError extends boolean = false>(options?: Options<GetAllCreditSummariesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAllCreditSummariesResponses, GetAllCreditSummariesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/credits',
        ...options
    });
};

/**
 * Update Password
 * Update the current user's password.
 */
export const updateUserPassword = <ThrowOnError extends boolean = false>(options: Options<UpdateUserPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserPasswordResponses, UpdateUserPasswordErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/password',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List API Keys
 * Get all API keys for the current user.
 */
export const listUserApiKeys = <ThrowOnError extends boolean = false>(options?: Options<ListUserApiKeysData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ListUserApiKeysResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys',
        ...options
    });
};

/**
 * Create API Key
 * Create a new API key for the current user.
 */
export const createUserApiKey = <ThrowOnError extends boolean = false>(options: Options<CreateUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateUserApiKeyResponses, CreateUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Revoke API Key
 * Revoke (deactivate) an API key.
 */
export const revokeUserApiKey = <ThrowOnError extends boolean = false>(options: Options<RevokeUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<RevokeUserApiKeyResponses, RevokeUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys/{api_key_id}',
        ...options
    });
};

/**
 * Update API Key
 * Update an API key's name or description.
 */
export const updateUserApiKey = <ThrowOnError extends boolean = false>(options: Options<UpdateUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserApiKeyResponses, UpdateUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys/{api_key_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get user limits
 * Retrieve current limits and restrictions for the authenticated user
 */
export const getUserLimits = <ThrowOnError extends boolean = false>(options?: Options<GetUserLimitsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserLimitsResponses, GetUserLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits',
        ...options
    });
};

/**
 * Get user usage statistics
 * Retrieve current usage statistics and remaining limits for the authenticated user
 */
export const getUserUsage = <ThrowOnError extends boolean = false>(options?: Options<GetUserUsageData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserUsageResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits/usage',
        ...options
    });
};

/**
 * Get all shared repository limits
 * Get rate limit status for all shared repositories the user has access to.
 */
export const getAllSharedRepositoryLimits = <ThrowOnError extends boolean = false>(options?: Options<GetAllSharedRepositoryLimitsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAllSharedRepositoryLimitsResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits/shared-repositories/summary',
        ...options
    });
};

/**
 * Get shared repository rate limit status
 * Get current rate limit status and usage for a shared repository.
 *
 * Returns:
 * - Current usage across different time windows
 * - Rate limits based on subscription tier
 * - Remaining quota
 * - Reset times
 *
 * Note: All queries are included - this only shows rate limit status.
 */
export const getSharedRepositoryLimits = <ThrowOnError extends boolean = false>(options: Options<GetSharedRepositoryLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSharedRepositoryLimitsResponses, GetSharedRepositoryLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits/shared-repositories/{repository}',
        ...options
    });
};

/**
 * Get User Usage Overview
 * Get a high-level overview of usage statistics for the current user.
 */
export const getUserUsageOverview = <ThrowOnError extends boolean = false>(options?: Options<GetUserUsageOverviewData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserUsageOverviewResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/analytics/overview',
        ...options
    });
};

/**
 * Get Detailed User Analytics
 * Get comprehensive analytics for the current user including API usage and recent activity.
 */
export const getDetailedUserAnalytics = <ThrowOnError extends boolean = false>(options?: Options<GetDetailedUserAnalyticsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetDetailedUserAnalyticsResponses, GetDetailedUserAnalyticsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/analytics/detailed',
        ...options
    });
};

/**
 * Get User Subscriptions
 * Retrieve user's current shared repository subscriptions with detailed information
 */
export const getUserSharedSubscriptions = <ThrowOnError extends boolean = false>(options?: Options<GetUserSharedSubscriptionsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserSharedSubscriptionsResponses, GetUserSharedSubscriptionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories',
        ...options
    });
};

/**
 * Subscribe to Shared Repository
 * Create a new subscription to a shared repository add-on with specified tier
 */
export const subscribeToSharedRepository = <ThrowOnError extends boolean = false>(options: Options<SubscribeToSharedRepositoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SubscribeToSharedRepositoryResponses, SubscribeToSharedRepositoryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/subscribe',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Upgrade Subscription Tier
 * Upgrade a subscription to a higher tier with immediate credit adjustment
 */
export const upgradeSharedRepositorySubscription = <ThrowOnError extends boolean = false>(options: Options<UpgradeSharedRepositorySubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpgradeSharedRepositorySubscriptionResponses, UpgradeSharedRepositorySubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/{subscription_id}/upgrade',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Cancel Subscription
 * Cancel a shared repository subscription and disable associated credit pool
 */
export const cancelSharedRepositorySubscription = <ThrowOnError extends boolean = false>(options: Options<CancelSharedRepositorySubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<CancelSharedRepositorySubscriptionResponses, CancelSharedRepositorySubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/{subscription_id}',
        ...options
    });
};

/**
 * Get Credit Balances
 * Retrieve credit balances for all shared repository subscriptions
 */
export const getSharedRepositoryCredits = <ThrowOnError extends boolean = false>(options?: Options<GetSharedRepositoryCreditsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetSharedRepositoryCreditsResponses, GetSharedRepositoryCreditsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/credits',
        ...options
    });
};

/**
 * Get Repository Credits
 * Get credit balance for a specific shared repository
 */
export const getRepositoryCredits = <ThrowOnError extends boolean = false>(options: Options<GetRepositoryCreditsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetRepositoryCreditsResponses, GetRepositoryCreditsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/credits/{repository}',
        ...options
    });
};

/**
 * List Connections
 * List all data connections in the graph.
 *
 * Returns active and inactive connections with their current status.
 * Connections can be filtered by:
 * - **Entity**: Show connections for a specific entity
 * - **Provider**: Filter by connection type (sec, quickbooks, plaid)
 *
 * Each connection shows:
 * - Current sync status and health
 * - Last successful sync timestamp
 * - Configuration metadata
 * - Error messages if any
 *
 * No credits are consumed for listing connections.
 */
export const listConnections = <ThrowOnError extends boolean = false>(options: Options<ListConnectionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListConnectionsResponses, ListConnectionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections',
        ...options
    });
};

/**
 * Create Connection
 * Create a new data connection for external system integration.
 *
 * This endpoint initiates connections to external data sources:
 *
 * **SEC Connections**:
 * - Provide entity CIK for automatic filing retrieval
 * - No authentication needed
 * - Begins immediate data sync
 *
 * **QuickBooks Connections**:
 * - Returns OAuth URL for authorization
 * - Requires admin permissions in QuickBooks
 * - Complete with OAuth callback
 *
 * **Plaid Connections**:
 * - Returns Plaid Link token
 * - User completes bank authentication
 * - Exchange public token for access
 *
 * Note:
 * This operation is included - no credit consumption required.
 */
export const createConnection = <ThrowOnError extends boolean = false>(options: Options<CreateConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateConnectionResponses, CreateConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Connection Options
 * Get metadata about all available data connection providers.
 *
 * This endpoint returns comprehensive information about each supported provider:
 *
 * **SEC EDGAR**: Public entity financial filings
 * - No authentication required (public data)
 * - 10-K, 10-Q, 8-K reports with XBRL data
 * - Historical and real-time filing access
 *
 * **QuickBooks Online**: Full accounting system integration
 * - OAuth 2.0 authentication
 * - Chart of accounts, transactions, trial balance
 * - Real-time sync capabilities
 *
 * **Plaid**: Bank account connections
 * - Secure bank authentication via Plaid Link
 * - Transaction history and balances
 * - Multi-account support
 *
 * No credits are consumed for viewing connection options.
 */
export const getConnectionOptions = <ThrowOnError extends boolean = false>(options: Options<GetConnectionOptionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetConnectionOptionsResponses, GetConnectionOptionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/options',
        ...options
    });
};

/**
 * Exchange Link Token
 * Exchange a public token for permanent access credentials.
 *
 * This completes the embedded authentication flow after user authorization.
 *
 * The exchange process:
 * 1. Validates the temporary public token
 * 2. Exchanges it for permanent access credentials
 * 3. Updates the connection with account information
 * 4. Optionally triggers initial data sync
 *
 * Supported providers:
 * - **Plaid**: Exchanges Plaid Link public token for access token
 *
 * Security:
 * - Public tokens expire after 30 minutes
 * - Each token can only be exchanged once
 * - Full audit trail is maintained
 *
 * No credits are consumed for token exchange.
 */
export const exchangeLinkToken = <ThrowOnError extends boolean = false>(options: Options<ExchangeLinkTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExchangeLinkTokenResponses, ExchangeLinkTokenErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/link/exchange',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Link Token
 * Create a link token for embedded authentication providers.
 *
 * This endpoint generates a temporary token used to initialize embedded authentication UI.
 *
 * Currently supported providers:
 * - **Plaid**: Bank account connections with real-time transaction access
 *
 * The link token:
 * - Expires after 4 hours
 * - Is single-use only
 * - Must be used with the matching frontend SDK
 * - Includes user and entity context
 *
 * No credits are consumed for creating link tokens.
 */
export const createLinkToken = <ThrowOnError extends boolean = false>(options: Options<CreateLinkTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateLinkTokenResponses, CreateLinkTokenErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/link/token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Init Oauth
 * Initialize OAuth flow for a connection.
 *
 * This generates an authorization URL that the frontend should redirect the user to.
 * Currently supports: QuickBooks
 */
export const initOAuth = <ThrowOnError extends boolean = false>(options: Options<InitOAuthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<InitOAuthResponses, InitOAuthErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/oauth/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * OAuth Callback
 * Handle OAuth callback from provider after user authorization.
 *
 * This endpoint completes the OAuth flow:
 * 1. Validates the OAuth state parameter
 * 2. Exchanges authorization code for access tokens
 * 3. Stores tokens securely
 * 4. Updates connection status
 * 5. Optionally triggers initial sync
 *
 * Supported providers:
 * - **QuickBooks**: Accounting data integration
 *
 * Security measures:
 * - State validation prevents session hijacking
 * - User context is verified
 * - Tokens are encrypted before storage
 * - Full audit trail is maintained
 *
 * No credits are consumed for OAuth callbacks.
 */
export const oauthCallback = <ThrowOnError extends boolean = false>(options: Options<OauthCallbackData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<OauthCallbackResponses, OauthCallbackErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/oauth/callback/{provider}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Connection
 * Delete a data connection and clean up related resources.
 *
 * This operation:
 * - Removes the connection configuration
 * - Preserves any imported data in the graph
 * - Performs provider-specific cleanup
 * - Revokes stored credentials
 *
 * Note:
 * This operation is included - no credit consumption required.
 *
 * Only users with admin role can delete connections.
 */
export const deleteConnection = <ThrowOnError extends boolean = false>(options: Options<DeleteConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteConnectionResponses, DeleteConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/{connection_id}',
        ...options
    });
};

/**
 * Get Connection
 * Get detailed information about a specific connection.
 *
 * Returns comprehensive connection details including:
 * - Current status and health indicators
 * - Authentication state
 * - Sync history and statistics
 * - Error details if any
 * - Provider-specific metadata
 *
 * No credits are consumed for viewing connection details.
 */
export const getConnection = <ThrowOnError extends boolean = false>(options: Options<GetConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetConnectionResponses, GetConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/{connection_id}',
        ...options
    });
};

/**
 * Sync Connection
 * Trigger a data synchronization for the connection.
 *
 * Initiates data sync based on provider type:
 *
 * **SEC Sync**:
 * - Downloads latest filings from EDGAR
 * - Parses XBRL data and updates graph
 * - Typically completes in 5-10 minutes
 *
 * **QuickBooks Sync**:
 * - Fetches latest transactions and balances
 * - Updates chart of accounts
 * - Generates fresh trial balance
 * - Duration depends on data volume
 *
 * **Plaid Sync**:
 * - Retrieves recent bank transactions
 * - Updates account balances
 * - Categorizes new transactions
 *
 * Note:
 * This operation is included - no credit consumption required.
 *
 * Returns a task ID for monitoring sync progress.
 */
export const syncConnection = <ThrowOnError extends boolean = false>(options: Options<SyncConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SyncConnectionResponses, SyncConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/{connection_id}/sync',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Auto-select agent for query
 * Automatically select the best agent for your query.
 *
 * **Agent Selection Process:**
 *
 * The orchestrator intelligently routes your query by:
 * 1. Analyzing query intent and complexity
 * 2. Enriching context with RAG if enabled
 * 3. Evaluating all available agents against selection criteria
 * 4. Selecting the best match based on confidence scores
 * 5. Executing the query with the selected agent
 *
 * **Available Agent Types:**
 * - `financial`: Financial analysis, SEC filings, company metrics
 * - `research`: General research, data exploration, trend analysis
 * - `rag`: Knowledge base search using RAG enrichment
 *
 * **Execution Modes:**
 * - `quick`: Fast responses (~2-5s), suitable for simple queries
 * - `standard`: Balanced approach (~5-15s), default mode
 * - `extended`: Comprehensive analysis (~15-60s), deep research
 * - `streaming`: Real-time response streaming
 *
 * **Confidence Score Interpretation:**
 * - `0.9-1.0`: High confidence, agent is ideal match
 * - `0.7-0.9`: Good confidence, agent is suitable
 * - `0.5-0.7`: Moderate confidence, agent can handle but may not be optimal
 * - `0.3-0.5`: Low confidence, fallback agent used
 * - `<0.3`: Very low confidence, consider using specific agent endpoint
 *
 * **Credit Costs:**
 * - Quick mode: 5-10 credits per query
 * - Standard mode: 15-25 credits per query
 * - Extended mode: 30-75 credits per query
 * - RAG enrichment: +5-15 credits (if enabled)
 *
 * **Use Cases:**
 * - Ask questions without specifying agent type
 * - Get intelligent routing for complex multi-domain queries
 * - Leverage conversation history for contextual understanding
 * - Enable RAG for knowledge base enrichment
 *
 * See request/response examples in the "Examples" dropdown below.
 */
export const autoSelectAgent = <ThrowOnError extends boolean = false>(options: Options<AutoSelectAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<AutoSelectAgentResponses, AutoSelectAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Execute specific agent
 * Execute a specific agent type directly.
 *
 * Available agents:
 * - **financial**: Financial analysis, SEC filings, accounting data
 * - **research**: Deep research and comprehensive analysis
 * - **rag**: Fast retrieval without AI (no credits required)
 *
 * Use this endpoint when you know which agent you want to use.
 */
export const executeSpecificAgent = <ThrowOnError extends boolean = false>(options: Options<ExecuteSpecificAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecuteSpecificAgentResponses, ExecuteSpecificAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/{agent_type}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Batch process multiple queries
 * Process multiple queries either sequentially or in parallel.
 *
 * **Features:**
 * - Process up to 10 queries in a single request
 * - Sequential or parallel execution modes
 * - Automatic error handling per query
 * - Credit checking before execution
 *
 * **Use Cases:**
 * - Bulk analysis of multiple entities
 * - Comparative analysis across queries
 * - Automated report generation
 *
 * Returns individual results for each query with execution metrics.
 */
export const batchProcessQueries = <ThrowOnError extends boolean = false>(options: Options<BatchProcessQueriesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BatchProcessQueriesResponses, BatchProcessQueriesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/batch',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List available agents
 * Get a comprehensive list of all available agents with their metadata.
 *
 * **Returns:**
 * - Agent types and names
 * - Capabilities and supported modes
 * - Version information
 * - Credit requirements
 *
 * Use the optional `capability` filter to find agents with specific capabilities.
 */
export const listAgents = <ThrowOnError extends boolean = false>(options: Options<ListAgentsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListAgentsResponses, ListAgentsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/list',
        ...options
    });
};

/**
 * Get agent metadata
 * Get comprehensive metadata for a specific agent type.
 *
 * **Returns:**
 * - Agent name and description
 * - Version information
 * - Supported capabilities and modes
 * - Credit requirements
 * - Author and tags
 * - Configuration options
 *
 * Use this to understand agent capabilities before execution.
 */
export const getAgentMetadata = <ThrowOnError extends boolean = false>(options: Options<GetAgentMetadataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetAgentMetadataResponses, GetAgentMetadataErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/{agent_type}/metadata',
        ...options
    });
};

/**
 * Get agent recommendations
 * Get intelligent agent recommendations for a specific query.
 *
 * **How it works:**
 * 1. Analyzes query content and structure
 * 2. Evaluates agent capabilities
 * 3. Calculates confidence scores
 * 4. Returns ranked recommendations
 *
 * **Use this when:**
 * - Unsure which agent to use
 * - Need to understand agent suitability
 * - Want confidence scores for decision making
 *
 * Returns top agents ranked by confidence with explanations.
 */
export const recommendAgent = <ThrowOnError extends boolean = false>(options: Options<RecommendAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RecommendAgentResponses, RecommendAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/recommend',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List MCP Tools
 * Get available Model Context Protocol tools for graph analysis.
 *
 * This endpoint returns a comprehensive list of MCP tools optimized for AI agents:
 * - Tool schemas with detailed parameter documentation
 * - Context-aware descriptions based on graph type
 * - Capability indicators for streaming and progress
 *
 * The tool list is customized based on:
 * - Graph type (shared repository vs user graph)
 * - User permissions and subscription tier
 * - Backend capabilities (Kuzu, Neo4j, etc.)
 *
 * **Note:**
 * MCP tool listing is included - no credit consumption required.
 */
export const listMcpTools = <ThrowOnError extends boolean = false>(options: Options<ListMcpToolsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListMcpToolsResponses, ListMcpToolsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/mcp/tools',
        ...options
    });
};

/**
 * Execute MCP Tool
 * Execute an MCP tool with intelligent response optimization.
 *
 * This endpoint automatically selects the best execution strategy based on:
 * - Tool type and estimated complexity
 * - Client capabilities (AI agent detection)
 * - System load and queue status
 * - Graph type (shared repository vs user graph)
 *
 * **Response Formats:**
 * - **JSON**: Direct response for small/fast operations
 * - **SSE**: Server-Sent Events for progress monitoring
 * - **NDJSON**: Newline-delimited JSON for streaming
 * - **Queued**: Asynchronous execution with status monitoring
 *
 * **SSE Streaming Support:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation to direct response if SSE unavailable
 * - Progress events for long-running operations
 *
 * **AI Agent Optimization:**
 * The Node.js MCP client transparently handles all response formats,
 * presenting a unified interface to AI agents. Streaming responses are
 * automatically aggregated for seamless consumption.
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Connection limit or rate limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - `408 Request Timeout`: Tool execution exceeded timeout
 * - Clients should implement exponential backoff on errors
 *
 * **Credit Model:**
 * MCP tool execution is included - no credit consumption required. Database
 * operations (queries, schema inspection, analytics) are completely free.
 * Only AI operations that invoke Claude or other LLM APIs consume credits,
 * which happens at the AI agent layer, not the MCP tool layer.
 */
export const callMcpTool = <ThrowOnError extends boolean = false>(options: Options<CallMcpToolData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CallMcpToolResponses, CallMcpToolErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/mcp/call-tool',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List graph database backups
 * List all backups for the specified graph database
 */
export const listBackups = <ThrowOnError extends boolean = false>(options: Options<ListBackupsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListBackupsResponses, ListBackupsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups',
        ...options
    });
};

/**
 * Create Backup
 * Create a backup of the graph database.
 *
 * Creates a complete backup of the graph database (.kuzu file) with:
 * - **Format**: Full database backup only (complete .kuzu file)
 * - **Compression**: Always enabled for optimal storage
 * - **Encryption**: Optional AES-256 encryption for security
 * - **Retention**: Configurable retention period (1-2555 days)
 *
 * **Backup Features:**
 * - **Complete Backup**: Full database file backup
 * - **Consistency**: Point-in-time consistent snapshot
 * - **Download Support**: Unencrypted backups can be downloaded
 * - **Restore Support**: Future support for encrypted backup restoration
 *
 * **Operation State Machine:**
 * ```
 * pending  processing  completed
 *  failed
 * ```
 * - **pending**: Backup queued, waiting to start
 * - **processing**: Actively backing up database
 * - **completed**: Backup successfully created and stored
 * - **failed**: Backup failed (check error message)
 *
 * **Expected Durations:**
 * Operation times vary by database size:
 * - **Small** (<1GB): 30 seconds - 2 minutes
 * - **Medium** (1-10GB): 2-10 minutes
 * - **Large** (10-100GB): 10-30 minutes
 * - **Very Large** (>100GB): 30+ minutes
 *
 * **Progress Monitoring:**
 * Use the returned operation_id to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.addEventListener('operation_progress', (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Backup progress:', data.progress_percent + '%');
 * console.log('Status:', data.status); // pending, processing, completed, failed
 * });
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Important Notes:**
 * - Only full_dump format is supported (no CSV/JSON exports)
 * - Compression is always enabled
 * - Encrypted backups cannot be downloaded (security measure)
 * - All backups are stored securely in cloud storage
 *
 * **Credit Consumption:**
 * - Base cost: 25.0 credits
 * - Large databases (>10GB): 50.0 credits
 * - Multiplied by graph tier
 *
 * Returns operation details for SSE monitoring.
 */
export const createBackup = <ThrowOnError extends boolean = false>(options: Options<CreateBackupData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateBackupResponses, CreateBackupErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get temporary download URL for backup
 * Generate a temporary download URL for a backup (unencrypted, compressed .kuzu files only)
 */
export const getBackupDownloadUrl = <ThrowOnError extends boolean = false>(options: Options<GetBackupDownloadUrlData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetBackupDownloadUrlResponses, GetBackupDownloadUrlErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups/{backup_id}/download',
        ...options
    });
};

/**
 * Restore Encrypted Backup
 * Restore a graph database from an encrypted backup.
 *
 * Restores a complete graph database from an encrypted backup:
 * - **Format**: Only full_dump backups can be restored
 * - **Encryption**: Only encrypted backups can be restored (security requirement)
 * - **System Backup**: Creates automatic backup of existing database before restore
 * - **Verification**: Optionally verifies database integrity after restore
 *
 * **Restore Features:**
 * - **Atomic Operation**: Complete replacement of database
 * - **Rollback Protection**: System backup created before restore
 * - **Data Integrity**: Verification ensures successful restore
 * - **Security**: Only encrypted backups to prevent data tampering
 *
 * **Operation State Machine:**
 * ```
 * pending  backing_up_current  downloading  restoring  verifying  completed
 *  failed
 * ```
 * - **pending**: Restore queued, waiting to start
 * - **backing_up_current**: Creating safety backup of existing database
 * - **downloading**: Downloading backup from storage
 * - **restoring**: Replacing database with backup contents
 * - **verifying**: Verifying database integrity (if enabled)
 * - **completed**: Restore successful, database operational
 * - **failed**: Restore failed (rollback may be available)
 *
 * **Expected Durations:**
 * Operation times vary by database size (includes backup + restore):
 * - **Small** (<1GB): 1-3 minutes
 * - **Medium** (1-10GB): 5-15 minutes
 * - **Large** (10-100GB): 20-45 minutes
 * - **Very Large** (>100GB): 45+ minutes
 *
 * Note: Restore operations take longer than backups due to safety backup step.
 *
 * **Progress Monitoring:**
 * Use the returned operation_id to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.addEventListener('operation_progress', (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Restore progress:', data.message);
 * console.log('Status:', data.status); // Shows current state
 * });
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Important Notes:**
 * - Only encrypted backups can be restored (security measure)
 * - Existing database is backed up to S3 before restore
 * - Restore is a destructive operation - existing data is replaced
 * - System backups are stored separately for recovery
 *
 * **Credit Consumption:**
 * - Base cost: 100.0 credits
 * - Large databases (>10GB): 200.0 credits
 * - Multiplied by graph tier
 *
 * Returns operation details for SSE monitoring.
 */
export const restoreBackup = <ThrowOnError extends boolean = false>(options: Options<RestoreBackupData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RestoreBackupResponses, RestoreBackupErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups/{backup_id}/restore',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get backup statistics
 * Get comprehensive backup statistics for the specified graph database
 */
export const getBackupStats = <ThrowOnError extends boolean = false>(options: Options<GetBackupStatsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetBackupStatsResponses, GetBackupStatsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups/stats',
        ...options
    });
};

/**
 * Get Graph Metrics
 * Get comprehensive metrics for the graph database.
 *
 * Provides detailed analytics including:
 * - **Node Statistics**: Counts by type (Entity, Report, Account, Transaction)
 * - **Relationship Metrics**: Connection counts and patterns
 * - **Data Quality**: Completeness scores and validation results
 * - **Performance Metrics**: Query response times and database health
 * - **Storage Analytics**: Database size and growth trends
 *
 * This data helps with:
 * - Monitoring data completeness
 * - Identifying data quality issues
 * - Capacity planning
 * - Performance optimization
 *
 * Note:
 * This operation is included - no credit consumption required.
 */
export const getGraphMetrics = <ThrowOnError extends boolean = false>(options: Options<GetGraphMetricsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphMetricsResponses, GetGraphMetricsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/analytics',
        ...options
    });
};

/**
 * Get Usage Statistics
 * Get detailed usage statistics for the graph.
 *
 * Provides temporal usage patterns including:
 * - **Query Volume**: API calls per day/hour
 * - **Credit Consumption**: Usage patterns and trends
 * - **Operation Breakdown**: Usage by operation type
 * - **User Activity**: Access patterns by user role
 * - **Peak Usage Times**: Identify high-activity periods
 *
 * Time ranges available:
 * - Last 24 hours (hourly breakdown)
 * - Last 7 days (daily breakdown)
 * - Last 30 days (daily breakdown)
 * - Custom date ranges
 *
 * Useful for:
 * - Capacity planning
 * - Cost optimization
 * - Usage trend analysis
 * - Performance tuning
 *
 * Note:
 * This operation is included - no credit consumption required.
 */
export const getGraphUsageStats = <ThrowOnError extends boolean = false>(options: Options<GetGraphUsageStatsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphUsageStatsResponses, GetGraphUsageStatsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/analytics/usage',
        ...options
    });
};

/**
 * Execute Cypher Query (Read-Only)
 * Execute a read-only Cypher query with intelligent response optimization.
 *
 * **IMPORTANT: This endpoint is READ-ONLY.** Write operations (CREATE, MERGE, SET, DELETE) are not allowed.
 * To load data into your graph, use the staging pipeline:
 * 1. Create file upload: `POST /v1/graphs/{graph_id}/tables/{table_name}/files`
 * 2. Ingest to graph: `POST /v1/graphs/{graph_id}/tables/ingest`
 *
 * **Security Best Practice - Use Parameterized Queries:**
 * ALWAYS use query parameters instead of string interpolation to prevent injection attacks:
 * -  SAFE: `MATCH (n:Entity {type: $entity_type}) RETURN n` with `parameters: {"entity_type": "Company"}`
 * -  UNSAFE: `MATCH (n:Entity {type: "Company"}) RETURN n` with user input concatenated into query string
 *
 * Query parameters provide automatic escaping and type safety. All examples in this API use parameterized queries.
 *
 * This endpoint automatically selects the best execution strategy based on:
 * - Query characteristics (size, complexity)
 * - Client capabilities (SSE, NDJSON, JSON)
 * - System load (queue status, concurrent queries)
 * - User preferences (mode parameter, headers)
 *
 * **Response Modes:**
 * - `auto` (default): Intelligent automatic selection
 * - `sync`: Force synchronous JSON response (best for testing)
 * - `async`: Force queued response with SSE monitoring endpoints (no polling needed)
 * - `stream`: Force streaming response (SSE or NDJSON)
 *
 * **Client Detection:**
 * - Automatically detects testing tools (Postman, Swagger UI)
 * - Adjusts behavior for better interactive experience
 * - Respects Accept and Prefer headers for capabilities
 *
 * **Streaming Support (SSE):**
 * - Real-time events with progress updates
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 * - 30-second keepalive to prevent timeouts
 *
 * **Streaming Support (NDJSON):**
 * - Efficient line-delimited JSON for large results
 * - Automatic chunking (configurable 10-10000 rows)
 * - No connection limits (stateless streaming)
 *
 * **Queue Management:**
 * - Automatic queuing under high load
 * - Real-time monitoring via SSE events (no polling needed)
 * - Priority based on subscription tier
 * - Queue position and progress updates pushed via SSE
 * - Connect to returned `/v1/operations/{id}/stream` endpoint for updates
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Rate limit or connection limit exceeded
 * - `503 Service Unavailable`: Circuit breaker open or SSE disabled
 * - Clients should implement exponential backoff
 *
 * **Note:**
 * Query operations are included - no credit consumption required.
 * Queue position is based on subscription tier for priority.
 */
export const executeCypherQuery = <ThrowOnError extends boolean = false>(options: Options<ExecuteCypherQueryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecuteCypherQueryResponses, ExecuteCypherQueryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/query',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Runtime Graph Schema
 * Get runtime schema information for the specified graph database.
 *
 * ## What This Returns
 *
 * This endpoint inspects the **actual current state** of the graph database and returns:
 * - **Node Labels**: All node types currently in the database
 * - **Relationship Types**: All relationship types currently in the database
 * - **Node Properties**: Properties discovered from actual data (up to 10 properties per node type)
 *
 * ## Runtime vs Declared Schema
 *
 * **Use this endpoint** (`/schema`) when you need to know:
 * - What data is ACTUALLY in the database right now
 * - What properties exist on real nodes
 * - What relationships have been created
 * - Current database structure for querying
 *
 * **Use `/schema/export` instead** when you need:
 * - The original schema definition used to create the graph
 * - Schema in a specific format (JSON, YAML, Cypher DDL)
 * - Schema for documentation or version control
 * - Schema to replicate in another graph
 *
 * ## Example Use Cases
 *
 * - **Building queries**: See what node labels and properties exist to write accurate Cypher
 * - **Data exploration**: Discover what's in an unfamiliar graph
 * - **Schema drift detection**: Compare runtime vs declared schema
 * - **API integration**: Dynamically adapt to current graph structure
 *
 * ## Performance Note
 *
 * Property discovery is limited to 10 properties per node type for performance.
 * For complete schema definitions, use `/schema/export`.
 *
 * This operation is included - no credit consumption required.
 */
export const getGraphSchema = <ThrowOnError extends boolean = false>(options: Options<GetGraphSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphSchemaResponses, GetGraphSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/schema',
        ...options
    });
};

/**
 * Export Declared Graph Schema
 * Export the declared schema definition of an existing graph.
 *
 * ## What This Returns
 *
 * This endpoint returns the **original schema definition** that was used to create the graph:
 * - The schema as it was **declared** during graph creation
 * - Complete node and relationship definitions
 * - Property types and constraints
 * - Schema metadata (name, version, type)
 *
 * ## Runtime vs Declared Schema
 *
 * **Use this endpoint** (`/schema/export`) when you need:
 * - The original schema definition used to create the graph
 * - Schema in a specific format (JSON, YAML, Cypher DDL)
 * - Schema for documentation or version control
 * - Schema to replicate in another graph
 *
 * **Use `/schema` instead** when you need:
 * - What data is ACTUALLY in the database right now
 * - What properties exist on real nodes (discovered from data)
 * - Current runtime database structure for querying
 *
 * ## Export Formats
 *
 * ### JSON Format (`format=json`)
 * Returns structured JSON with nodes, relationships, and properties.
 * Best for programmatic access and API integration.
 *
 * ### YAML Format (`format=yaml`)
 * Returns human-readable YAML with comments.
 * Best for documentation and configuration management.
 *
 * ### Cypher DDL Format (`format=cypher`)
 * Returns Cypher CREATE statements for recreating the schema.
 * Best for database migration and replication.
 *
 * ## Data Statistics
 *
 * Set `include_data_stats=true` to include:
 * - Node counts by label
 * - Relationship counts by type
 * - Total nodes and relationships
 *
 * This combines declared schema with runtime statistics.
 *
 * This operation is included - no credit consumption required.
 */
export const exportGraphSchema = <ThrowOnError extends boolean = false>(options: Options<ExportGraphSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ExportGraphSchemaResponses, ExportGraphSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/schema/export',
        ...options
    });
};

/**
 * Validate Schema
 * Validate a custom schema definition before deployment.
 *
 * This endpoint performs comprehensive validation including:
 * - **Structure Validation**: Ensures proper JSON/YAML format
 * - **Type Checking**: Validates data types (STRING, INT, DOUBLE, etc.)
 * - **Constraint Verification**: Checks primary keys and unique constraints
 * - **Relationship Integrity**: Validates node references in relationships
 * - **Naming Conventions**: Ensures valid identifiers
 * - **Compatibility**: Checks against existing extensions if specified
 *
 * Supported formats:
 * - JSON schema definitions
 * - YAML schema definitions
 * - Direct dictionary format
 *
 * Validation helps prevent:
 * - Schema deployment failures
 * - Data integrity issues
 * - Performance problems
 * - Naming conflicts
 *
 * This operation is included - no credit consumption required.
 */
export const validateSchema = <ThrowOnError extends boolean = false>(options: Options<ValidateSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ValidateSchemaResponses, ValidateSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/schema/validate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Current Bill
 * Get current month's billing details for the graph.
 *
 * Returns comprehensive billing information including:
 * - **Credit Usage**: Consumed vs. allocated credits
 * - **Storage Charges**: Current storage usage and costs
 * - **Subscription Tier**: Current plan and features
 * - **Pro-rated Charges**: If plan changed mid-month
 * - **Estimated Total**: Current charges to date
 *
 * Billing calculations are updated hourly. Storage is measured in GB-months.
 *
 *  No credits are consumed for viewing billing information.
 */
export const getCurrentGraphBill = <ThrowOnError extends boolean = false>(options: Options<GetCurrentGraphBillData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCurrentGraphBillResponses, GetCurrentGraphBillErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/billing/current',
        ...options
    });
};

/**
 * Get Usage Details
 * Get detailed usage metrics for the graph.
 *
 * Provides granular usage information including:
 * - **Daily Credit Consumption**: Track credit usage patterns
 * - **Storage Growth**: Monitor database size over time
 * - **Operation Breakdown**: Credits by operation type
 * - **Peak Usage Times**: Identify high-activity periods
 * - **API Call Volumes**: Request counts and patterns
 *
 * Useful for:
 * - Optimizing credit consumption
 * - Capacity planning
 * - Usage trend analysis
 * - Cost optimization
 *
 *  No credits are consumed for viewing usage details.
 */
export const getGraphUsageDetails = <ThrowOnError extends boolean = false>(options: Options<GetGraphUsageDetailsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphUsageDetailsResponses, GetGraphUsageDetailsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/billing/usage',
        ...options
    });
};

/**
 * Get Billing History
 * Get billing history for the graph.
 *
 * Returns a chronological list of monthly bills, perfect for:
 * - Tracking spending trends over time
 * - Identifying usage patterns
 * - Budget forecasting
 * - Financial reporting
 *
 * Each month includes:
 * - Credit usage and overages
 * - Storage charges
 * - Total charges
 * - Usage metrics
 *
 *  No credits are consumed for viewing billing history.
 */
export const getGraphBillingHistory = <ThrowOnError extends boolean = false>(options: Options<GetGraphBillingHistoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphBillingHistoryResponses, GetGraphBillingHistoryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/billing/history',
        ...options
    });
};

/**
 * Get Monthly Bill
 * Get billing details for a specific month.
 *
 * Retrieve historical billing information for any previous month.
 * Useful for:
 * - Reconciling past charges
 * - Tracking usage trends
 * - Expense reporting
 * - Budget analysis
 *
 * Returns the same detailed breakdown as the current bill endpoint.
 *
 *  No credits are consumed for viewing billing history.
 */
export const getGraphMonthlyBill = <ThrowOnError extends boolean = false>(options: Options<GetGraphMonthlyBillData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphMonthlyBillResponses, GetGraphMonthlyBillErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/billing/history/{year}/{month}',
        ...options
    });
};

/**
 * Get Credit Summary
 * Retrieve comprehensive credit usage summary for the specified graph.
 *
 * This endpoint provides:
 * - Current credit balance and monthly allocation
 * - Credit consumption metrics for the current month
 * - Graph tier and credit multiplier information
 * - Usage percentage to help monitor credit consumption
 *
 * No credits are consumed for checking credit status.
 */
export const getCreditSummary = <ThrowOnError extends boolean = false>(options: Options<GetCreditSummaryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCreditSummaryResponses, GetCreditSummaryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/summary',
        ...options
    });
};

/**
 * List Credit Transactions
 * Retrieve detailed credit transaction history for the specified graph.
 *
 * This enhanced endpoint provides:
 * - Detailed transaction records with idempotency information
 * - Summary by operation type to identify high-consumption operations
 * - Date range filtering for analysis
 * - Metadata search capabilities
 *
 * Transaction types include:
 * - ALLOCATION: Monthly credit allocations
 * - CONSUMPTION: Credit usage for operations
 * - BONUS: Bonus credits added by admins
 * - REFUND: Credit refunds
 *
 * No credits are consumed for viewing transaction history.
 */
export const listCreditTransactions = <ThrowOnError extends boolean = false>(options: Options<ListCreditTransactionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListCreditTransactionsResponses, ListCreditTransactionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/transactions',
        ...options
    });
};

/**
 * Check Credit Balance
 * Check if the graph has sufficient credits for a planned operation.
 *
 * This endpoint allows you to verify credit availability before performing
 * an operation, helping prevent failed operations due to insufficient credits.
 *
 * The check considers:
 * - Base operation cost
 * - Graph tier multiplier
 * - Current credit balance
 *
 * No credits are consumed for checking availability.
 */
export const checkCreditBalance = <ThrowOnError extends boolean = false>(options: Options<CheckCreditBalanceData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<CheckCreditBalanceResponses, CheckCreditBalanceErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/balance/check',
        ...options
    });
};

/**
 * Get Storage Usage
 * Get storage usage history for a graph.
 *
 * Returns detailed storage usage information including:
 * - Daily average storage consumption
 * - Storage trends over time
 * - Credit costs for storage
 * - Current storage billing information
 *
 * This endpoint helps users understand their storage patterns
 * and associated credit costs.
 */
export const getStorageUsage = <ThrowOnError extends boolean = false>(options: Options<GetStorageUsageData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetStorageUsageResponses, GetStorageUsageErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/storage/usage',
        ...options
    });
};

/**
 * Check Storage Limits
 * Check storage limits and usage for a graph.
 *
 * Returns comprehensive storage limit information including:
 * - Current storage usage
 * - Effective limit (override or default)
 * - Usage percentage and warnings
 * - Recommendations for limit management
 *
 * This endpoint helps users monitor storage usage and plan for potential
 * limit increases. No credits are consumed for checking storage limits.
 */
export const checkStorageLimits = <ThrowOnError extends boolean = false>(options: Options<CheckStorageLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<CheckStorageLimitsResponses, CheckStorageLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/storage/limits',
        ...options
    });
};

/**
 * Database Health Check
 * Get comprehensive health information for the graph database.
 *
 * Returns detailed health metrics including:
 * - **Connection Status**: Database connectivity and responsiveness
 * - **Performance Metrics**: Query execution times and throughput
 * - **Resource Usage**: Memory and storage utilization
 * - **Error Monitoring**: Recent error rates and patterns
 * - **Uptime Statistics**: Service availability metrics
 *
 * Health indicators:
 * - **Status**: healthy, degraded, or unhealthy
 * - **Query Performance**: Average execution times
 * - **Error Rates**: Recent failure percentages
 * - **Resource Usage**: Memory and storage consumption
 * - **Alerts**: Active warnings or issues
 *
 * This endpoint provides essential monitoring data for operational visibility.
 */
export const getDatabaseHealth = <ThrowOnError extends boolean = false>(options: Options<GetDatabaseHealthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetDatabaseHealthResponses, GetDatabaseHealthErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/health',
        ...options
    });
};

/**
 * Database Information
 * Get comprehensive database information and statistics.
 *
 * Returns detailed database metrics including:
 * - **Database Metadata**: Name, path, size, and timestamps
 * - **Schema Information**: Node labels, relationship types, and counts
 * - **Storage Statistics**: Database size and usage metrics
 * - **Data Composition**: Node and relationship counts
 * - **Backup Information**: Available backups and last backup date
 * - **Configuration**: Read-only status and schema version
 *
 * Database statistics:
 * - **Size**: Storage usage in bytes and MB
 * - **Content**: Node and relationship counts
 * - **Schema**: Available labels and relationship types
 * - **Backup Status**: Backup availability and recency
 * - **Timestamps**: Creation and modification dates
 *
 * This endpoint provides essential database information for capacity planning and monitoring.
 */
export const getDatabaseInfo = <ThrowOnError extends boolean = false>(options: Options<GetDatabaseInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetDatabaseInfoResponses, GetDatabaseInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/info',
        ...options
    });
};

/**
 * Get Graph Operational Limits
 * Get comprehensive operational limits for the graph database.
 *
 * Returns all operational limits that apply to this graph including:
 * - **Storage Limits**: Maximum storage size and current usage
 * - **Query Limits**: Timeouts, complexity, row limits
 * - **Copy/Ingestion Limits**: File sizes, timeouts, concurrent operations
 * - **Backup Limits**: Frequency, retention, size limits
 * - **Rate Limits**: Requests per minute/hour based on tier
 * - **Credit Limits**: AI operation credits (if applicable)
 *
 * This unified endpoint provides all limits in one place for easier client integration.
 *
 * **Note**: Limits vary based on subscription tier (Standard, Enterprise, Premium).
 */
export const getGraphLimits = <ThrowOnError extends boolean = false>(options: Options<GetGraphLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphLimitsResponses, GetGraphLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/limits',
        ...options
    });
};

/**
 * List Subgraphs
 * List all subgraphs for a parent graph.
 *
 * **Requirements:**
 * - Valid authentication
 * - Parent graph must exist and be accessible to the user
 * - User must have at least 'read' permission on the parent graph
 *
 * **Returns:**
 * - List of all subgraphs for the parent graph
 * - Each subgraph includes its ID, name, description, type, status, and creation date
 */
export const listSubgraphs = <ThrowOnError extends boolean = false>(options: Options<ListSubgraphsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListSubgraphsResponses, ListSubgraphsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs',
        ...options
    });
};

/**
 * Create Subgraph
 * Create a new subgraph within a parent graph.
 *
 * **Requirements:**
 * - Valid authentication
 * - Parent graph must exist and be accessible to the user
 * - User must have 'admin' permission on the parent graph
 * - Parent graph tier must support subgraphs (Enterprise or Premium only)
 * - Must be within subgraph quota limits
 * - Subgraph name must be unique within the parent graph
 *
 * **Returns:**
 * - Created subgraph details including its unique ID
 */
export const createSubgraph = <ThrowOnError extends boolean = false>(options: Options<CreateSubgraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateSubgraphResponses, CreateSubgraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Subgraph
 * Delete a subgraph database.
 *
 * **Requirements:**
 * - Must be a valid subgraph (not parent graph)
 * - User must have admin access to parent graph
 * - Optional backup before deletion
 *
 * **Deletion Options:**
 * - `force`: Delete even if contains data
 * - `backup_first`: Create backup before deletion
 *
 * **Warning:**
 * Deletion is permanent unless backup is created.
 * All data in the subgraph will be lost.
 *
 * **Backup Location:**
 * If backup requested, stored in S3 at:
 * `s3://robosystems-backups/{instance_id}/{database_name}_{timestamp}.backup`
 */
export const deleteSubgraph = <ThrowOnError extends boolean = false>(options: Options<DeleteSubgraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteSubgraphResponses, DeleteSubgraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Subgraph Details
 * Get detailed information about a specific subgraph.
 *
 * **Requirements:**
 * - User must have read access to parent graph
 *
 * **Response includes:**
 * - Full subgraph metadata
 * - Database statistics (nodes, edges)
 * - Size information
 * - Schema configuration
 * - Creation/modification timestamps
 * - Last access time (when available)
 *
 * **Statistics:**
 * Real-time statistics queried from Kuzu:
 * - Node count
 * - Edge count
 * - Database size on disk
 * - Schema information
 */
export const getSubgraphInfo = <ThrowOnError extends boolean = false>(options: Options<GetSubgraphInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSubgraphInfoResponses, GetSubgraphInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_id}/info',
        ...options
    });
};

/**
 * Get Subgraph Quota
 * Get subgraph quota and usage information for a parent graph.
 *
 * **Shows:**
 * - Current subgraph count
 * - Maximum allowed subgraphs per tier
 * - Remaining capacity
 * - Total size usage across all subgraphs
 *
 * **Tier Limits:**
 * - Standard: 0 subgraphs (not supported)
 * - Enterprise: Configurable limit (default: 10 subgraphs)
 * - Premium: Unlimited subgraphs
 * - Limits are defined in deployment configuration
 *
 * **Size Tracking:**
 * Provides aggregate size metrics when available.
 * Individual subgraph sizes shown in list endpoint.
 */
export const getSubgraphQuota = <ThrowOnError extends boolean = false>(options: Options<GetSubgraphQuotaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSubgraphQuotaResponses, GetSubgraphQuotaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs/quota',
        ...options
    });
};

/**
 * List Staging Tables
 * List all DuckDB staging tables with comprehensive metrics and status.
 *
 * Get a complete inventory of all staging tables for a graph, including
 * file counts, storage sizes, and row estimates. Essential for monitoring
 * the data pipeline and determining which tables are ready for ingestion.
 *
 * **Returned Metrics:**
 * - Table name and type (node/relationship)
 * - File count per table
 * - Total storage size in bytes
 * - Estimated row count
 * - S3 location pattern
 * - Ready-for-ingestion status
 *
 * **Use Cases:**
 * - Monitor data upload progress
 * - Check which tables have files ready
 * - Track storage consumption
 * - Validate pipeline before ingestion
 * - Capacity planning
 *
 * **Workflow:**
 * 1. List tables to see current state
 * 2. Upload files to empty tables
 * 3. Re-list to verify uploads
 * 4. Check file counts and sizes
 * 5. Ingest when ready
 *
 * **Important Notes:**
 * - Tables with `file_count > 0` have data ready
 * - Check `total_size_bytes` for storage monitoring
 * - Use `s3_location` to verify upload paths
 * - Empty tables (file_count=0) are skipped during ingestion
 * - Table queries are included - no credit consumption
 */
export const listTables = <ThrowOnError extends boolean = false>(options: Options<ListTablesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListTablesResponses, ListTablesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables',
        ...options
    });
};

/**
 * List Files in Staging Table
 * List all files uploaded to a staging table with comprehensive metadata.
 *
 * Get a complete inventory of all files in a staging table, including upload status,
 * file sizes, row counts, and S3 locations. Essential for monitoring upload progress
 * and validating data before ingestion.
 *
 * **Use Cases:**
 * - Monitor file upload progress
 * - Verify files are ready for ingestion
 * - Check file formats and sizes
 * - Track storage usage per table
 * - Identify failed or incomplete uploads
 * - Pre-ingestion validation
 *
 * **Returned Metadata:**
 * - File ID, name, and format (parquet, csv, json)
 * - Size in bytes and row count (if available)
 * - Upload status and method
 * - Creation and upload timestamps
 * - S3 key for reference
 *
 * **Upload Status Values:**
 * - `pending`: Upload URL generated, awaiting upload
 * - `uploaded`: Successfully uploaded, ready for ingestion
 * - `disabled`: Excluded from ingestion
 * - `archived`: Soft deleted
 * - `failed`: Upload failed
 *
 * **Important Notes:**
 * - Only `uploaded` files are ingested
 * - Check `row_count` to estimate data volume
 * - Use `total_size_bytes` for storage monitoring
 * - Files with `failed` status should be deleted and re-uploaded
 * - File listing is included - no credit consumption
 */
export const listTableFiles = <ThrowOnError extends boolean = false>(options: Options<ListTableFilesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListTableFilesResponses, ListTableFilesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/{table_name}/files',
        ...options
    });
};

/**
 * Get File Upload URL
 * Generate a presigned S3 URL for secure file upload.
 *
 * Initiates file upload to a staging table by generating a secure, time-limited
 * presigned S3 URL. Files are uploaded directly to S3, bypassing the API for
 * optimal performance.
 *
 * **Upload Workflow:**
 * 1. Call this endpoint to get presigned URL
 * 2. PUT file directly to S3 URL
 * 3. Call PATCH /tables/files/{file_id} with status='uploaded'
 * 4. Backend validates file and calculates metrics
 * 5. File ready for ingestion
 *
 * **Supported Formats:**
 * - Parquet (`application/x-parquet` with `.parquet` extension)
 * - CSV (`text/csv` with `.csv` extension)
 * - JSON (`application/json` with `.json` extension)
 *
 * **Validation:**
 * - File extension must match content type
 * - File name 1-255 characters
 * - No path traversal characters (.. / \)
 * - Auto-creates table if it doesn't exist
 *
 * **Auto-Table Creation:**
 * Tables are automatically created on first file upload with type inferred from name
 * (e.g., "Transaction"  relationship) and empty schema populated during ingestion.
 *
 * **Important Notes:**
 * - Presigned URLs expire (default: 1 hour)
 * - Use appropriate Content-Type header when uploading to S3
 * - File extension must match content type
 * - Upload URL generation is included - no credit consumption
 */
export const getUploadUrl = <ThrowOnError extends boolean = false>(options: Options<GetUploadUrlData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<GetUploadUrlResponses, GetUploadUrlErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/{table_name}/files',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete File from Staging
 * Delete a file from S3 storage and database tracking.
 *
 * Remove unwanted, duplicate, or incorrect files from staging tables before ingestion.
 * The file is deleted from both S3 and database tracking, and table statistics
 * are automatically recalculated.
 *
 * **Use Cases:**
 * - Remove duplicate uploads
 * - Delete files with incorrect data
 * - Clean up failed uploads
 * - Fix data quality issues before ingestion
 * - Manage storage usage
 *
 * **What Happens:**
 * 1. File deleted from S3 storage
 * 2. Database tracking record removed
 * 3. Table statistics recalculated (file count, size, row count)
 * 4. DuckDB automatically excludes file from future queries
 *
 * **Security:**
 * - Write access required (verified via auth)
 * - Shared repositories block file deletions
 * - Full audit trail of deletion operations
 * - Cannot delete after ingestion to graph
 *
 * **Important Notes:**
 * - Delete files before ingestion for best results
 * - Table statistics update automatically
 * - No need to refresh DuckDB - exclusion is automatic
 * - Consider re-uploading corrected version after deletion
 * - File deletion is included - no credit consumption
 */
export const deleteFile = <ThrowOnError extends boolean = false>(options: Options<DeleteFileData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteFileResponses, DeleteFileErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/files/{file_id}',
        ...options
    });
};

/**
 * Get File Information
 * Get detailed information about a specific file.
 *
 * Retrieve comprehensive metadata for a single file, including upload status,
 * size, row count, and timestamps. Useful for validating individual files
 * before ingestion.
 *
 * **Use Cases:**
 * - Validate file upload completion
 * - Check file metadata before ingestion
 * - Debug upload issues
 * - Verify file format and size
 * - Track file lifecycle
 *
 * **Note:**
 * File info retrieval is included - no credit consumption
 */
export const getFileInfo = <ThrowOnError extends boolean = false>(options: Options<GetFileInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFileInfoResponses, GetFileInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/files/{file_id}',
        ...options
    });
};

/**
 * Update File Upload Status
 * Update file status after upload completes.
 *
 * Marks files as uploaded after successful S3 upload. The backend validates
 * the file, calculates size and row count, enforces storage limits, and
 * registers the DuckDB table for queries.
 *
 * **Status Values:**
 * - `uploaded`: File successfully uploaded to S3 (triggers validation)
 * - `disabled`: Exclude file from ingestion
 * - `archived`: Soft delete file
 *
 * **What Happens on 'uploaded' Status:**
 * 1. Verify file exists in S3
 * 2. Calculate actual file size
 * 3. Enforce tier storage limits
 * 4. Calculate or estimate row count
 * 5. Update table statistics
 * 6. Register DuckDB external table
 * 7. File ready for ingestion
 *
 * **Row Count Calculation:**
 * - **Parquet**: Exact count from file metadata
 * - **CSV**: Count rows (minus header)
 * - **JSON**: Count array elements
 * - **Fallback**: Estimate from file size if reading fails
 *
 * **Storage Limits:**
 * Enforced per subscription tier. Returns HTTP 413 if limit exceeded.
 * Check current usage before large uploads.
 *
 * **Important Notes:**
 * - Always call this after S3 upload completes
 * - Check response for actual row count
 * - Storage limit errors (413) mean tier upgrade needed
 * - DuckDB registration failures are non-fatal (retried later)
 * - Status updates are included - no credit consumption
 */
export const updateFileStatus = <ThrowOnError extends boolean = false>(options: Options<UpdateFileStatusData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<UpdateFileStatusResponses, UpdateFileStatusErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/files/{file_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Ingest Tables to Graph
 * Load all files from S3 into DuckDB staging tables and ingest into Kuzu graph database.
 *
 * Orchestrates the complete data pipeline from S3 staging files into the Kuzu graph database.
 * Processes all tables in a single bulk operation with comprehensive error handling and metrics.
 *
 * **Use Cases:**
 * - Initial graph population from uploaded data
 * - Incremental data updates with new files
 * - Complete database rebuild from source files
 * - Recovery from failed ingestion attempts
 *
 * **Workflow:**
 * 1. Upload data files via `POST /tables/{table_name}/files`
 * 2. Files are validated and marked as 'uploaded'
 * 3. Trigger ingestion: `POST /tables/ingest`
 * 4. DuckDB staging tables created from S3 patterns
 * 5. Data copied row-by-row from DuckDB to Kuzu
 * 6. Per-table results and metrics returned
 *
 * **Rebuild Feature:**
 * Setting `rebuild=true` regenerates the entire graph database from scratch:
 * - Deletes existing Kuzu database
 * - Recreates with fresh schema from active GraphSchema
 * - Ingests all data files
 * - Safe operation - S3 is source of truth
 * - Useful for schema changes or data corrections
 * - Graph marked as 'rebuilding' during process
 *
 * **Error Handling:**
 * - Per-table error isolation with `ignore_errors` flag
 * - Partial success support (some tables succeed, some fail)
 * - Detailed error reporting per table
 * - Graph status tracking throughout process
 * - Automatic failure recovery and cleanup
 *
 * **Performance:**
 * - Processes all tables in sequence
 * - Each table timed independently
 * - Total execution metrics provided
 * - Scales to thousands of files
 * - Optimized for large datasets
 *
 * **Concurrency Control:**
 * Only one ingestion can run per graph at a time. If another ingestion is in progress,
 * you'll receive a 409 Conflict error. The distributed lock automatically expires after
 * the configured TTL (default: 1 hour) to prevent deadlocks from failed ingestions.
 *
 * **Important Notes:**
 * - Only files with 'uploaded' status are processed
 * - Tables with no uploaded files are skipped
 * - Use `ignore_errors=false` for strict validation
 * - Monitor progress via per-table results
 * - Check graph metadata for rebuild status
 * - Wait for current ingestion to complete before starting another
 * - Table ingestion is included - no credit consumption
 */
export const ingestTables = <ThrowOnError extends boolean = false>(options: Options<IngestTablesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<IngestTablesResponses, IngestTablesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/ingest',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Query Staging Tables with SQL
 * Execute SQL queries on DuckDB staging tables for data inspection and validation.
 *
 * Query raw staging data directly with SQL before ingestion into the graph database.
 * Useful for data quality checks, validation, and exploratory analysis.
 *
 * **Security Best Practice - Use Parameterized Queries:**
 * ALWAYS use query parameters instead of string concatenation to prevent SQL injection:
 * -  SAFE: `SELECT * FROM Entity WHERE type = ? LIMIT ?` with `parameters: ["Company", 100]`
 * -  UNSAFE: `SELECT * FROM Entity WHERE type = 'Company' LIMIT 100` with user input concatenated into SQL string
 *
 * Query parameters provide automatic escaping and type safety. Use `?` placeholders with parameters array.
 *
 * **Use Cases:**
 * - Validate data quality before graph ingestion
 * - Inspect row-level data for debugging
 * - Run analytics on staging tables
 * - Check for duplicates, nulls, or data issues
 * - Preview data transformations
 *
 * **Workflow:**
 * 1. Upload data files via `POST /tables/{table_name}/files`
 * 2. Query staging tables to validate: `POST /tables/query`
 * 3. Fix any data issues by re-uploading
 * 4. Ingest validated data: `POST /tables/ingest`
 *
 * **Supported SQL:**
 * - Full DuckDB SQL syntax
 * - SELECT, JOIN, WHERE, GROUP BY, ORDER BY
 * - Aggregations, window functions, CTEs
 * - Multiple table joins across staging area
 *
 * **Common Operations:**
 * - Count rows: `SELECT COUNT(*) FROM Entity`
 * - Filter by type: `SELECT * FROM Entity WHERE entity_type = ? LIMIT ?` with `parameters: ["Company", 100]`
 * - Check for nulls: `SELECT * FROM Entity WHERE name IS NULL LIMIT 10`
 * - Find duplicates: `SELECT identifier, COUNT(*) as cnt FROM Entity GROUP BY identifier HAVING COUNT(*) > 1`
 * - Filter amounts: `SELECT * FROM Transaction WHERE amount > ? AND date >= ?` with `parameters: [1000, "2024-01-01"]`
 *
 * **Limits:**
 * - Query timeout: 30 seconds
 * - Result limit: 10,000 rows (use LIMIT clause)
 * - Read-only: No INSERT, UPDATE, DELETE
 * - User's tables only: Cannot query other users' data
 *
 * **Shared Repositories:**
 * Shared repositories (SEC, etc.) do not allow direct SQL queries.
 * Use the graph query endpoint instead: `POST /v1/graphs/{graph_id}/query`
 *
 * **Note:**
 * Staging table queries are included - no credit consumption
 */
export const queryTables = <ThrowOnError extends boolean = false>(options: Options<QueryTablesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<QueryTablesResponses, QueryTablesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/query',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get User Graphs and Repositories
 * List all graph databases and shared repositories accessible to the current user.
 *
 * Returns a unified list of both user-created graphs and shared repositories (like SEC data)
 * that the user has access to, including their role/access level and selection status.
 *
 * **Returned Information:**
 * - Graph/Repository ID and display name
 * - User's role/access level (admin/member for graphs, read/write/admin for repositories)
 * - Selection status (only user graphs can be selected)
 * - Creation timestamp
 * - Repository type indicator (isRepository: true for shared repositories)
 *
 * **User Graphs (isRepository: false):**
 * - Collaborative workspaces that can be shared with other users
 * - Roles: `admin` (full access, can invite users) or `member` (read/write access)
 * - Can be selected as active workspace
 * - Graphs you create or have been invited to
 *
 * **Shared Repositories (isRepository: true):**
 * - Read-only data repositories like SEC filings, industry benchmarks
 * - Access levels: `read`, `write` (for data contributions), `admin`
 * - Cannot be selected (each has separate subscription)
 * - Require separate subscriptions (personal, cannot be shared)
 *
 * **Selected Graph Concept:**
 * The "selected" graph is the user's currently active workspace (user graphs only).
 * Many API operations default to the selected graph if no graph_id is provided.
 * Users can change their selected graph via `POST /v1/graphs/{graph_id}/select`.
 *
 * **Use Cases:**
 * - Display unified graph/repository selector in UI
 * - Show all accessible data sources (both owned graphs and subscribed repositories)
 * - Identify currently active workspace
 * - Filter by type (user graphs vs repositories)
 *
 * **Empty Response:**
 * New users receive an empty list with `selectedGraphId: null`. Users should create
 * a graph or subscribe to a repository.
 *
 * **Note:**
 * Graph listing is included - no credit consumption required.
 */
export const getGraphs = <ThrowOnError extends boolean = false>(options?: Options<GetGraphsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetGraphsResponses, GetGraphsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs',
        ...options
    });
};

/**
 * Create New Graph Database
 * Create a new graph database with specified schema and optionally an initial entity.
 *
 * This endpoint starts an asynchronous graph creation operation and returns
 * connection details for monitoring progress via Server-Sent Events (SSE).
 *
 * **Graph Creation Options:**
 *
 * 1. **Entity Graph with Initial Entity** (`initial_entity` provided, `create_entity=True`):
 * - Creates graph structure with entity schema extensions
 * - Populates an initial entity node with provided data
 * - Useful when you want a pre-configured entity to start with
 * - Example: Creating a company graph with the company already populated
 *
 * 2. **Entity Graph without Initial Entity** (`initial_entity=None`, `create_entity=False`):
 * - Creates graph structure with entity schema extensions
 * - Graph starts empty, ready for data import
 * - Useful for bulk data imports or custom workflows
 * - Example: Creating a graph structure before importing from CSV/API
 *
 * 3. **Generic Graph** (no `initial_entity` provided):
 * - Creates empty graph with custom schema extensions
 * - General-purpose knowledge graph
 * - Example: Analytics graphs, custom data models
 *
 * **Required Fields:**
 * - `metadata.graph_name`: Unique name for the graph
 * - `instance_tier`: Resource tier (kuzu-standard, kuzu-large, kuzu-xlarge)
 *
 * **Optional Fields:**
 * - `metadata.description`: Human-readable description of the graph's purpose
 * - `metadata.schema_extensions`: List of schema extensions (roboledger, roboinvestor, etc.)
 * - `tags`: Organizational tags (max 10)
 * - `initial_entity`: Entity data (required for entity graphs with initial data)
 * - `create_entity`: Whether to populate initial entity (default: true when initial_entity provided)
 *
 * **Monitoring Progress:**
 * Use the returned `operation_id` to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.onmessage = (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Progress:', data.progress_percent + '%');
 * };
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Events Emitted:**
 * - `operation_started`: Graph creation begins
 * - `operation_progress`: Schema loading, database setup, etc.
 * - `operation_completed`: Graph ready with connection details
 * - `operation_error`: Creation failed with error details
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: SSE connection limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - Clients should implement exponential backoff on errors
 *
 * **Response includes:**
 * - `operation_id`: Unique identifier for monitoring
 * - `_links.stream`: SSE endpoint for real-time updates
 * - `_links.status`: Point-in-time status check endpoint
 */
export const createGraph = <ThrowOnError extends boolean = false>(options: Options<CreateGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateGraphResponses, CreateGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Available Schema Extensions
 * List all available schema extensions for graph creation.
 *
 * Schema extensions provide pre-built industry-specific data models that extend
 * the base graph schema with specialized nodes, relationships, and properties.
 *
 * **Available Extensions:**
 * - **RoboLedger**: Complete accounting system with XBRL reporting, general ledger, and financial statements
 * - **RoboInvestor**: Investment portfolio management and tracking
 * - **RoboSCM**: Supply chain management and logistics
 * - **RoboFO**: Front office operations and CRM
 * - **RoboHRM**: Human resources management
 * - **RoboEPM**: Enterprise performance management
 * - **RoboReport**: Business intelligence and reporting
 *
 * **Extension Information:**
 * Each extension includes:
 * - Display name and description
 * - Node and relationship counts
 * - Context-aware capabilities (e.g., SEC repositories get different features than entity graphs)
 *
 * **Use Cases:**
 * - Browse available extensions before creating a graph
 * - Understand extension capabilities and data models
 * - Plan graph schema based on business requirements
 * - Combine multiple extensions for comprehensive data modeling
 *
 * **Note:**
 * Extension listing is included - no credit consumption required.
 */
export const getAvailableExtensions = <ThrowOnError extends boolean = false>(options?: Options<GetAvailableExtensionsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAvailableExtensionsResponses, GetAvailableExtensionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/extensions',
        ...options
    });
};

/**
 * Get Available Graph Tiers
 * List all available graph database tier configurations.
 *
 * This endpoint provides comprehensive technical specifications for each available
 * graph database tier, including instance types, resource limits, and features.
 *
 * **Tier Information:**
 * Each tier includes:
 * - Technical specifications (instance type, memory, storage)
 * - Resource limits (subgraphs, credits, rate limits)
 * - Feature list with capabilities
 * - Availability status
 *
 * **Available Tiers:**
 * - **kuzu-standard**: Multi-tenant entry-level tier
 * - **kuzu-large**: Dedicated professional tier with subgraph support
 * - **kuzu-xlarge**: Enterprise tier with maximum resources
 * - **neo4j-community-large**: Neo4j Community Edition (optional, if enabled)
 * - **neo4j-enterprise-xlarge**: Neo4j Enterprise Edition (optional, if enabled)
 *
 * **Use Cases:**
 * - Display tier options in graph creation UI
 * - Show technical specifications for tier selection
 * - Validate tier availability before graph creation
 * - Display feature comparisons
 *
 * **Note:**
 * Tier listing is included - no credit consumption required.
 */
export const getAvailableGraphTiers = <ThrowOnError extends boolean = false>(options?: Options<GetAvailableGraphTiersData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAvailableGraphTiersResponses, GetAvailableGraphTiersErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/tiers',
        ...options
    });
};

/**
 * Select Graph
 * Select a specific graph as the active workspace for the user.
 *
 * The selected graph becomes the default context for operations in client applications
 * and can be used to maintain user workspace preferences across sessions.
 *
 * **Functionality:**
 * - Sets the specified graph as the user's currently selected graph
 * - Deselects any previously selected graph (only one can be selected at a time)
 * - Persists selection across sessions until changed
 * - Returns confirmation with the selected graph ID
 *
 * **Requirements:**
 * - User must have access to the graph (as admin or member)
 * - Graph must exist and not be deleted
 * - User can only select graphs they have permission to access
 *
 * **Use Cases:**
 * - Switch between multiple graphs in a multi-graph environment
 * - Set default workspace after creating a new graph
 * - Restore user's preferred workspace on login
 * - Support graph context switching in client applications
 *
 * **Client Integration:**
 * Many client operations can default to the selected graph, simplifying API calls
 * by eliminating the need to specify graph_id repeatedly. Check the selected
 * graph with `GET /v1/graphs` which returns `selectedGraphId`.
 *
 * **Note:**
 * Graph selection is included - no credit consumption required.
 */
export const selectGraph = <ThrowOnError extends boolean = false>(options: Options<SelectGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SelectGraphResponses, SelectGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/select',
        ...options
    });
};

/**
 * Get Service Offerings
 * Get comprehensive information about all subscription offerings.
 *
 * This endpoint provides complete information about both graph database subscriptions
 * and shared repository subscriptions. This is the primary endpoint for frontend
 * applications to display subscription options.
 *
 * Includes:
 * - Graph subscription tiers (standard, enterprise, premium)
 * - Shared repository subscriptions (SEC, industry, economic data)
 * - Operation costs and credit information
 * - Features and capabilities for each tier
 * - Enabled/disabled status for repositories
 *
 * All data comes from the config-based systems to ensure accuracy with backend behavior.
 *
 * No authentication required - this is public service information.
 */
export const getServiceOfferings = <ThrowOnError extends boolean = false>(options?: Options<GetServiceOfferingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetServiceOfferingsResponses, GetServiceOfferingsErrors, ThrowOnError>({
        url: '/v1/offering',
        ...options
    });
};

/**
 * Stream Operation Events
 * Stream real-time events for an operation using Server-Sent Events (SSE).
 *
 * This endpoint provides real-time monitoring for all non-immediate operations including:
 * - Graph creation and management
 * - Agent analysis processing
 * - Database backups and restores
 * - Data synchronization tasks
 *
 * **Event Types:**
 * - `operation_started`: Operation began execution
 * - `operation_progress`: Progress update with details
 * - `operation_completed`: Operation finished successfully
 * - `operation_error`: Operation failed with error details
 * - `operation_cancelled`: Operation was cancelled
 *
 * **Features:**
 * - **Event Replay**: Use `from_sequence` parameter to replay missed events
 * - **Automatic Reconnection**: Client can reconnect and resume from last seen event
 * - **Real-time Updates**: Live progress updates during execution
 * - **Timeout Handling**: 30-second keepalive messages prevent connection timeouts
 * - **Graceful Degradation**: Automatic fallback if Redis is unavailable
 *
 * **Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic cleanup of stale connections
 * - Circuit breaker protection for Redis failures
 *
 * **Client Usage:**
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/abc123/stream');
 * eventSource.onmessage = (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Progress:', data);
 * };
 * eventSource.onerror = (error) => {
 * // Handle connection errors or rate limits
 * console.error('SSE Error:', error);
 * };
 * ```
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Connection limit or rate limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - Clients should implement exponential backoff on errors
 *
 * **No credits are consumed for SSE connections.**
 */
export const streamOperationEvents = <ThrowOnError extends boolean = false>(options: Options<StreamOperationEventsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StreamOperationEventsResponses, StreamOperationEventsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}/stream',
        ...options
    });
};

/**
 * Get Operation Status
 * Get current status and metadata for an operation.
 *
 * Returns detailed information including:
 * - Current status (pending, running, completed, failed, cancelled)
 * - Creation and update timestamps
 * - Operation type and associated graph
 * - Result data (for completed operations)
 * - Error details (for failed operations)
 *
 * This endpoint provides a point-in-time status check, while the `/stream` endpoint
 * provides real-time updates. Use this for polling or initial status checks.
 *
 * **No credits are consumed for status checks.**
 */
export const getOperationStatus = <ThrowOnError extends boolean = false>(options: Options<GetOperationStatusData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOperationStatusResponses, GetOperationStatusErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}/status',
        ...options
    });
};

/**
 * Cancel Operation
 * Cancel a pending or running operation.
 *
 * Cancels the specified operation if it's still in progress. Once cancelled,
 * the operation cannot be resumed and will emit a cancellation event to any
 * active SSE connections.
 *
 * **Note**: Completed or already failed operations cannot be cancelled.
 *
 * **No credits are consumed for cancellation requests.**
 */
export const cancelOperation = <ThrowOnError extends boolean = false>(options: Options<CancelOperationData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<CancelOperationResponses, CancelOperationErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}',
        ...options
    });
};