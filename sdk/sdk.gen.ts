// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from './client';
import type { RegisterUserData, RegisterUserResponses, RegisterUserErrors, LoginUserData, LoginUserResponses, LoginUserErrors, LogoutUserData, LogoutUserResponses, GetCurrentAuthUserData, GetCurrentAuthUserResponses, GetCurrentAuthUserErrors, RefreshAuthSessionData, RefreshAuthSessionResponses, RefreshAuthSessionErrors, ResendVerificationEmailData, ResendVerificationEmailResponses, ResendVerificationEmailErrors, VerifyEmailData, VerifyEmailResponses, VerifyEmailErrors, GetPasswordPolicyData, GetPasswordPolicyResponses, CheckPasswordStrengthData, CheckPasswordStrengthResponses, CheckPasswordStrengthErrors, ForgotPasswordData, ForgotPasswordResponses, ForgotPasswordErrors, ValidateResetTokenData, ValidateResetTokenResponses, ValidateResetTokenErrors, ResetPasswordData, ResetPasswordResponses, ResetPasswordErrors, GenerateSsoTokenData, GenerateSsoTokenResponses, GenerateSsoTokenErrors, SsoTokenExchangeData, SsoTokenExchangeResponses, SsoTokenExchangeErrors, CompleteSsoAuthData, CompleteSsoAuthResponses, CompleteSsoAuthErrors, GetCaptchaConfigData, GetCaptchaConfigResponses, GetServiceStatusData, GetServiceStatusResponses, GetCurrentUserData, GetCurrentUserResponses, UpdateUserData, UpdateUserResponses, UpdateUserErrors, GetAllCreditSummariesData, GetAllCreditSummariesResponses, GetAllCreditSummariesErrors, UpdateUserPasswordData, UpdateUserPasswordResponses, UpdateUserPasswordErrors, ListUserApiKeysData, ListUserApiKeysResponses, CreateUserApiKeyData, CreateUserApiKeyResponses, CreateUserApiKeyErrors, RevokeUserApiKeyData, RevokeUserApiKeyResponses, RevokeUserApiKeyErrors, UpdateUserApiKeyData, UpdateUserApiKeyResponses, UpdateUserApiKeyErrors, GetUserLimitsData, GetUserLimitsResponses, GetUserLimitsErrors, GetUserUsageData, GetUserUsageResponses, GetAllSharedRepositoryLimitsData, GetAllSharedRepositoryLimitsResponses, GetSharedRepositoryLimitsData, GetSharedRepositoryLimitsResponses, GetSharedRepositoryLimitsErrors, GetUserUsageOverviewData, GetUserUsageOverviewResponses, GetDetailedUserAnalyticsData, GetDetailedUserAnalyticsResponses, GetDetailedUserAnalyticsErrors, GetUserSharedSubscriptionsData, GetUserSharedSubscriptionsResponses, GetUserSharedSubscriptionsErrors, SubscribeToSharedRepositoryData, SubscribeToSharedRepositoryResponses, SubscribeToSharedRepositoryErrors, UpgradeSharedRepositorySubscriptionData, UpgradeSharedRepositorySubscriptionResponses, UpgradeSharedRepositorySubscriptionErrors, CancelSharedRepositorySubscriptionData, CancelSharedRepositorySubscriptionResponses, CancelSharedRepositorySubscriptionErrors, GetSharedRepositoryCreditsData, GetSharedRepositoryCreditsResponses, GetSharedRepositoryCreditsErrors, GetRepositoryCreditsData, GetRepositoryCreditsResponses, GetRepositoryCreditsErrors, ListConnectionsData, ListConnectionsResponses, ListConnectionsErrors, CreateConnectionData, CreateConnectionResponses, CreateConnectionErrors, GetConnectionOptionsData, GetConnectionOptionsResponses, GetConnectionOptionsErrors, ExchangeLinkTokenData, ExchangeLinkTokenResponses, ExchangeLinkTokenErrors, CreateLinkTokenData, CreateLinkTokenResponses, CreateLinkTokenErrors, InitOAuthData, InitOAuthResponses, InitOAuthErrors, OauthCallbackData, OauthCallbackResponses, OauthCallbackErrors, DeleteConnectionData, DeleteConnectionResponses, DeleteConnectionErrors, GetConnectionData, GetConnectionResponses, GetConnectionErrors, SyncConnectionData, SyncConnectionResponses, SyncConnectionErrors, AutoSelectAgentData, AutoSelectAgentResponses, AutoSelectAgentErrors, ExecuteSpecificAgentData, ExecuteSpecificAgentResponses, ExecuteSpecificAgentErrors, BatchProcessQueriesData, BatchProcessQueriesResponses, BatchProcessQueriesErrors, ListAgentsData, ListAgentsResponses, ListAgentsErrors, GetAgentMetadataData, GetAgentMetadataResponses, GetAgentMetadataErrors, RecommendAgentData, RecommendAgentResponses, RecommendAgentErrors, ListMcpToolsData, ListMcpToolsResponses, ListMcpToolsErrors, CallMcpToolData, CallMcpToolResponses, CallMcpToolErrors, ListBackupsData, ListBackupsResponses, ListBackupsErrors, CreateBackupData, CreateBackupResponses, CreateBackupErrors, GetBackupDownloadUrlData, GetBackupDownloadUrlResponses, GetBackupDownloadUrlErrors, RestoreBackupData, RestoreBackupResponses, RestoreBackupErrors, GetBackupStatsData, GetBackupStatsResponses, GetBackupStatsErrors, GetGraphMetricsData, GetGraphMetricsResponses, GetGraphMetricsErrors, GetGraphUsageStatsData, GetGraphUsageStatsResponses, GetGraphUsageStatsErrors, ExecuteCypherQueryData, ExecuteCypherQueryResponses, ExecuteCypherQueryErrors, GetGraphSchemaData, GetGraphSchemaResponses, GetGraphSchemaErrors, ExportGraphSchemaData, ExportGraphSchemaResponses, ExportGraphSchemaErrors, ValidateSchemaData, ValidateSchemaResponses, ValidateSchemaErrors, GetCurrentGraphBillData, GetCurrentGraphBillResponses, GetCurrentGraphBillErrors, GetGraphUsageDetailsData, GetGraphUsageDetailsResponses, GetGraphUsageDetailsErrors, GetGraphBillingHistoryData, GetGraphBillingHistoryResponses, GetGraphBillingHistoryErrors, GetGraphMonthlyBillData, GetGraphMonthlyBillResponses, GetGraphMonthlyBillErrors, GetCreditSummaryData, GetCreditSummaryResponses, GetCreditSummaryErrors, ListCreditTransactionsData, ListCreditTransactionsResponses, ListCreditTransactionsErrors, CheckCreditBalanceData, CheckCreditBalanceResponses, CheckCreditBalanceErrors, GetStorageUsageData, GetStorageUsageResponses, GetStorageUsageErrors, CheckStorageLimitsData, CheckStorageLimitsResponses, CheckStorageLimitsErrors, GetDatabaseHealthData, GetDatabaseHealthResponses, GetDatabaseHealthErrors, GetDatabaseInfoData, GetDatabaseInfoResponses, GetDatabaseInfoErrors, GetGraphLimitsData, GetGraphLimitsResponses, GetGraphLimitsErrors, ListSubgraphsData, ListSubgraphsResponses, ListSubgraphsErrors, CreateSubgraphData, CreateSubgraphResponses, CreateSubgraphErrors, DeleteSubgraphData, DeleteSubgraphResponses, DeleteSubgraphErrors, GetSubgraphInfoData, GetSubgraphInfoResponses, GetSubgraphInfoErrors, GetSubgraphQuotaData, GetSubgraphQuotaResponses, GetSubgraphQuotaErrors, ListTablesData, ListTablesResponses, ListTablesErrors, ListTableFilesData, ListTableFilesResponses, ListTableFilesErrors, GetUploadUrlData, GetUploadUrlResponses, GetUploadUrlErrors, DeleteFileData, DeleteFileResponses, DeleteFileErrors, GetFileInfoData, GetFileInfoResponses, GetFileInfoErrors, UpdateFileStatusData, UpdateFileStatusResponses, UpdateFileStatusErrors, IngestTablesData, IngestTablesResponses, IngestTablesErrors, QueryTablesData, QueryTablesResponses, QueryTablesErrors, GetGraphsData, GetGraphsResponses, CreateGraphData, CreateGraphResponses, CreateGraphErrors, GetAvailableExtensionsData, GetAvailableExtensionsResponses, SelectGraphData, SelectGraphResponses, SelectGraphErrors, GetServiceOfferingsData, GetServiceOfferingsResponses, GetServiceOfferingsErrors, StreamOperationEventsData, StreamOperationEventsResponses, StreamOperationEventsErrors, GetOperationStatusData, GetOperationStatusResponses, GetOperationStatusErrors, CancelOperationData, CancelOperationResponses, CancelOperationErrors } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Register New User
 * Register a new user account with email and password. Security controls vary by environment: CAPTCHA and email verification are disabled in development for API testing, but required in production.
 */
export const registerUser = <ThrowOnError extends boolean = false>(options: Options<RegisterUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RegisterUserResponses, RegisterUserErrors, ThrowOnError>({
        url: '/v1/auth/register',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * User Login
 * Authenticate user with email and password.
 */
export const loginUser = <ThrowOnError extends boolean = false>(options: Options<LoginUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<LoginUserResponses, LoginUserErrors, ThrowOnError>({
        url: '/v1/auth/login',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * User Logout
 * Logout user and invalidate session.
 */
export const logoutUser = <ThrowOnError extends boolean = false>(options?: Options<LogoutUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<LogoutUserResponses, unknown, ThrowOnError>({
        url: '/v1/auth/logout',
        ...options
    });
};

/**
 * Get Current User
 * Get the currently authenticated user.
 */
export const getCurrentAuthUser = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentAuthUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCurrentAuthUserResponses, GetCurrentAuthUserErrors, ThrowOnError>({
        url: '/v1/auth/me',
        ...options
    });
};

/**
 * Refresh Session
 * Refresh authentication session with a new JWT token.
 */
export const refreshAuthSession = <ThrowOnError extends boolean = false>(options?: Options<RefreshAuthSessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RefreshAuthSessionResponses, RefreshAuthSessionErrors, ThrowOnError>({
        url: '/v1/auth/refresh',
        ...options
    });
};

/**
 * Resend Email Verification
 * Resend verification email to the authenticated user. Rate limited to 3 per hour.
 */
export const resendVerificationEmail = <ThrowOnError extends boolean = false>(options?: Options<ResendVerificationEmailData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<ResendVerificationEmailResponses, ResendVerificationEmailErrors, ThrowOnError>({
        url: '/v1/auth/email/resend',
        ...options
    });
};

/**
 * Verify Email
 * Verify email address with token from email link. Returns JWT for auto-login.
 */
export const verifyEmail = <ThrowOnError extends boolean = false>(options: Options<VerifyEmailData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<VerifyEmailResponses, VerifyEmailErrors, ThrowOnError>({
        url: '/v1/auth/email/verify',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Password Policy
 * Get current password policy requirements for frontend validation
 */
export const getPasswordPolicy = <ThrowOnError extends boolean = false>(options?: Options<GetPasswordPolicyData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetPasswordPolicyResponses, unknown, ThrowOnError>({
        url: '/v1/auth/password/policy',
        ...options
    });
};

/**
 * Check Password Strength
 * Check password strength and get validation feedback
 */
export const checkPasswordStrength = <ThrowOnError extends boolean = false>(options: Options<CheckPasswordStrengthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CheckPasswordStrengthResponses, CheckPasswordStrengthErrors, ThrowOnError>({
        url: '/v1/auth/password/check',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Forgot Password
 * Request password reset email. Always returns success to prevent email enumeration.
 */
export const forgotPassword = <ThrowOnError extends boolean = false>(options: Options<ForgotPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ForgotPasswordResponses, ForgotPasswordErrors, ThrowOnError>({
        url: '/v1/auth/password/forgot',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Validate Reset Token
 * Check if a password reset token is valid without consuming it.
 */
export const validateResetToken = <ThrowOnError extends boolean = false>(options: Options<ValidateResetTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ValidateResetTokenResponses, ValidateResetTokenErrors, ThrowOnError>({
        url: '/v1/auth/password/reset/validate',
        ...options
    });
};

/**
 * Reset Password
 * Reset password with token from email. Returns JWT for auto-login.
 */
export const resetPassword = <ThrowOnError extends boolean = false>(options: Options<ResetPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ResetPasswordResponses, ResetPasswordErrors, ThrowOnError>({
        url: '/v1/auth/password/reset',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Generate SSO Token
 * Generate a temporary SSO token for cross-app authentication.
 */
export const generateSsoToken = <ThrowOnError extends boolean = false>(options?: Options<GenerateSsoTokenData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<GenerateSsoTokenResponses, GenerateSsoTokenErrors, ThrowOnError>({
        url: '/v1/auth/sso-token',
        ...options
    });
};

/**
 * SSO Token Exchange
 * Exchange SSO token for secure session handoff to target application.
 */
export const ssoTokenExchange = <ThrowOnError extends boolean = false>(options: Options<SsoTokenExchangeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SsoTokenExchangeResponses, SsoTokenExchangeErrors, ThrowOnError>({
        url: '/v1/auth/sso-exchange',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Complete SSO Authentication
 * Complete SSO authentication using session ID from secure handoff.
 */
export const completeSsoAuth = <ThrowOnError extends boolean = false>(options: Options<CompleteSsoAuthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CompleteSsoAuthResponses, CompleteSsoAuthErrors, ThrowOnError>({
        url: '/v1/auth/sso-complete',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get CAPTCHA Configuration
 * Get CAPTCHA configuration including site key and whether CAPTCHA is required.
 */
export const getCaptchaConfig = <ThrowOnError extends boolean = false>(options?: Options<GetCaptchaConfigData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCaptchaConfigResponses, unknown, ThrowOnError>({
        url: '/v1/auth/captcha/config',
        ...options
    });
};

/**
 * Health Check
 * Service health check endpoint for monitoring and load balancers
 */
export const getServiceStatus = <ThrowOnError extends boolean = false>(options?: Options<GetServiceStatusData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetServiceStatusResponses, unknown, ThrowOnError>({
        url: '/v1/status',
        ...options
    });
};

/**
 * Get Current User
 * Returns information about the currently authenticated user.
 */
export const getCurrentUser = <ThrowOnError extends boolean = false>(options?: Options<GetCurrentUserData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetCurrentUserResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user',
        ...options
    });
};

/**
 * Update User Profile
 * Update the current user's profile information.
 */
export const updateUser = <ThrowOnError extends boolean = false>(options: Options<UpdateUserData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserResponses, UpdateUserErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get All Credit Summaries
 * Get credit summaries for all graphs owned by the user.
 *
 * This endpoint provides a consolidated view of credit usage across
 * all graphs where the user has access, helping to monitor overall
 * credit consumption and plan usage.
 *
 * No credits are consumed for viewing summaries.
 */
export const getAllCreditSummaries = <ThrowOnError extends boolean = false>(options?: Options<GetAllCreditSummariesData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAllCreditSummariesResponses, GetAllCreditSummariesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/credits',
        ...options
    });
};

/**
 * Update Password
 * Update the current user's password.
 */
export const updateUserPassword = <ThrowOnError extends boolean = false>(options: Options<UpdateUserPasswordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserPasswordResponses, UpdateUserPasswordErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/password',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List API Keys
 * Get all API keys for the current user.
 */
export const listUserApiKeys = <ThrowOnError extends boolean = false>(options?: Options<ListUserApiKeysData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ListUserApiKeysResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys',
        ...options
    });
};

/**
 * Create API Key
 * Create a new API key for the current user.
 */
export const createUserApiKey = <ThrowOnError extends boolean = false>(options: Options<CreateUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateUserApiKeyResponses, CreateUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Revoke API Key
 * Revoke (deactivate) an API key.
 */
export const revokeUserApiKey = <ThrowOnError extends boolean = false>(options: Options<RevokeUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<RevokeUserApiKeyResponses, RevokeUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys/{api_key_id}',
        ...options
    });
};

/**
 * Update API Key
 * Update an API key's name or description.
 */
export const updateUserApiKey = <ThrowOnError extends boolean = false>(options: Options<UpdateUserApiKeyData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpdateUserApiKeyResponses, UpdateUserApiKeyErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/api-keys/{api_key_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get user limits
 * Retrieve current limits and restrictions for the authenticated user
 */
export const getUserLimits = <ThrowOnError extends boolean = false>(options?: Options<GetUserLimitsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserLimitsResponses, GetUserLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits',
        ...options
    });
};

/**
 * Get user usage statistics
 * Retrieve current usage statistics and remaining limits for the authenticated user
 */
export const getUserUsage = <ThrowOnError extends boolean = false>(options?: Options<GetUserUsageData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserUsageResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits/usage',
        ...options
    });
};

/**
 * Get all shared repository limits
 * Get rate limit status for all shared repositories the user has access to.
 */
export const getAllSharedRepositoryLimits = <ThrowOnError extends boolean = false>(options?: Options<GetAllSharedRepositoryLimitsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAllSharedRepositoryLimitsResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits/shared-repositories/summary',
        ...options
    });
};

/**
 * Get shared repository rate limit status
 * Get current rate limit status and usage for a shared repository.
 *
 * Returns:
 * - Current usage across different time windows
 * - Rate limits based on subscription tier
 * - Remaining quota
 * - Reset times
 *
 * Note: All queries are included - this only shows rate limit status.
 */
export const getSharedRepositoryLimits = <ThrowOnError extends boolean = false>(options: Options<GetSharedRepositoryLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSharedRepositoryLimitsResponses, GetSharedRepositoryLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/limits/shared-repositories/{repository}',
        ...options
    });
};

/**
 * Get User Usage Overview
 * Get a high-level overview of usage statistics for the current user.
 */
export const getUserUsageOverview = <ThrowOnError extends boolean = false>(options?: Options<GetUserUsageOverviewData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserUsageOverviewResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/analytics/overview',
        ...options
    });
};

/**
 * Get Detailed User Analytics
 * Get comprehensive analytics for the current user including API usage and recent activity.
 */
export const getDetailedUserAnalytics = <ThrowOnError extends boolean = false>(options?: Options<GetDetailedUserAnalyticsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetDetailedUserAnalyticsResponses, GetDetailedUserAnalyticsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/analytics/detailed',
        ...options
    });
};

/**
 * Get User Subscriptions
 * Retrieve user's current shared repository subscriptions with detailed information
 */
export const getUserSharedSubscriptions = <ThrowOnError extends boolean = false>(options?: Options<GetUserSharedSubscriptionsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetUserSharedSubscriptionsResponses, GetUserSharedSubscriptionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories',
        ...options
    });
};

/**
 * Subscribe to Shared Repository
 * Create a new subscription to a shared repository add-on with specified tier
 */
export const subscribeToSharedRepository = <ThrowOnError extends boolean = false>(options: Options<SubscribeToSharedRepositoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SubscribeToSharedRepositoryResponses, SubscribeToSharedRepositoryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/subscribe',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Upgrade Subscription Tier
 * Upgrade a subscription to a higher tier with immediate credit adjustment
 */
export const upgradeSharedRepositorySubscription = <ThrowOnError extends boolean = false>(options: Options<UpgradeSharedRepositorySubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<UpgradeSharedRepositorySubscriptionResponses, UpgradeSharedRepositorySubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/{subscription_id}/upgrade',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Cancel Subscription
 * Cancel a shared repository subscription and disable associated credit pool
 */
export const cancelSharedRepositorySubscription = <ThrowOnError extends boolean = false>(options: Options<CancelSharedRepositorySubscriptionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<CancelSharedRepositorySubscriptionResponses, CancelSharedRepositorySubscriptionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/{subscription_id}',
        ...options
    });
};

/**
 * Get Credit Balances
 * Retrieve credit balances for all shared repository subscriptions
 */
export const getSharedRepositoryCredits = <ThrowOnError extends boolean = false>(options?: Options<GetSharedRepositoryCreditsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetSharedRepositoryCreditsResponses, GetSharedRepositoryCreditsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/credits',
        ...options
    });
};

/**
 * Get Repository Credits
 * Get credit balance for a specific shared repository
 */
export const getRepositoryCredits = <ThrowOnError extends boolean = false>(options: Options<GetRepositoryCreditsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetRepositoryCreditsResponses, GetRepositoryCreditsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/user/subscriptions/shared-repositories/credits/{repository}',
        ...options
    });
};

/**
 * List Connections
 * List all data connections in the graph.
 *
 * Returns active and inactive connections with their current status.
 * Connections can be filtered by:
 * - **Entity**: Show connections for a specific entity
 * - **Provider**: Filter by connection type (sec, quickbooks, plaid)
 *
 * Each connection shows:
 * - Current sync status and health
 * - Last successful sync timestamp
 * - Configuration metadata
 * - Error messages if any
 *
 * No credits are consumed for listing connections.
 */
export const listConnections = <ThrowOnError extends boolean = false>(options: Options<ListConnectionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListConnectionsResponses, ListConnectionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections',
        ...options
    });
};

/**
 * Create Connection
 * Create a new data connection for external system integration.
 *
 * This endpoint initiates connections to external data sources:
 *
 * **SEC Connections**:
 * - Provide entity CIK for automatic filing retrieval
 * - No authentication needed
 * - Begins immediate data sync
 *
 * **QuickBooks Connections**:
 * - Returns OAuth URL for authorization
 * - Requires admin permissions in QuickBooks
 * - Complete with OAuth callback
 *
 * **Plaid Connections**:
 * - Returns Plaid Link token
 * - User completes bank authentication
 * - Exchange public token for access
 *
 * Note:
 * This operation is included - no credit consumption required.
 */
export const createConnection = <ThrowOnError extends boolean = false>(options: Options<CreateConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateConnectionResponses, CreateConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List Connection Options
 * Get metadata about all available data connection providers.
 *
 * This endpoint returns comprehensive information about each supported provider:
 *
 * **SEC EDGAR**: Public entity financial filings
 * - No authentication required (public data)
 * - 10-K, 10-Q, 8-K reports with XBRL data
 * - Historical and real-time filing access
 *
 * **QuickBooks Online**: Full accounting system integration
 * - OAuth 2.0 authentication
 * - Chart of accounts, transactions, trial balance
 * - Real-time sync capabilities
 *
 * **Plaid**: Bank account connections
 * - Secure bank authentication via Plaid Link
 * - Transaction history and balances
 * - Multi-account support
 *
 * No credits are consumed for viewing connection options.
 */
export const getConnectionOptions = <ThrowOnError extends boolean = false>(options: Options<GetConnectionOptionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetConnectionOptionsResponses, GetConnectionOptionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/options',
        ...options
    });
};

/**
 * Exchange Link Token
 * Exchange a public token for permanent access credentials.
 *
 * This completes the embedded authentication flow after user authorization.
 *
 * The exchange process:
 * 1. Validates the temporary public token
 * 2. Exchanges it for permanent access credentials
 * 3. Updates the connection with account information
 * 4. Optionally triggers initial data sync
 *
 * Supported providers:
 * - **Plaid**: Exchanges Plaid Link public token for access token
 *
 * Security:
 * - Public tokens expire after 30 minutes
 * - Each token can only be exchanged once
 * - Full audit trail is maintained
 *
 * No credits are consumed for token exchange.
 */
export const exchangeLinkToken = <ThrowOnError extends boolean = false>(options: Options<ExchangeLinkTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExchangeLinkTokenResponses, ExchangeLinkTokenErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/link/exchange',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Create Link Token
 * Create a link token for embedded authentication providers.
 *
 * This endpoint generates a temporary token used to initialize embedded authentication UI.
 *
 * Currently supported providers:
 * - **Plaid**: Bank account connections with real-time transaction access
 *
 * The link token:
 * - Expires after 4 hours
 * - Is single-use only
 * - Must be used with the matching frontend SDK
 * - Includes user and entity context
 *
 * No credits are consumed for creating link tokens.
 */
export const createLinkToken = <ThrowOnError extends boolean = false>(options: Options<CreateLinkTokenData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateLinkTokenResponses, CreateLinkTokenErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/link/token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Init Oauth
 * Initialize OAuth flow for a connection.
 *
 * This generates an authorization URL that the frontend should redirect the user to.
 * Currently supports: QuickBooks
 */
export const initOAuth = <ThrowOnError extends boolean = false>(options: Options<InitOAuthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<InitOAuthResponses, InitOAuthErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/oauth/init',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * OAuth Callback
 * Handle OAuth callback from provider after user authorization.
 *
 * This endpoint completes the OAuth flow:
 * 1. Validates the OAuth state parameter
 * 2. Exchanges authorization code for access tokens
 * 3. Stores tokens securely
 * 4. Updates connection status
 * 5. Optionally triggers initial sync
 *
 * Supported providers:
 * - **QuickBooks**: Accounting data integration
 *
 * Security measures:
 * - State validation prevents session hijacking
 * - User context is verified
 * - Tokens are encrypted before storage
 * - Full audit trail is maintained
 *
 * No credits are consumed for OAuth callbacks.
 */
export const oauthCallback = <ThrowOnError extends boolean = false>(options: Options<OauthCallbackData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<OauthCallbackResponses, OauthCallbackErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/oauth/callback/{provider}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Connection
 * Delete a data connection and clean up related resources.
 *
 * This operation:
 * - Removes the connection configuration
 * - Preserves any imported data in the graph
 * - Performs provider-specific cleanup
 * - Revokes stored credentials
 *
 * Note:
 * This operation is included - no credit consumption required.
 *
 * Only users with admin role can delete connections.
 */
export const deleteConnection = <ThrowOnError extends boolean = false>(options: Options<DeleteConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteConnectionResponses, DeleteConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/{connection_id}',
        ...options
    });
};

/**
 * Get Connection
 * Get detailed information about a specific connection.
 *
 * Returns comprehensive connection details including:
 * - Current status and health indicators
 * - Authentication state
 * - Sync history and statistics
 * - Error details if any
 * - Provider-specific metadata
 *
 * No credits are consumed for viewing connection details.
 */
export const getConnection = <ThrowOnError extends boolean = false>(options: Options<GetConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetConnectionResponses, GetConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/{connection_id}',
        ...options
    });
};

/**
 * Sync Connection
 * Trigger a data synchronization for the connection.
 *
 * Initiates data sync based on provider type:
 *
 * **SEC Sync**:
 * - Downloads latest filings from EDGAR
 * - Parses XBRL data and updates graph
 * - Typically completes in 5-10 minutes
 *
 * **QuickBooks Sync**:
 * - Fetches latest transactions and balances
 * - Updates chart of accounts
 * - Generates fresh trial balance
 * - Duration depends on data volume
 *
 * **Plaid Sync**:
 * - Retrieves recent bank transactions
 * - Updates account balances
 * - Categorizes new transactions
 *
 * Note:
 * This operation is included - no credit consumption required.
 *
 * Returns a task ID for monitoring sync progress.
 */
export const syncConnection = <ThrowOnError extends boolean = false>(options: Options<SyncConnectionData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SyncConnectionResponses, SyncConnectionErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/connections/{connection_id}/sync',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Auto-select agent for query
 * Automatically select the best agent for your query.
 *
 * The orchestrator will:
 * 1. Enrich context with RAG if enabled
 * 2. Evaluate all available agents
 * 3. Select the best match based on confidence scores
 * 4. Execute the query with the selected agent
 *
 * Use this endpoint when you want the system to intelligently route your query.
 */
export const autoSelectAgent = <ThrowOnError extends boolean = false>(options: Options<AutoSelectAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<AutoSelectAgentResponses, AutoSelectAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Execute specific agent
 * Execute a specific agent type directly.
 *
 * Available agents:
 * - **financial**: Financial analysis, SEC filings, accounting data
 * - **research**: Deep research and comprehensive analysis
 * - **rag**: Fast retrieval without AI (no credits required)
 *
 * Use this endpoint when you know which agent you want to use.
 */
export const executeSpecificAgent = <ThrowOnError extends boolean = false>(options: Options<ExecuteSpecificAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecuteSpecificAgentResponses, ExecuteSpecificAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/{agent_type}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Batch process multiple queries
 * Process multiple queries either sequentially or in parallel.
 *
 * **Features:**
 * - Process up to 10 queries in a single request
 * - Sequential or parallel execution modes
 * - Automatic error handling per query
 * - Credit checking before execution
 *
 * **Use Cases:**
 * - Bulk analysis of multiple entities
 * - Comparative analysis across queries
 * - Automated report generation
 *
 * Returns individual results for each query with execution metrics.
 */
export const batchProcessQueries = <ThrowOnError extends boolean = false>(options: Options<BatchProcessQueriesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<BatchProcessQueriesResponses, BatchProcessQueriesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/batch',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List available agents
 * Get a comprehensive list of all available agents with their metadata.
 *
 * **Returns:**
 * - Agent types and names
 * - Capabilities and supported modes
 * - Version information
 * - Credit requirements
 *
 * Use the optional `capability` filter to find agents with specific capabilities.
 */
export const listAgents = <ThrowOnError extends boolean = false>(options: Options<ListAgentsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListAgentsResponses, ListAgentsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/list',
        ...options
    });
};

/**
 * Get agent metadata
 * Get comprehensive metadata for a specific agent type.
 *
 * **Returns:**
 * - Agent name and description
 * - Version information
 * - Supported capabilities and modes
 * - Credit requirements
 * - Author and tags
 * - Configuration options
 *
 * Use this to understand agent capabilities before execution.
 */
export const getAgentMetadata = <ThrowOnError extends boolean = false>(options: Options<GetAgentMetadataData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetAgentMetadataResponses, GetAgentMetadataErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/{agent_type}/metadata',
        ...options
    });
};

/**
 * Get agent recommendations
 * Get intelligent agent recommendations for a specific query.
 *
 * **How it works:**
 * 1. Analyzes query content and structure
 * 2. Evaluates agent capabilities
 * 3. Calculates confidence scores
 * 4. Returns ranked recommendations
 *
 * **Use this when:**
 * - Unsure which agent to use
 * - Need to understand agent suitability
 * - Want confidence scores for decision making
 *
 * Returns top agents ranked by confidence with explanations.
 */
export const recommendAgent = <ThrowOnError extends boolean = false>(options: Options<RecommendAgentData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RecommendAgentResponses, RecommendAgentErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/agent/recommend',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List MCP Tools
 * Get available Model Context Protocol tools for graph analysis.
 *
 * This endpoint returns a comprehensive list of MCP tools optimized for AI agents:
 * - Tool schemas with detailed parameter documentation
 * - Context-aware descriptions based on graph type
 * - Capability indicators for streaming and progress
 *
 * The tool list is customized based on:
 * - Graph type (shared repository vs user graph)
 * - User permissions and subscription tier
 * - Backend capabilities (Kuzu, Neo4j, etc.)
 *
 * Credit consumption:
 * - Listing tools is included to encourage exploration
 * - Tool execution costs vary by operation complexity
 */
export const listMcpTools = <ThrowOnError extends boolean = false>(options: Options<ListMcpToolsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListMcpToolsResponses, ListMcpToolsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/mcp/tools',
        ...options
    });
};

/**
 * Execute MCP Tool
 * Execute an MCP tool with intelligent response optimization.
 *
 * This endpoint automatically selects the best execution strategy based on:
 * - Tool type and estimated complexity
 * - Client capabilities (AI agent detection)
 * - System load and queue status
 * - Graph type (shared repository vs user graph)
 *
 * **Response Formats:**
 * - **JSON**: Direct response for small/fast operations
 * - **SSE**: Server-Sent Events for progress monitoring
 * - **NDJSON**: Newline-delimited JSON for streaming
 * - **Queued**: Asynchronous execution with status monitoring
 *
 * **SSE Streaming Support:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation to direct response if SSE unavailable
 * - Progress events for long-running operations
 *
 * **AI Agent Optimization:**
 * The Node.js MCP client transparently handles all response formats,
 * presenting a unified interface to AI agents. Streaming responses are
 * automatically aggregated for seamless consumption.
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Connection limit or rate limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - `408 Request Timeout`: Tool execution exceeded timeout
 * - Clients should implement exponential backoff on errors
 *
 * **Note:**
 * MCP tool calls are included and do not consume credits.
 */
export const callMcpTool = <ThrowOnError extends boolean = false>(options: Options<CallMcpToolData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CallMcpToolResponses, CallMcpToolErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/mcp/call-tool',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * List graph database backups
 * List all backups for the specified graph database
 */
export const listBackups = <ThrowOnError extends boolean = false>(options: Options<ListBackupsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListBackupsResponses, ListBackupsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups',
        ...options
    });
};

/**
 * Create Backup
 * Create a backup of the graph database.
 *
 * Creates a complete backup of the graph database (.kuzu file) with:
 * - **Format**: Full database backup only (complete .kuzu file)
 * - **Compression**: Always enabled for optimal storage
 * - **Encryption**: Optional AES-256 encryption for security
 * - **Retention**: Configurable retention period (1-2555 days)
 *
 * **Backup Features:**
 * - **Complete Backup**: Full database file backup
 * - **Consistency**: Point-in-time consistent snapshot
 * - **Download Support**: Unencrypted backups can be downloaded
 * - **Restore Support**: Future support for encrypted backup restoration
 *
 * **Progress Monitoring:**
 * Use the returned operation_id to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.addEventListener('operation_progress', (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Backup progress:', data.progress_percent + '%');
 * });
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Important Notes:**
 * - Only full_dump format is supported (no CSV/JSON exports)
 * - Compression is always enabled
 * - Encrypted backups cannot be downloaded (security measure)
 * - All backups are stored securely in cloud storage
 *
 * **Credit Consumption:**
 * - Base cost: 25.0 credits
 * - Large databases (>10GB): 50.0 credits
 * - Multiplied by graph tier
 *
 * Returns operation details for SSE monitoring.
 */
export const createBackup = <ThrowOnError extends boolean = false>(options: Options<CreateBackupData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateBackupResponses, CreateBackupErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get temporary download URL for backup
 * Generate a temporary download URL for a backup (unencrypted, compressed .kuzu files only)
 */
export const getBackupDownloadUrl = <ThrowOnError extends boolean = false>(options: Options<GetBackupDownloadUrlData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetBackupDownloadUrlResponses, GetBackupDownloadUrlErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups/{backup_id}/download',
        ...options
    });
};

/**
 * Restore Encrypted Backup
 * Restore a graph database from an encrypted backup.
 *
 * Restores a complete graph database from an encrypted backup:
 * - **Format**: Only full_dump backups can be restored
 * - **Encryption**: Only encrypted backups can be restored (security requirement)
 * - **System Backup**: Creates automatic backup of existing database before restore
 * - **Verification**: Optionally verifies database integrity after restore
 *
 * **Restore Features:**
 * - **Atomic Operation**: Complete replacement of database
 * - **Rollback Protection**: System backup created before restore
 * - **Data Integrity**: Verification ensures successful restore
 * - **Security**: Only encrypted backups to prevent data tampering
 *
 * **Progress Monitoring:**
 * Use the returned operation_id to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.addEventListener('operation_progress', (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Restore progress:', data.message);
 * });
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Important Notes:**
 * - Only encrypted backups can be restored (security measure)
 * - Existing database is backed up to S3 before restore
 * - Restore is a destructive operation - existing data is replaced
 * - System backups are stored separately for recovery
 *
 * **Credit Consumption:**
 * - Base cost: 100.0 credits
 * - Large databases (>10GB): 200.0 credits
 * - Multiplied by graph tier
 *
 * Returns operation details for SSE monitoring.
 */
export const restoreBackup = <ThrowOnError extends boolean = false>(options: Options<RestoreBackupData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RestoreBackupResponses, RestoreBackupErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups/{backup_id}/restore',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get backup statistics
 * Get comprehensive backup statistics for the specified graph database
 */
export const getBackupStats = <ThrowOnError extends boolean = false>(options: Options<GetBackupStatsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetBackupStatsResponses, GetBackupStatsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/backups/stats',
        ...options
    });
};

/**
 * Get Graph Metrics
 * Get comprehensive metrics for the graph database.
 *
 * Provides detailed analytics including:
 * - **Node Statistics**: Counts by type (Entity, Report, Account, Transaction)
 * - **Relationship Metrics**: Connection counts and patterns
 * - **Data Quality**: Completeness scores and validation results
 * - **Performance Metrics**: Query response times and database health
 * - **Storage Analytics**: Database size and growth trends
 *
 * This data helps with:
 * - Monitoring data completeness
 * - Identifying data quality issues
 * - Capacity planning
 * - Performance optimization
 *
 * Note:
 * This operation is included - no credit consumption required.
 */
export const getGraphMetrics = <ThrowOnError extends boolean = false>(options: Options<GetGraphMetricsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphMetricsResponses, GetGraphMetricsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/analytics',
        ...options
    });
};

/**
 * Get Usage Statistics
 * Get detailed usage statistics for the graph.
 *
 * Provides temporal usage patterns including:
 * - **Query Volume**: API calls per day/hour
 * - **Credit Consumption**: Usage patterns and trends
 * - **Operation Breakdown**: Usage by operation type
 * - **User Activity**: Access patterns by user role
 * - **Peak Usage Times**: Identify high-activity periods
 *
 * Time ranges available:
 * - Last 24 hours (hourly breakdown)
 * - Last 7 days (daily breakdown)
 * - Last 30 days (daily breakdown)
 * - Custom date ranges
 *
 * Useful for:
 * - Capacity planning
 * - Cost optimization
 * - Usage trend analysis
 * - Performance tuning
 *
 * Note:
 * This operation is included - no credit consumption required.
 */
export const getGraphUsageStats = <ThrowOnError extends boolean = false>(options: Options<GetGraphUsageStatsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphUsageStatsResponses, GetGraphUsageStatsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/analytics/usage',
        ...options
    });
};

/**
 * Execute Cypher Query (Read-Only)
 * Execute a read-only Cypher query with intelligent response optimization.
 *
 * **IMPORTANT: This endpoint is READ-ONLY.** Write operations (CREATE, MERGE, SET, DELETE) are not allowed.
 * To load data into your graph, use the staging pipeline:
 * 1. Create file upload: `POST /v1/graphs/{graph_id}/tables/{table_name}/files`
 * 2. Ingest to graph: `POST /v1/graphs/{graph_id}/tables/ingest`
 *
 * This endpoint automatically selects the best execution strategy based on:
 * - Query characteristics (size, complexity)
 * - Client capabilities (SSE, NDJSON, JSON)
 * - System load (queue status, concurrent queries)
 * - User preferences (mode parameter, headers)
 *
 * **Response Modes:**
 * - `auto` (default): Intelligent automatic selection
 * - `sync`: Force synchronous JSON response (best for testing)
 * - `async`: Force queued response with SSE monitoring endpoints (no polling needed)
 * - `stream`: Force streaming response (SSE or NDJSON)
 *
 * **Client Detection:**
 * - Automatically detects testing tools (Postman, Swagger UI)
 * - Adjusts behavior for better interactive experience
 * - Respects Accept and Prefer headers for capabilities
 *
 * **Streaming Support (SSE):**
 * - Real-time events with progress updates
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 * - 30-second keepalive to prevent timeouts
 *
 * **Streaming Support (NDJSON):**
 * - Efficient line-delimited JSON for large results
 * - Automatic chunking (configurable 10-10000 rows)
 * - No connection limits (stateless streaming)
 *
 * **Queue Management:**
 * - Automatic queuing under high load
 * - Real-time monitoring via SSE events (no polling needed)
 * - Priority based on subscription tier
 * - Queue position and progress updates pushed via SSE
 * - Connect to returned `/v1/operations/{id}/stream` endpoint for updates
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Rate limit or connection limit exceeded
 * - `503 Service Unavailable`: Circuit breaker open or SSE disabled
 * - Clients should implement exponential backoff
 *
 * **Note:**
 * Query operations are included - no credit consumption required.
 * Queue position is based on subscription tier for priority.
 */
export const executeCypherQuery = <ThrowOnError extends boolean = false>(options: Options<ExecuteCypherQueryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ExecuteCypherQueryResponses, ExecuteCypherQueryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/query',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Runtime Graph Schema
 * Get runtime schema information for the specified graph database.
 *
 * This endpoint inspects the actual graph database structure and returns:
 * - **Node Labels**: All node types currently in the database
 * - **Relationship Types**: All relationship types currently in the database
 * - **Node Properties**: Properties for each node type (limited to first 10 for performance)
 *
 * This shows what actually exists in the database right now - the runtime state.
 * For the declared schema definition, use GET /schema/export instead.
 *
 * This operation is included - no credit consumption required.
 */
export const getGraphSchema = <ThrowOnError extends boolean = false>(options: Options<GetGraphSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphSchemaResponses, GetGraphSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/schema',
        ...options
    });
};

/**
 * Export Graph Schema
 * Export the schema of an existing graph in JSON, YAML, or Cypher format
 */
export const exportGraphSchema = <ThrowOnError extends boolean = false>(options: Options<ExportGraphSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ExportGraphSchemaResponses, ExportGraphSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/schema/export',
        ...options
    });
};

/**
 * Validate Schema
 * Validate a custom schema definition before deployment.
 *
 * This endpoint performs comprehensive validation including:
 * - **Structure Validation**: Ensures proper JSON/YAML format
 * - **Type Checking**: Validates data types (STRING, INT, DOUBLE, etc.)
 * - **Constraint Verification**: Checks primary keys and unique constraints
 * - **Relationship Integrity**: Validates node references in relationships
 * - **Naming Conventions**: Ensures valid identifiers
 * - **Compatibility**: Checks against existing extensions if specified
 *
 * Supported formats:
 * - JSON schema definitions
 * - YAML schema definitions
 * - Direct dictionary format
 *
 * Validation helps prevent:
 * - Schema deployment failures
 * - Data integrity issues
 * - Performance problems
 * - Naming conflicts
 *
 * This operation is included - no credit consumption required.
 */
export const validateSchema = <ThrowOnError extends boolean = false>(options: Options<ValidateSchemaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ValidateSchemaResponses, ValidateSchemaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/schema/validate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Current Bill
 * Get current month's billing details for the graph.
 *
 * Returns comprehensive billing information including:
 * - **Credit Usage**: Consumed vs. allocated credits
 * - **Storage Charges**: Current storage usage and costs
 * - **Subscription Tier**: Current plan and features
 * - **Pro-rated Charges**: If plan changed mid-month
 * - **Estimated Total**: Current charges to date
 *
 * Billing calculations are updated hourly. Storage is measured in GB-months.
 *
 * ℹ️ No credits are consumed for viewing billing information.
 */
export const getCurrentGraphBill = <ThrowOnError extends boolean = false>(options: Options<GetCurrentGraphBillData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCurrentGraphBillResponses, GetCurrentGraphBillErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/billing/current',
        ...options
    });
};

/**
 * Get Usage Details
 * Get detailed usage metrics for the graph.
 *
 * Provides granular usage information including:
 * - **Daily Credit Consumption**: Track credit usage patterns
 * - **Storage Growth**: Monitor database size over time
 * - **Operation Breakdown**: Credits by operation type
 * - **Peak Usage Times**: Identify high-activity periods
 * - **API Call Volumes**: Request counts and patterns
 *
 * Useful for:
 * - Optimizing credit consumption
 * - Capacity planning
 * - Usage trend analysis
 * - Cost optimization
 *
 * ℹ️ No credits are consumed for viewing usage details.
 */
export const getGraphUsageDetails = <ThrowOnError extends boolean = false>(options: Options<GetGraphUsageDetailsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphUsageDetailsResponses, GetGraphUsageDetailsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/billing/usage',
        ...options
    });
};

/**
 * Get Billing History
 * Get billing history for the graph.
 *
 * Returns a chronological list of monthly bills, perfect for:
 * - Tracking spending trends over time
 * - Identifying usage patterns
 * - Budget forecasting
 * - Financial reporting
 *
 * Each month includes:
 * - Credit usage and overages
 * - Storage charges
 * - Total charges
 * - Usage metrics
 *
 * ℹ️ No credits are consumed for viewing billing history.
 */
export const getGraphBillingHistory = <ThrowOnError extends boolean = false>(options: Options<GetGraphBillingHistoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphBillingHistoryResponses, GetGraphBillingHistoryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/billing/history',
        ...options
    });
};

/**
 * Get Monthly Bill
 * Get billing details for a specific month.
 *
 * Retrieve historical billing information for any previous month.
 * Useful for:
 * - Reconciling past charges
 * - Tracking usage trends
 * - Expense reporting
 * - Budget analysis
 *
 * Returns the same detailed breakdown as the current bill endpoint.
 *
 * ℹ️ No credits are consumed for viewing billing history.
 */
export const getGraphMonthlyBill = <ThrowOnError extends boolean = false>(options: Options<GetGraphMonthlyBillData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphMonthlyBillResponses, GetGraphMonthlyBillErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/billing/history/{year}/{month}',
        ...options
    });
};

/**
 * Get Credit Summary
 * Retrieve comprehensive credit usage summary for the specified graph.
 *
 * This endpoint provides:
 * - Current credit balance and monthly allocation
 * - Credit consumption metrics for the current month
 * - Graph tier and credit multiplier information
 * - Usage percentage to help monitor credit consumption
 *
 * No credits are consumed for checking credit status.
 */
export const getCreditSummary = <ThrowOnError extends boolean = false>(options: Options<GetCreditSummaryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetCreditSummaryResponses, GetCreditSummaryErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/summary',
        ...options
    });
};

/**
 * List Credit Transactions
 * Retrieve detailed credit transaction history for the specified graph.
 *
 * This enhanced endpoint provides:
 * - Detailed transaction records with idempotency information
 * - Summary by operation type to identify high-consumption operations
 * - Date range filtering for analysis
 * - Metadata search capabilities
 *
 * Transaction types include:
 * - ALLOCATION: Monthly credit allocations
 * - CONSUMPTION: Credit usage for operations
 * - BONUS: Bonus credits added by admins
 * - REFUND: Credit refunds
 *
 * No credits are consumed for viewing transaction history.
 */
export const listCreditTransactions = <ThrowOnError extends boolean = false>(options: Options<ListCreditTransactionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListCreditTransactionsResponses, ListCreditTransactionsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/transactions',
        ...options
    });
};

/**
 * Check Credit Balance
 * Check if the graph has sufficient credits for a planned operation.
 *
 * This endpoint allows you to verify credit availability before performing
 * an operation, helping prevent failed operations due to insufficient credits.
 *
 * The check considers:
 * - Base operation cost
 * - Graph tier multiplier
 * - Current credit balance
 *
 * No credits are consumed for checking availability.
 */
export const checkCreditBalance = <ThrowOnError extends boolean = false>(options: Options<CheckCreditBalanceData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<CheckCreditBalanceResponses, CheckCreditBalanceErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/balance/check',
        ...options
    });
};

/**
 * Get Storage Usage
 * Get storage usage history for a graph.
 *
 * Returns detailed storage usage information including:
 * - Daily average storage consumption
 * - Storage trends over time
 * - Credit costs for storage
 * - Current storage billing information
 *
 * This endpoint helps users understand their storage patterns
 * and associated credit costs.
 */
export const getStorageUsage = <ThrowOnError extends boolean = false>(options: Options<GetStorageUsageData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetStorageUsageResponses, GetStorageUsageErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/storage/usage',
        ...options
    });
};

/**
 * Check Storage Limits
 * Check storage limits and usage for a graph.
 *
 * Returns comprehensive storage limit information including:
 * - Current storage usage
 * - Effective limit (override or default)
 * - Usage percentage and warnings
 * - Recommendations for limit management
 *
 * This endpoint helps users monitor storage usage and plan for potential
 * limit increases. No credits are consumed for checking storage limits.
 */
export const checkStorageLimits = <ThrowOnError extends boolean = false>(options: Options<CheckStorageLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<CheckStorageLimitsResponses, CheckStorageLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/credits/storage/limits',
        ...options
    });
};

/**
 * Database Health Check
 * Get comprehensive health information for the graph database.
 *
 * Returns detailed health metrics including:
 * - **Connection Status**: Database connectivity and responsiveness
 * - **Performance Metrics**: Query execution times and throughput
 * - **Resource Usage**: Memory and storage utilization
 * - **Error Monitoring**: Recent error rates and patterns
 * - **Uptime Statistics**: Service availability metrics
 *
 * Health indicators:
 * - **Status**: healthy, degraded, or unhealthy
 * - **Query Performance**: Average execution times
 * - **Error Rates**: Recent failure percentages
 * - **Resource Usage**: Memory and storage consumption
 * - **Alerts**: Active warnings or issues
 *
 * This endpoint provides essential monitoring data for operational visibility.
 */
export const getDatabaseHealth = <ThrowOnError extends boolean = false>(options: Options<GetDatabaseHealthData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetDatabaseHealthResponses, GetDatabaseHealthErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/health',
        ...options
    });
};

/**
 * Database Information
 * Get comprehensive database information and statistics.
 *
 * Returns detailed database metrics including:
 * - **Database Metadata**: Name, path, size, and timestamps
 * - **Schema Information**: Node labels, relationship types, and counts
 * - **Storage Statistics**: Database size and usage metrics
 * - **Data Composition**: Node and relationship counts
 * - **Backup Information**: Available backups and last backup date
 * - **Configuration**: Read-only status and schema version
 *
 * Database statistics:
 * - **Size**: Storage usage in bytes and MB
 * - **Content**: Node and relationship counts
 * - **Schema**: Available labels and relationship types
 * - **Backup Status**: Backup availability and recency
 * - **Timestamps**: Creation and modification dates
 *
 * This endpoint provides essential database information for capacity planning and monitoring.
 */
export const getDatabaseInfo = <ThrowOnError extends boolean = false>(options: Options<GetDatabaseInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetDatabaseInfoResponses, GetDatabaseInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/info',
        ...options
    });
};

/**
 * Get Graph Operational Limits
 * Get comprehensive operational limits for the graph database.
 *
 * Returns all operational limits that apply to this graph including:
 * - **Storage Limits**: Maximum storage size and current usage
 * - **Query Limits**: Timeouts, complexity, row limits
 * - **Copy/Ingestion Limits**: File sizes, timeouts, concurrent operations
 * - **Backup Limits**: Frequency, retention, size limits
 * - **Rate Limits**: Requests per minute/hour based on tier
 * - **Credit Limits**: AI operation credits (if applicable)
 *
 * This unified endpoint provides all limits in one place for easier client integration.
 *
 * **Note**: Limits vary based on subscription tier (Standard, Enterprise, Premium).
 */
export const getGraphLimits = <ThrowOnError extends boolean = false>(options: Options<GetGraphLimitsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetGraphLimitsResponses, GetGraphLimitsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/limits',
        ...options
    });
};

/**
 * List Subgraphs
 * List all subgraphs for a parent graph.
 *
 * **Requirements:**
 * - Valid authentication
 * - Parent graph must exist and be accessible to the user
 * - User must have at least 'read' permission on the parent graph
 *
 * **Returns:**
 * - List of all subgraphs for the parent graph
 * - Each subgraph includes its ID, name, description, type, status, and creation date
 */
export const listSubgraphs = <ThrowOnError extends boolean = false>(options: Options<ListSubgraphsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListSubgraphsResponses, ListSubgraphsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs',
        ...options
    });
};

/**
 * Create Subgraph
 * Create a new subgraph within a parent graph.
 *
 * **Requirements:**
 * - Valid authentication
 * - Parent graph must exist and be accessible to the user
 * - User must have 'admin' permission on the parent graph
 * - Parent graph tier must support subgraphs (Enterprise or Premium only)
 * - Must be within subgraph quota limits
 * - Subgraph name must be unique within the parent graph
 *
 * **Returns:**
 * - Created subgraph details including its unique ID
 */
export const createSubgraph = <ThrowOnError extends boolean = false>(options: Options<CreateSubgraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateSubgraphResponses, CreateSubgraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete Subgraph
 * Delete a subgraph database.
 *
 * **Requirements:**
 * - Must be a valid subgraph (not parent graph)
 * - User must have admin access to parent graph
 * - Optional backup before deletion
 *
 * **Deletion Options:**
 * - `force`: Delete even if contains data
 * - `backup_first`: Create backup before deletion
 *
 * **Warning:**
 * Deletion is permanent unless backup is created.
 * All data in the subgraph will be lost.
 *
 * **Backup Location:**
 * If backup requested, stored in S3 at:
 * `s3://robosystems-backups/{instance_id}/{database_name}_{timestamp}.backup`
 */
export const deleteSubgraph = <ThrowOnError extends boolean = false>(options: Options<DeleteSubgraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteSubgraphResponses, DeleteSubgraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Subgraph Details
 * Get detailed information about a specific subgraph.
 *
 * **Requirements:**
 * - User must have read access to parent graph
 *
 * **Response includes:**
 * - Full subgraph metadata
 * - Database statistics (nodes, edges)
 * - Size information
 * - Schema configuration
 * - Creation/modification timestamps
 * - Last access time (when available)
 *
 * **Statistics:**
 * Real-time statistics queried from Kuzu:
 * - Node count
 * - Edge count
 * - Database size on disk
 * - Schema information
 */
export const getSubgraphInfo = <ThrowOnError extends boolean = false>(options: Options<GetSubgraphInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSubgraphInfoResponses, GetSubgraphInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_id}/info',
        ...options
    });
};

/**
 * Get Subgraph Quota
 * Get subgraph quota and usage information for a parent graph.
 *
 * **Shows:**
 * - Current subgraph count
 * - Maximum allowed subgraphs per tier
 * - Remaining capacity
 * - Total size usage across all subgraphs
 *
 * **Tier Limits:**
 * - Standard: 0 subgraphs (not supported)
 * - Enterprise: Configurable limit (default: 10 subgraphs)
 * - Premium: Unlimited subgraphs
 * - Limits are defined in deployment configuration
 *
 * **Size Tracking:**
 * Provides aggregate size metrics when available.
 * Individual subgraph sizes shown in list endpoint.
 */
export const getSubgraphQuota = <ThrowOnError extends boolean = false>(options: Options<GetSubgraphQuotaData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetSubgraphQuotaResponses, GetSubgraphQuotaErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/subgraphs/quota',
        ...options
    });
};

/**
 * List Staging Tables
 * List all DuckDB staging tables with comprehensive metrics and status.
 *
 * **Purpose:**
 * Get a complete inventory of all staging tables for a graph, including
 * file counts, storage sizes, and row estimates. Essential for monitoring
 * the data pipeline and determining which tables are ready for ingestion.
 *
 * **What You Get:**
 * - Table name and type (node/relationship)
 * - File count per table
 * - Total storage size in bytes
 * - Estimated row count
 * - S3 location pattern
 * - Ready-for-ingestion status
 *
 * **Use Cases:**
 * - Monitor data upload progress
 * - Check which tables have files ready
 * - Track storage consumption
 * - Validate pipeline before ingestion
 * - Capacity planning
 *
 * **Workflow:**
 * 1. List tables to see current state
 * 2. Upload files to empty tables
 * 3. Re-list to verify uploads
 * 4. Check file counts and sizes
 * 5. Ingest when ready
 *
 * **Example Response:**
 * ```json
 * {
 * "tables": [
 * {
 * "table_name": "Entity",
 * "row_count": 5000,
 * "file_count": 3,
 * "total_size_bytes": 2457600,
 * "s3_location": "s3://bucket/user-staging/user123/graph456/Entity***.parquet"
 * },
 * {
 * "table_name": "Transaction",
 * "row_count": 15000,
 * "file_count": 5,
 * "total_size_bytes": 8192000,
 * "s3_location": "s3://bucket/user-staging/user123/graph456/Transaction***.parquet"
 * }
 * ],
 * "total_count": 2
 * }
 * ```
 *
 * **Example Usage:**
 * ```bash
 * curl -H "Authorization: Bearer YOUR_TOKEN" \
 * https://api.robosystems.ai/v1/graphs/kg123/tables
 * ```
 *
 * **Tips:**
 * - Tables with `file_count > 0` have data ready
 * - Check `total_size_bytes` for storage monitoring
 * - Use `s3_location` to verify upload paths
 * - Empty tables (file_count=0) are skipped during ingestion
 *
 * **Note:**
 * Table queries are included - no credit consumption.
 */
export const listTables = <ThrowOnError extends boolean = false>(options: Options<ListTablesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListTablesResponses, ListTablesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables',
        ...options
    });
};

/**
 * List Files in Staging Table
 * List all files uploaded to a staging table with comprehensive metadata.
 *
 * **Purpose:**
 * Get a complete inventory of all files in a staging table, including upload status,
 * file sizes, row counts, and S3 locations. Essential for monitoring upload progress
 * and validating data before ingestion.
 *
 * **Use Cases:**
 * - Monitor file upload progress
 * - Verify files are ready for ingestion
 * - Check file formats and sizes
 * - Track storage usage per table
 * - Identify failed or incomplete uploads
 * - Pre-ingestion validation
 *
 * **What You Get:**
 * - File ID and name
 * - File format (parquet, csv, etc.)
 * - Size in bytes
 * - Row count (if available)
 * - Upload status and method
 * - Creation and upload timestamps
 * - S3 key for reference
 *
 * **Upload Status Values:**
 * - `created`: File record created, not yet uploaded
 * - `uploading`: Upload in progress
 * - `uploaded`: Successfully uploaded, ready for ingestion
 * - `failed`: Upload failed
 *
 * **Example Response:**
 * ```json
 * {
 * "graph_id": "kg123",
 * "table_name": "Entity",
 * "files": [
 * {
 * "file_id": "f123",
 * "file_name": "entities_batch1.parquet",
 * "file_format": "parquet",
 * "size_bytes": 1048576,
 * "row_count": 5000,
 * "upload_status": "uploaded",
 * "upload_method": "presigned_url",
 * "created_at": "2025-10-28T10:00:00Z",
 * "uploaded_at": "2025-10-28T10:01:30Z",
 * "s3_key": "user-staging/user123/kg123/Entity/entities_batch1.parquet"
 * }
 * ],
 * "total_files": 1,
 * "total_size_bytes": 1048576
 * }
 * ```
 *
 * **Example Usage:**
 * ```bash
 * curl -H "Authorization: Bearer YOUR_TOKEN" \
 * https://api.robosystems.ai/v1/graphs/kg123/tables/Entity/files
 * ```
 *
 * **Tips:**
 * - Only `uploaded` files are ingested
 * - Check `row_count` to estimate data volume
 * - Use `total_size_bytes` for storage monitoring
 * - Files with `failed` status should be deleted and re-uploaded
 *
 * **Note:**
 * File listing is included - no credit consumption.
 */
export const listTableFiles = <ThrowOnError extends boolean = false>(options: Options<ListTableFilesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListTableFilesResponses, ListTableFilesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/{table_name}/files',
        ...options
    });
};

/**
 * Get File Upload URL
 * Generate a presigned S3 URL for secure file upload.
 *
 * **Purpose:**
 * Initiate file upload to a staging table by generating a secure, time-limited
 * presigned S3 URL. Files are uploaded directly to S3, bypassing the API for
 * optimal performance.
 *
 * **Upload Workflow:**
 * 1. Call this endpoint to get presigned URL
 * 2. PUT file directly to S3 URL (using curl, axios, etc.)
 * 3. Call PATCH /tables/files/{file_id} with status='uploaded'
 * 4. Backend validates file and calculates metrics
 * 5. File ready for ingestion
 *
 * **Supported Formats:**
 * - Parquet (`application/x-parquet` with `.parquet` extension)
 * - CSV (`text/csv` with `.csv` extension)
 * - JSON (`application/json` with `.json` extension)
 *
 * **Validation:**
 * - File extension must match content type
 * - File name 1-255 characters
 * - No path traversal characters (.. / \)
 * - Auto-creates table if it doesn't exist
 *
 * **Auto-Table Creation:**
 * If the table doesn't exist, it's automatically created with:
 * - Type inferred from name (e.g., "Transaction" → relationship)
 * - Empty schema (populated on ingestion)
 * - Ready for file uploads
 *
 * **Example Response:**
 * ```json
 * {
 * "upload_url": "https://bucket.s3.amazonaws.com/path?X-Amz-Algorithm=...",
 * "expires_in": 3600,
 * "file_id": "f123-456-789",
 * "s3_key": "user-staging/user123/kg456/Entity/f123.../data.parquet"
 * }
 * ```
 *
 * **Example Usage:**
 * ```bash
 * # Step 1: Get upload URL
 * curl -X POST "https://api.robosystems.ai/v1/graphs/kg123/tables/Entity/files" \
 * -H "Authorization: Bearer YOUR_TOKEN" \
 * -H "Content-Type: application/json" \
 * -d '{
 * "file_name": "entities.parquet",
 * "content_type": "application/x-parquet"
 * }'
 *
 * # Step 2: Upload file directly to S3
 * curl -X PUT "$UPLOAD_URL" \
 * -H "Content-Type: application/x-parquet" \
 * --data-binary "@entities.parquet"
 *
 * # Step 3: Mark as uploaded
 * curl -X PATCH "https://api.robosystems.ai/v1/graphs/kg123/tables/files/$FILE_ID" \
 * -H "Authorization: Bearer YOUR_TOKEN" \
 * -H "Content-Type: application/json" \
 * -d '{"status": "uploaded"}'
 * ```
 *
 * **Tips:**
 * - Presigned URLs expire (default: 1 hour)
 * - Use appropriate Content-Type header when uploading to S3
 * - File extension must match content type
 * - Large files benefit from direct S3 upload
 *
 * **Note:**
 * Upload URL generation is included - no credit consumption.
 */
export const getUploadUrl = <ThrowOnError extends boolean = false>(options: Options<GetUploadUrlData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<GetUploadUrlResponses, GetUploadUrlErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/{table_name}/files',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Delete File from Staging
 * Delete a file from S3 storage and database tracking.
 *
 * **Purpose:**
 * Remove unwanted, duplicate, or incorrect files from staging tables before ingestion.
 * The file is deleted from both S3 and database tracking, and table statistics
 * are automatically recalculated.
 *
 * **Use Cases:**
 * - Remove duplicate uploads
 * - Delete files with incorrect data
 * - Clean up failed uploads
 * - Fix data quality issues before ingestion
 * - Manage storage usage
 *
 * **What Happens:**
 * 1. File deleted from S3 storage
 * 2. Database tracking record removed
 * 3. Table statistics recalculated (file count, size, row count)
 * 4. DuckDB automatically excludes file from future queries
 *
 * **Security:**
 * - Write access required (verified via auth)
 * - Shared repositories block file deletions
 * - Full audit trail of deletion operations
 * - Cannot delete after ingestion to graph
 *
 * **Example Response:**
 * ```json
 * {
 * "status": "deleted",
 * "file_id": "f123",
 * "file_name": "entities_batch1.parquet",
 * "message": "File deleted successfully. DuckDB will automatically exclude it from queries."
 * }
 * ```
 *
 * **Example Usage:**
 * ```bash
 * curl -X DELETE -H "Authorization: Bearer YOUR_TOKEN" \
 * https://api.robosystems.ai/v1/graphs/kg123/tables/files/f123
 * ```
 *
 * **Tips:**
 * - Delete files before ingestion for best results
 * - Table statistics update automatically
 * - No need to refresh DuckDB - exclusion is automatic
 * - Consider re-uploading corrected version after deletion
 *
 * **Note:**
 * File deletion is included - no credit consumption.
 */
export const deleteFile = <ThrowOnError extends boolean = false>(options: Options<DeleteFileData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteFileResponses, DeleteFileErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/files/{file_id}',
        ...options
    });
};

/**
 * Get File Information
 * Get detailed information about a specific file.
 *
 * **Purpose:**
 * Retrieve comprehensive metadata for a single file, including upload status,
 * size, row count, and timestamps. Useful for validating individual files
 * before ingestion.
 *
 * **Use Cases:**
 * - Validate file upload completion
 * - Check file metadata before ingestion
 * - Debug upload issues
 * - Verify file format and size
 * - Track file lifecycle
 *
 * **Example Response:**
 * ```json
 * {
 * "file_id": "f123",
 * "graph_id": "kg123",
 * "table_id": "t456",
 * "table_name": "Entity",
 * "file_name": "entities_batch1.parquet",
 * "file_format": "parquet",
 * "size_bytes": 1048576,
 * "row_count": 5000,
 * "upload_status": "uploaded",
 * "upload_method": "presigned_url",
 * "created_at": "2025-10-28T10:00:00Z",
 * "uploaded_at": "2025-10-28T10:01:30Z",
 * "s3_key": "user-staging/user123/kg123/Entity/entities_batch1.parquet"
 * }
 * ```
 *
 * **Example Usage:**
 * ```bash
 * curl -H "Authorization: Bearer YOUR_TOKEN" \
 * https://api.robosystems.ai/v1/graphs/kg123/tables/files/f123
 * ```
 *
 * **Note:**
 * File info retrieval is included - no credit consumption.
 */
export const getFileInfo = <ThrowOnError extends boolean = false>(options: Options<GetFileInfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetFileInfoResponses, GetFileInfoErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/files/{file_id}',
        ...options
    });
};

/**
 * Update File Upload Status
 * Update file status after upload completes.
 *
 * **Purpose:**
 * Mark files as uploaded after successful S3 upload. The backend validates
 * the file, calculates size and row count, enforces storage limits, and
 * registers the DuckDB table for queries.
 *
 * **Status Values:**
 * - `uploaded`: File successfully uploaded to S3 (triggers validation)
 * - `disabled`: Exclude file from ingestion
 * - `archived`: Soft delete file
 *
 * **What Happens on 'uploaded' Status:**
 * 1. Verify file exists in S3
 * 2. Calculate actual file size
 * 3. Enforce tier storage limits
 * 4. Calculate or estimate row count
 * 5. Update table statistics
 * 6. Register DuckDB external table
 * 7. File ready for ingestion
 *
 * **Row Count Calculation:**
 * - **Parquet**: Exact count from file metadata
 * - **CSV**: Count rows (minus header)
 * - **JSON**: Count array elements
 * - **Fallback**: Estimate from file size if reading fails
 *
 * **Storage Limits:**
 * Enforced per subscription tier:
 * - Prevents uploads exceeding tier limit
 * - Returns HTTP 413 if limit exceeded
 * - Check current usage before large uploads
 *
 * **Example Response:**
 * ```json
 * {
 * "status": "success",
 * "file_id": "f123",
 * "upload_status": "uploaded",
 * "file_size_bytes": 1048576,
 * "row_count": 5000,
 * "message": "File validated and ready for ingestion"
 * }
 * ```
 *
 * **Example Usage:**
 * ```bash
 * # After uploading file to S3 presigned URL
 * curl -X PATCH "https://api.robosystems.ai/v1/graphs/kg123/tables/files/f123" \
 * -H "Authorization: Bearer YOUR_TOKEN" \
 * -H "Content-Type: application/json" \
 * -d '{"status": "uploaded"}'
 * ```
 *
 * **Tips:**
 * - Always call this after S3 upload completes
 * - Check response for actual row count
 * - Storage limit errors (413) mean tier upgrade needed
 * - DuckDB registration failures are non-fatal (retried later)
 *
 * **Note:**
 * Status updates are included - no credit consumption.
 */
export const updateFileStatus = <ThrowOnError extends boolean = false>(options: Options<UpdateFileStatusData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).patch<UpdateFileStatusResponses, UpdateFileStatusErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/files/{file_id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Ingest Tables to Graph
 * Load all files from S3 into DuckDB staging tables and ingest into Kuzu graph database.
 *
 * **Purpose:**
 * Orchestrates the complete data pipeline from S3 staging files into the Kuzu graph database.
 * Processes all tables in a single bulk operation with comprehensive error handling and metrics.
 *
 * **Use Cases:**
 * - Initial graph population from uploaded data
 * - Incremental data updates with new files
 * - Complete database rebuild from source files
 * - Recovery from failed ingestion attempts
 *
 * **Workflow:**
 * 1. Upload data files via `POST /tables/{table_name}/files`
 * 2. Files are validated and marked as 'uploaded'
 * 3. Trigger ingestion: `POST /tables/ingest`
 * 4. DuckDB staging tables created from S3 patterns
 * 5. Data copied row-by-row from DuckDB to Kuzu
 * 6. Per-table results and metrics returned
 *
 * **Rebuild Feature:**
 * Setting `rebuild=true` regenerates the entire graph database from scratch:
 * - Deletes existing Kuzu database
 * - Recreates with fresh schema from active GraphSchema
 * - Ingests all data files
 * - Safe operation - S3 is source of truth
 * - Useful for schema changes or data corrections
 * - Graph marked as 'rebuilding' during process
 *
 * **Error Handling:**
 * - Per-table error isolation with `ignore_errors` flag
 * - Partial success support (some tables succeed, some fail)
 * - Detailed error reporting per table
 * - Graph status tracking throughout process
 * - Automatic failure recovery and cleanup
 *
 * **Performance:**
 * - Processes all tables in sequence
 * - Each table timed independently
 * - Total execution metrics provided
 * - Scales to thousands of files
 * - Optimized for large datasets
 *
 * **Example Request:**
 * ```bash
 * curl -X POST "https://api.robosystems.ai/v1/graphs/kg123/tables/ingest" \
 * -H "Authorization: Bearer YOUR_TOKEN" \
 * -H "Content-Type: application/json" \
 * -d '{
 * "ignore_errors": true,
 * "rebuild": false
 * }'
 * ```
 *
 * **Example Response:**
 * ```json
 * {
 * "status": "success",
 * "graph_id": "kg123",
 * "total_tables": 5,
 * "successful_tables": 5,
 * "failed_tables": 0,
 * "skipped_tables": 0,
 * "total_rows_ingested": 25000,
 * "total_execution_time_ms": 15420.5,
 * "results": [
 * {
 * "table_name": "Entity",
 * "status": "success",
 * "rows_ingested": 5000,
 * "execution_time_ms": 3200.1,
 * "error": null
 * }
 * ]
 * }
 * ```
 *
 * **Concurrency Control:**
 * Only one ingestion can run per graph at a time. If another ingestion is in progress,
 * you'll receive a 409 Conflict error. The distributed lock automatically expires after
 * the configured TTL (default: 1 hour) to prevent deadlocks from failed ingestions.
 *
 * **Tips:**
 * - Only files with 'uploaded' status are processed
 * - Tables with no uploaded files are skipped
 * - Use `ignore_errors=false` for strict validation
 * - Monitor progress via per-table results
 * - Check graph metadata for rebuild status
 * - Wait for current ingestion to complete before starting another
 *
 * **Note:**
 * Table ingestion is included - no credit consumption.
 */
export const ingestTables = <ThrowOnError extends boolean = false>(options: Options<IngestTablesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<IngestTablesResponses, IngestTablesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/ingest',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Query Staging Tables with SQL
 * Execute SQL queries on DuckDB staging tables for data inspection and validation.
 *
 * **Purpose:**
 * Query raw staging data directly with SQL before ingestion into the graph database.
 * Useful for data quality checks, validation, and exploratory analysis.
 *
 * **Use Cases:**
 * - Validate data quality before graph ingestion
 * - Inspect row-level data for debugging
 * - Run analytics on staging tables
 * - Check for duplicates, nulls, or data issues
 * - Preview data transformations
 *
 * **Workflow:**
 * 1. Upload data files via `POST /tables/{table_name}/files`
 * 2. Query staging tables to validate: `POST /tables/query`
 * 3. Fix any data issues by re-uploading
 * 4. Ingest validated data: `POST /tables/ingest`
 *
 * **Supported SQL:**
 * - Full DuckDB SQL syntax
 * - SELECT, JOIN, WHERE, GROUP BY, ORDER BY
 * - Aggregations, window functions, CTEs
 * - Multiple table joins across staging area
 *
 * **Example Queries:**
 * ```sql
 * -- Count rows in staging table
 * SELECT COUNT(*) FROM Entity;
 *
 * -- Check for nulls
 * SELECT * FROM Entity WHERE name IS NULL LIMIT 10;
 *
 * -- Find duplicates
 * SELECT identifier, COUNT(*) as cnt
 * FROM Entity
 * GROUP BY identifier
 * HAVING COUNT(*) > 1;
 *
 * -- Join across tables
 * SELECT e.name, COUNT(t.id) as transaction_count
 * FROM Entity e
 * LEFT JOIN Transaction t ON e.identifier = t.entity_id
 * GROUP BY e.name
 * ORDER BY transaction_count DESC;
 * ```
 *
 * **Limits:**
 * - Query timeout: 30 seconds
 * - Result limit: 10,000 rows (use LIMIT clause)
 * - Read-only: No INSERT, UPDATE, DELETE
 * - User's tables only: Cannot query other users' data
 *
 * **Shared Repositories:**
 * Shared repositories (SEC, etc.) do not allow direct SQL queries.
 * Use the graph query endpoint instead: `POST /v1/graphs/{graph_id}/query`
 *
 * **Note:**
 * Staging table queries are included - no credit consumption.
 */
export const queryTables = <ThrowOnError extends boolean = false>(options: Options<QueryTablesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<QueryTablesResponses, QueryTablesErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/tables/query',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get User Graphs
 * Get all graph databases accessible to the current user.
 */
export const getGraphs = <ThrowOnError extends boolean = false>(options?: Options<GetGraphsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetGraphsResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs',
        ...options
    });
};

/**
 * Create New Graph Database
 * Create a new graph database with specified schema and optionally an initial entity.
 *
 * This endpoint starts an asynchronous graph creation operation and returns
 * connection details for monitoring progress via Server-Sent Events (SSE).
 *
 * **Operation Types:**
 * - **Generic Graph**: Creates empty graph with schema extensions
 * - **Entity Graph**: Creates graph with initial entity data
 *
 * **Monitoring Progress:**
 * Use the returned `operation_id` to connect to the SSE stream:
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/{operation_id}/stream');
 * eventSource.onmessage = (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Progress:', data.progress_percent + '%');
 * };
 * ```
 *
 * **SSE Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic circuit breaker for Redis failures
 * - Graceful degradation if event system unavailable
 *
 * **Events Emitted:**
 * - `operation_started`: Graph creation begins
 * - `operation_progress`: Schema loading, database setup, etc.
 * - `operation_completed`: Graph ready with connection details
 * - `operation_error`: Creation failed with error details
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: SSE connection limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - Clients should implement exponential backoff on errors
 *
 * **Response includes:**
 * - `operation_id`: Unique identifier for monitoring
 * - `_links.stream`: SSE endpoint for real-time updates
 * - `_links.status`: Point-in-time status check endpoint
 */
export const createGraph = <ThrowOnError extends boolean = false>(options: Options<CreateGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<CreateGraphResponses, CreateGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Get Available Schema Extensions
 * List all available schema extensions for graph creation
 */
export const getAvailableExtensions = <ThrowOnError extends boolean = false>(options?: Options<GetAvailableExtensionsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetAvailableExtensionsResponses, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/extensions',
        ...options
    });
};

/**
 * Select Graph
 * Select a specific graph as the active graph for the user.
 */
export const selectGraph = <ThrowOnError extends boolean = false>(options: Options<SelectGraphData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<SelectGraphResponses, SelectGraphErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/graphs/{graph_id}/select',
        ...options
    });
};

/**
 * Get Service Offerings
 * Get comprehensive information about all subscription offerings.
 *
 * This endpoint provides complete information about both graph database subscriptions
 * and shared repository subscriptions. This is the primary endpoint for frontend
 * applications to display subscription options.
 *
 * Includes:
 * - Graph subscription tiers (standard, enterprise, premium)
 * - Shared repository subscriptions (SEC, industry, economic data)
 * - Operation costs and credit information
 * - Features and capabilities for each tier
 * - Enabled/disabled status for repositories
 *
 * All data comes from the config-based systems to ensure accuracy with backend behavior.
 *
 * No authentication required - this is public service information.
 */
export const getServiceOfferings = <ThrowOnError extends boolean = false>(options?: Options<GetServiceOfferingsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetServiceOfferingsResponses, GetServiceOfferingsErrors, ThrowOnError>({
        url: '/v1/offering',
        ...options
    });
};

/**
 * Stream Operation Events
 * Stream real-time events for an operation using Server-Sent Events (SSE).
 *
 * This endpoint provides real-time monitoring for all non-immediate operations including:
 * - Graph creation and management
 * - Agent analysis processing
 * - Database backups and restores
 * - Data synchronization tasks
 *
 * **Event Types:**
 * - `operation_started`: Operation began execution
 * - `operation_progress`: Progress update with details
 * - `operation_completed`: Operation finished successfully
 * - `operation_error`: Operation failed with error details
 * - `operation_cancelled`: Operation was cancelled
 *
 * **Features:**
 * - **Event Replay**: Use `from_sequence` parameter to replay missed events
 * - **Automatic Reconnection**: Client can reconnect and resume from last seen event
 * - **Real-time Updates**: Live progress updates during execution
 * - **Timeout Handling**: 30-second keepalive messages prevent connection timeouts
 * - **Graceful Degradation**: Automatic fallback if Redis is unavailable
 *
 * **Connection Limits:**
 * - Maximum 5 concurrent SSE connections per user
 * - Rate limited to 10 new connections per minute
 * - Automatic cleanup of stale connections
 * - Circuit breaker protection for Redis failures
 *
 * **Client Usage:**
 * ```javascript
 * const eventSource = new EventSource('/v1/operations/abc123/stream');
 * eventSource.onmessage = (event) => {
 * const data = JSON.parse(event.data);
 * console.log('Progress:', data);
 * };
 * eventSource.onerror = (error) => {
 * // Handle connection errors or rate limits
 * console.error('SSE Error:', error);
 * };
 * ```
 *
 * **Error Handling:**
 * - `429 Too Many Requests`: Connection limit or rate limit exceeded
 * - `503 Service Unavailable`: SSE system temporarily disabled
 * - Clients should implement exponential backoff on errors
 *
 * **No credits are consumed for SSE connections.**
 */
export const streamOperationEvents = <ThrowOnError extends boolean = false>(options: Options<StreamOperationEventsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StreamOperationEventsResponses, StreamOperationEventsErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}/stream',
        ...options
    });
};

/**
 * Get Operation Status
 * Get current status and metadata for an operation.
 *
 * Returns detailed information including:
 * - Current status (pending, running, completed, failed, cancelled)
 * - Creation and update timestamps
 * - Operation type and associated graph
 * - Result data (for completed operations)
 * - Error details (for failed operations)
 *
 * This endpoint provides a point-in-time status check, while the `/stream` endpoint
 * provides real-time updates. Use this for polling or initial status checks.
 *
 * **No credits are consumed for status checks.**
 */
export const getOperationStatus = <ThrowOnError extends boolean = false>(options: Options<GetOperationStatusData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetOperationStatusResponses, GetOperationStatusErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}/status',
        ...options
    });
};

/**
 * Cancel Operation
 * Cancel a pending or running operation.
 *
 * Cancels the specified operation if it's still in progress. Once cancelled,
 * the operation cannot be resumed and will emit a cancellation event to any
 * active SSE connections.
 *
 * **Note**: Completed or already failed operations cannot be cancelled.
 *
 * **No credits are consumed for cancellation requests.**
 */
export const cancelOperation = <ThrowOnError extends boolean = false>(options: Options<CancelOperationData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<CancelOperationResponses, CancelOperationErrors, ThrowOnError>({
        security: [
            {
                name: 'X-API-Key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/v1/operations/{operation_id}',
        ...options
    });
};