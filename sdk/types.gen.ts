// This file is auto-generated by @hey-api/openapi-ts

/**
 * APIKeyInfo
 * API key information response model.
 */
export type ApiKeyInfo = {
    /**
     * Id
     * API key ID
     */
    id: string;
    /**
     * Name
     * API key name
     */
    name: string;
    /**
     * Description
     * API key description
     */
    description?: string | null;
    /**
     * Prefix
     * API key prefix for identification
     */
    prefix: string;
    /**
     * Is Active
     * Whether the key is active
     */
    is_active: boolean;
    /**
     * Last Used At
     * Last used timestamp
     */
    last_used_at?: string | null;
    /**
     * Expires At
     * Expiration timestamp
     */
    expires_at?: string | null;
    /**
     * Created At
     * Creation timestamp
     */
    created_at: string;
};

/**
 * APIKeysResponse
 * Response model for listing API keys.
 */
export type ApiKeysResponse = {
    /**
     * Api Keys
     * List of user's API keys
     */
    api_keys: Array<ApiKeyInfo>;
};

/**
 * AccountInfo
 * Provider account information.
 */
export type AccountInfo = {
    /**
     * Provider
     * Authentication provider ID (e.g., 'github', 'google')
     */
    provider: string;
    /**
     * Provider Type
     * Type of provider
     */
    provider_type: string;
    /**
     * Provider Account Id
     * Account ID at the provider
     */
    provider_account_id: string;
};

/**
 * AddOnCreditInfo
 * Credit information for a specific add-on.
 */
export type AddOnCreditInfo = {
    /**
     * Subscription Id
     * Subscription ID
     */
    subscription_id: string;
    /**
     * Addon Type
     * Add-on type (e.g., sec_data)
     */
    addon_type: string;
    /**
     * Name
     * Display name of the add-on
     */
    name: string;
    /**
     * Tier
     * Subscription tier
     */
    tier: string;
    /**
     * Credits Remaining
     * Credits remaining
     */
    credits_remaining: number;
    /**
     * Credits Allocated
     * Monthly credit allocation
     */
    credits_allocated: number;
    /**
     * Credits Consumed
     * Credits consumed this month
     */
    credits_consumed: number;
    /**
     * Rollover Amount
     * Credits rolled over from previous month
     */
    rollover_amount?: number;
};

/**
 * AgentListResponse
 * Response for listing available agents.
 */
export type AgentListResponse = {
    /**
     * Agents
     * Dictionary of available agents with metadata
     */
    agents: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    /**
     * Total
     * Total number of agents
     */
    total: number;
};

/**
 * AgentMessage
 * Message in conversation history.
 */
export type AgentMessage = {
    /**
     * Role
     * Message role (user/assistant)
     */
    role: string;
    /**
     * Content
     * Message content
     */
    content: string;
    /**
     * Timestamp
     * Message timestamp
     */
    timestamp?: string | null;
};

/**
 * AgentMetadataResponse
 * Response for agent metadata.
 */
export type AgentMetadataResponse = {
    /**
     * Name
     * Agent name
     */
    name: string;
    /**
     * Description
     * Agent description
     */
    description: string;
    /**
     * Version
     * Agent version
     */
    version: string;
    /**
     * Capabilities
     * Agent capabilities
     */
    capabilities: Array<string>;
    /**
     * Supported Modes
     * Supported execution modes
     */
    supported_modes: Array<string>;
    /**
     * Requires Credits
     * Whether agent requires credits
     */
    requires_credits: boolean;
    /**
     * Author
     * Agent author
     */
    author?: string | null;
    /**
     * Tags
     * Agent tags
     */
    tags?: Array<string>;
};

/**
 * AgentMode
 * Agent execution modes.
 */
export type AgentMode = 'quick' | 'standard' | 'extended' | 'streaming';

/**
 * AgentRecommendation
 * Single agent recommendation.
 */
export type AgentRecommendation = {
    /**
     * Agent Type
     * Agent type identifier
     */
    agent_type: string;
    /**
     * Agent Name
     * Agent display name
     */
    agent_name: string;
    /**
     * Confidence
     * Confidence score (0-1)
     */
    confidence: number;
    /**
     * Capabilities
     * Agent capabilities
     */
    capabilities: Array<string>;
    /**
     * Reason
     * Reason for recommendation
     */
    reason?: string | null;
};

/**
 * AgentRecommendationRequest
 * Request for agent recommendations.
 */
export type AgentRecommendationRequest = {
    /**
     * Query
     * Query to analyze
     */
    query: string;
    /**
     * Context
     * Additional context
     */
    context?: {
        [key: string]: unknown;
    } | null;
};

/**
 * AgentRecommendationResponse
 * Response for agent recommendations.
 */
export type AgentRecommendationResponse = {
    /**
     * Recommendations
     * List of agent recommendations sorted by confidence
     */
    recommendations: Array<AgentRecommendation>;
    /**
     * Query
     * The analyzed query
     */
    query: string;
};

/**
 * AgentRequest
 * Request model for agent interactions.
 */
export type AgentRequest = {
    /**
     * Message
     * The query or message to process
     */
    message: string;
    /**
     * History
     * Conversation history
     */
    history?: Array<AgentMessage>;
    /**
     * Context
     * Additional context for analysis (e.g., enable_rag, include_schema)
     */
    context?: {
        [key: string]: unknown;
    } | null;
    /**
     * Execution mode
     */
    mode?: AgentMode | null;
    /**
     * Agent Type
     * Specific agent type to use (optional)
     */
    agent_type?: string | null;
    /**
     * Criteria for agent selection
     */
    selection_criteria?: SelectionCriteria | null;
    /**
     * Force Extended Analysis
     * Force extended analysis mode with comprehensive research
     */
    force_extended_analysis?: boolean;
    /**
     * Enable Rag
     * Enable RAG context enrichment
     */
    enable_rag?: boolean;
    /**
     * Stream
     * Enable streaming response
     */
    stream?: boolean;
};

/**
 * AgentResponse
 * Response model for agent interactions.
 */
export type AgentResponse = {
    /**
     * Content
     * The agent's response content
     */
    content: string;
    /**
     * Agent Used
     * The agent type that handled the request
     */
    agent_used: string;
    /**
     * The execution mode used
     */
    mode_used: AgentMode;
    /**
     * Metadata
     * Response metadata including routing info
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Tokens Used
     * Token usage statistics
     */
    tokens_used?: {
        [key: string]: number;
    } | null;
    /**
     * Confidence Score
     * Confidence score of the response
     */
    confidence_score?: number | null;
    /**
     * Operation Id
     * Operation ID for SSE monitoring
     */
    operation_id?: string | null;
    /**
     * Is Partial
     * Whether this is a partial response
     */
    is_partial?: boolean;
    /**
     * Error Details
     * Error details if any
     */
    error_details?: {
        [key: string]: unknown;
    } | null;
    /**
     * Execution Time
     * Execution time in seconds
     */
    execution_time?: number | null;
    /**
     * Timestamp
     * Response timestamp
     */
    timestamp?: string;
};

/**
 * AuthResponse
 * Authentication response model.
 */
export type AuthResponse = {
    /**
     * User
     * User information
     */
    user: {
        [key: string]: unknown;
    };
    /**
     * Message
     * Success message
     */
    message: string;
    /**
     * Token
     * JWT authentication token (optional for cookie-based auth)
     */
    token?: string | null;
};

/**
 * AvailableExtension
 */
export type AvailableExtension = {
    /**
     * Name
     */
    name: string;
    /**
     * Description
     */
    description: string;
    /**
     * Enabled
     */
    enabled?: boolean;
};

/**
 * AvailableExtensionsResponse
 */
export type AvailableExtensionsResponse = {
    /**
     * Extensions
     */
    extensions: Array<AvailableExtension>;
};

/**
 * BackupCreateRequest
 * Request model for creating a backup.
 */
export type BackupCreateRequest = {
    /**
     * Backup Format
     * Backup format - only 'full_dump' is supported (complete .kuzu database file)
     */
    backup_format?: string;
    /**
     * Backup Type
     * Backup type - only 'full' is supported
     */
    backup_type?: string;
    /**
     * Retention Days
     * Retention period in days
     */
    retention_days?: number;
    /**
     * Compression
     * Enable compression (always enabled for optimal storage)
     */
    compression?: boolean;
    /**
     * Encryption
     * Enable encryption (encrypted backups cannot be downloaded)
     */
    encryption?: boolean;
    /**
     * Schedule
     * Optional cron schedule for automated backups
     */
    schedule?: string | null;
};

/**
 * BackupListResponse
 * Response model for backup list.
 */
export type BackupListResponse = {
    /**
     * Backups
     */
    backups: Array<BackupResponse>;
    /**
     * Total Count
     */
    total_count: number;
    /**
     * Graph Id
     */
    graph_id: string;
};

/**
 * BackupResponse
 * Response model for backup information.
 */
export type BackupResponse = {
    /**
     * Backup Id
     */
    backup_id: string;
    /**
     * Graph Id
     */
    graph_id: string;
    /**
     * Backup Format
     */
    backup_format: string;
    /**
     * Backup Type
     */
    backup_type: string;
    /**
     * Status
     */
    status: string;
    /**
     * Original Size Bytes
     */
    original_size_bytes: number;
    /**
     * Compressed Size Bytes
     */
    compressed_size_bytes: number;
    /**
     * Compression Ratio
     */
    compression_ratio: number;
    /**
     * Node Count
     */
    node_count: number;
    /**
     * Relationship Count
     */
    relationship_count: number;
    /**
     * Backup Duration Seconds
     */
    backup_duration_seconds: number;
    /**
     * Encryption Enabled
     */
    encryption_enabled: boolean;
    /**
     * Compression Enabled
     */
    compression_enabled: boolean;
    /**
     * Allow Export
     */
    allow_export: boolean;
    /**
     * Created At
     */
    created_at: string;
    /**
     * Completed At
     */
    completed_at: string | null;
    /**
     * Expires At
     */
    expires_at: string | null;
};

/**
 * BackupRestoreRequest
 * Request model for restoring from a backup.
 */
export type BackupRestoreRequest = {
    /**
     * Create System Backup
     * Create a system backup of existing database before restore
     */
    create_system_backup?: boolean;
    /**
     * Verify After Restore
     * Verify database integrity after restore
     */
    verify_after_restore?: boolean;
};

/**
 * BackupStatsResponse
 * Response model for backup statistics.
 */
export type BackupStatsResponse = {
    /**
     * Graph Id
     */
    graph_id: string;
    /**
     * Total Backups
     */
    total_backups: number;
    /**
     * Successful Backups
     */
    successful_backups: number;
    /**
     * Failed Backups
     */
    failed_backups: number;
    /**
     * Success Rate
     */
    success_rate: number;
    /**
     * Total Original Size Bytes
     */
    total_original_size_bytes: number;
    /**
     * Total Compressed Size Bytes
     */
    total_compressed_size_bytes: number;
    /**
     * Storage Saved Bytes
     */
    storage_saved_bytes: number;
    /**
     * Average Compression Ratio
     */
    average_compression_ratio: number;
    /**
     * Latest Backup Date
     */
    latest_backup_date: string | null;
    /**
     * Backup Formats
     */
    backup_formats: {
        [key: string]: number;
    };
};

/**
 * BatchAgentRequest
 * Request for batch processing multiple queries.
 */
export type BatchAgentRequest = {
    /**
     * Queries
     * List of queries to process
     */
    queries: Array<AgentRequest>;
    /**
     * Parallel
     * Process queries in parallel
     */
    parallel?: boolean;
};

/**
 * BatchAgentResponse
 * Response for batch processing.
 */
export type BatchAgentResponse = {
    /**
     * Results
     * List of agent responses
     */
    results: Array<AgentResponse>;
    /**
     * Total Execution Time
     * Total execution time
     */
    total_execution_time: number;
    /**
     * Parallel Processed
     * Whether queries were processed in parallel
     */
    parallel_processed: boolean;
};

/**
 * BulkIngestRequest
 */
export type BulkIngestRequest = {
    /**
     * Ignore Errors
     * Continue ingestion on row errors
     */
    ignore_errors?: boolean;
    /**
     * Rebuild
     * Rebuild graph database from scratch before ingestion. Safe operation - staged data is the source of truth, graph can always be regenerated.
     */
    rebuild?: boolean;
};

/**
 * BulkIngestResponse
 */
export type BulkIngestResponse = {
    /**
     * Status
     * Overall ingestion status
     */
    status: string;
    /**
     * Graph Id
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Total Tables
     * Total number of tables processed
     */
    total_tables: number;
    /**
     * Successful Tables
     * Number of successfully ingested tables
     */
    successful_tables: number;
    /**
     * Failed Tables
     * Number of failed table ingestions
     */
    failed_tables: number;
    /**
     * Skipped Tables
     * Number of skipped tables (no files)
     */
    skipped_tables: number;
    /**
     * Total Rows Ingested
     * Total rows ingested across all tables
     */
    total_rows_ingested: number;
    /**
     * Total Execution Time Ms
     * Total execution time in milliseconds
     */
    total_execution_time_ms: number;
    /**
     * Results
     * Per-table ingestion results
     */
    results: Array<TableIngestResult>;
};

/**
 * CancellationResponse
 * Response for subscription cancellation.
 */
export type CancellationResponse = {
    /**
     * Message
     * Cancellation confirmation message
     */
    message: string;
    /**
     * Subscription Id
     * ID of the cancelled subscription
     */
    subscription_id: string;
    /**
     * Cancelled At
     * Cancellation timestamp (ISO format)
     */
    cancelled_at: string;
};

/**
 * ConnectionOptionsResponse
 * Response with all available connection options.
 */
export type ConnectionOptionsResponse = {
    /**
     * Providers
     * Available connection providers
     */
    providers: Array<ConnectionProviderInfo>;
    /**
     * Total Providers
     * Total number of providers
     */
    total_providers: number;
};

/**
 * ConnectionProviderInfo
 * Information about a connection provider.
 */
export type ConnectionProviderInfo = {
    /**
     * Provider
     * Provider identifier
     */
    provider: 'sec' | 'quickbooks' | 'plaid';
    /**
     * Display Name
     * Human-readable provider name
     */
    display_name: string;
    /**
     * Description
     * Provider description
     */
    description: string;
    /**
     * Auth Type
     * Authentication type
     */
    auth_type: 'none' | 'oauth' | 'link' | 'api_key';
    /**
     * Auth Flow
     * Description of authentication flow
     */
    auth_flow?: string | null;
    /**
     * Required Config
     * Required configuration fields
     */
    required_config: Array<string>;
    /**
     * Optional Config
     * Optional configuration fields
     */
    optional_config?: Array<string>;
    /**
     * Features
     * Supported features
     */
    features: Array<string>;
    /**
     * Sync Frequency
     * Typical sync frequency
     */
    sync_frequency?: string | null;
    /**
     * Data Types
     * Types of data available
     */
    data_types: Array<string>;
    /**
     * Setup Instructions
     * Setup instructions
     */
    setup_instructions?: string | null;
    /**
     * Documentation Url
     * Link to documentation
     */
    documentation_url?: string | null;
};

/**
 * ConnectionResponse
 * Connection response model.
 */
export type ConnectionResponse = {
    /**
     * Connection Id
     * Unique connection identifier
     */
    connection_id: string;
    /**
     * Provider
     * Connection provider type
     */
    provider: 'sec' | 'quickbooks' | 'plaid';
    /**
     * Entity Id
     * Entity identifier
     */
    entity_id: string;
    /**
     * Status
     * Connection status
     */
    status: string;
    /**
     * Created At
     * Creation timestamp
     */
    created_at: string;
    /**
     * Updated At
     * Last update timestamp
     */
    updated_at?: string | null;
    /**
     * Last Sync
     * Last sync timestamp
     */
    last_sync?: string | null;
    /**
     * Metadata
     * Provider-specific metadata
     */
    metadata: {
        [key: string]: unknown;
    };
};

/**
 * CreateAPIKeyRequest
 * Request model for creating a new API key.
 */
export type CreateApiKeyRequest = {
    /**
     * Name
     * Name for the API key
     */
    name: string;
    /**
     * Description
     * Optional description
     */
    description?: string | null;
    /**
     * Expires At
     * Optional expiration date in ISO format (e.g. 2024-12-31T23:59:59Z)
     */
    expires_at?: string | null;
};

/**
 * CreateAPIKeyResponse
 * Response model for creating a new API key.
 */
export type CreateApiKeyResponse = {
    /**
     * API key information
     */
    api_key: ApiKeyInfo;
    /**
     * Key
     * The actual API key (only shown once)
     */
    key: string;
};

/**
 * CreateConnectionRequest
 * Request to create a new connection.
 */
export type CreateConnectionRequest = {
    /**
     * Provider
     * Connection provider type
     */
    provider: 'sec' | 'quickbooks' | 'plaid';
    /**
     * Entity Id
     * Entity identifier
     */
    entity_id: string;
    sec_config?: SecConnectionConfig | null;
    quickbooks_config?: QuickBooksConnectionConfig | null;
    plaid_config?: PlaidConnectionConfig | null;
};

/**
 * CreateGraphRequest
 * Request model for creating a new graph.
 */
export type CreateGraphRequest = {
    /**
     * Graph metadata including name, description, and schema extensions
     */
    metadata: GraphMetadata;
    /**
     * Instance Tier
     * Instance tier: kuzu-standard, kuzu-large, kuzu-xlarge, neo4j-community-large, neo4j-enterprise-xlarge
     */
    instance_tier?: string;
    /**
     * Custom schema definition to apply
     */
    custom_schema?: CustomSchemaDefinition | null;
    /**
     * Optional initial entity to create in the graph. If provided, creates a entity-focused graph.
     */
    initial_entity?: InitialEntityData | null;
    /**
     * Create Entity
     * Whether to create the entity node and upload initial data. Only applies when initial_entity is provided. Set to False to create graph without populating entity data (useful for file-based ingestion workflows).
     */
    create_entity?: boolean;
    /**
     * Tags
     * Optional tags for organization
     */
    tags?: Array<string>;
};

/**
 * CreateSubgraphRequest
 * Request model for creating a subgraph.
 */
export type CreateSubgraphRequest = {
    /**
     * Name
     * Alphanumeric name for the subgraph (e.g., dev, staging, prod1)
     */
    name: string;
    /**
     * Display Name
     * Human-readable display name for the subgraph
     */
    display_name: string;
    /**
     * Description
     * Optional description of the subgraph's purpose
     */
    description?: string | null;
    /**
     * Schema Extensions
     * Schema extensions to include (inherits from parent by default)
     */
    schema_extensions?: Array<string> | null;
    /**
     * Type of subgraph (currently only 'static' is supported)
     */
    subgraph_type?: SubgraphType;
    /**
     * Metadata
     * Additional metadata for the subgraph
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
};

/**
 * CreditSummary
 * Credit balance summary.
 */
export type CreditSummary = {
    /**
     * Current Balance
     * Current credit balance
     */
    current_balance: number;
    /**
     * Monthly Allocation
     * Monthly credit allocation
     */
    monthly_allocation: number;
    /**
     * Consumed This Month
     * Credits consumed this month
     */
    consumed_this_month: number;
    /**
     * Usage Percentage
     * Usage percentage of monthly allocation
     */
    usage_percentage: number;
    /**
     * Rollover Credits
     * Credits rolled over from previous month
     */
    rollover_credits: number;
    /**
     * Allows Rollover
     * Whether rollover is allowed
     */
    allows_rollover: boolean;
    /**
     * Last Allocation Date
     * Last allocation date (ISO format)
     */
    last_allocation_date?: string | null;
    /**
     * Next Allocation Date
     * Next allocation date (ISO format)
     */
    next_allocation_date?: string | null;
    /**
     * Is Active
     * Whether credit pool is active
     */
    is_active: boolean;
};

/**
 * CreditSummaryResponse
 * Credit summary response model.
 */
export type CreditSummaryResponse = {
    /**
     * Graph Id
     */
    graph_id: string;
    /**
     * Graph Tier
     */
    graph_tier: string;
    /**
     * Current Balance
     */
    current_balance: number;
    /**
     * Monthly Allocation
     */
    monthly_allocation: number;
    /**
     * Consumed This Month
     */
    consumed_this_month: number;
    /**
     * Transaction Count
     */
    transaction_count: number;
    /**
     * Usage Percentage
     */
    usage_percentage: number;
    /**
     * Last Allocation Date
     */
    last_allocation_date?: string | null;
};

/**
 * CreditsSummaryResponse
 * Response for credits summary.
 */
export type CreditsSummaryResponse = {
    /**
     * Add Ons
     * Credits breakdown by add-on
     */
    add_ons: Array<AddOnCreditInfo>;
    /**
     * Total Credits
     * Total credits remaining across all subscriptions
     */
    total_credits: number;
    /**
     * Credits By Addon
     * Legacy field - Credits breakdown by add-on
     * @deprecated
     */
    credits_by_addon?: Array<{
        [key: string]: unknown;
    }> | null;
    /**
     * Addon Count
     * Number of active add-ons
     */
    addon_count: number;
};

/**
 * CustomSchemaDefinition
 * Custom schema definition for custom graphs.
 */
export type CustomSchemaDefinition = {
    /**
     * Name
     * Schema name
     */
    name: string;
    /**
     * Version
     * Schema version
     */
    version?: string;
    /**
     * Description
     * Schema description
     */
    description?: string | null;
    /**
     * Extends
     * Base schema to extend (e.g., 'base')
     */
    extends?: string | null;
    /**
     * Nodes
     * List of node definitions with properties
     */
    nodes?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Relationships
     * List of relationship definitions
     */
    relationships?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Metadata
     * Additional schema metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * CypherQueryRequest
 * Request model for Cypher query execution.
 */
export type CypherQueryRequest = {
    /**
     * Query
     * The Cypher query to execute
     */
    query: string;
    /**
     * Parameters
     * Optional parameters for the Cypher query
     */
    parameters?: {
        [key: string]: unknown;
    } | null;
    /**
     * Timeout
     * Query timeout in seconds (1-300)
     */
    timeout?: number | null;
};

/**
 * DatabaseHealthResponse
 * Response model for database health check.
 */
export type DatabaseHealthResponse = {
    /**
     * Graph Id
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Status
     * Overall health status
     */
    status: string;
    /**
     * Connection Status
     * Database connection status
     */
    connection_status: string;
    /**
     * Uptime Seconds
     * Database uptime in seconds
     */
    uptime_seconds: number;
    /**
     * Last Query Time
     * Timestamp of last query execution
     */
    last_query_time?: string | null;
    /**
     * Query Count 24H
     * Number of queries executed in last 24 hours
     */
    query_count_24h: number;
    /**
     * Avg Query Time Ms
     * Average query execution time in milliseconds
     */
    avg_query_time_ms: number;
    /**
     * Error Rate 24H
     * Error rate in last 24 hours (percentage)
     */
    error_rate_24h: number;
    /**
     * Memory Usage Mb
     * Memory usage in MB
     */
    memory_usage_mb?: number | null;
    /**
     * Storage Usage Mb
     * Storage usage in MB
     */
    storage_usage_mb?: number | null;
    /**
     * Alerts
     * Active alerts or warnings
     */
    alerts?: Array<string>;
};

/**
 * DatabaseInfoResponse
 * Response model for database information and statistics.
 */
export type DatabaseInfoResponse = {
    /**
     * Graph Id
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Database Name
     * Database name
     */
    database_name: string;
    /**
     * Database Size Bytes
     * Database size in bytes
     */
    database_size_bytes: number;
    /**
     * Database Size Mb
     * Database size in MB
     */
    database_size_mb: number;
    /**
     * Node Count
     * Total number of nodes
     */
    node_count: number;
    /**
     * Relationship Count
     * Total number of relationships
     */
    relationship_count: number;
    /**
     * Node Labels
     * List of node labels
     */
    node_labels: Array<string>;
    /**
     * Relationship Types
     * List of relationship types
     */
    relationship_types: Array<string>;
    /**
     * Created At
     * Database creation timestamp
     */
    created_at: string;
    /**
     * Last Modified
     * Last modification timestamp
     */
    last_modified: string;
    /**
     * Schema Version
     * Schema version
     */
    schema_version?: string | null;
    /**
     * Read Only
     * Whether database is read-only
     */
    read_only: boolean;
    /**
     * Backup Count
     * Number of available backups
     */
    backup_count: number;
    /**
     * Last Backup Date
     * Date of last backup
     */
    last_backup_date?: string | null;
};

/**
 * DeleteFileResponse
 */
export type DeleteFileResponse = {
    /**
     * Status
     * Deletion status
     */
    status: string;
    /**
     * File Id
     * Deleted file ID
     */
    file_id: string;
    /**
     * File Name
     * Deleted file name
     */
    file_name: string;
    /**
     * Message
     * Operation message
     */
    message: string;
};

/**
 * DeleteSubgraphRequest
 * Request model for deleting a subgraph.
 */
export type DeleteSubgraphRequest = {
    /**
     * Force
     * Force deletion even if subgraph contains data
     */
    force?: boolean;
    /**
     * Backup First
     * Create a backup before deletion
     */
    backup_first?: boolean;
    /**
     * Backup Location
     * S3 location for backup (uses default if not specified)
     */
    backup_location?: string | null;
};

/**
 * DeleteSubgraphResponse
 * Response model for subgraph deletion.
 */
export type DeleteSubgraphResponse = {
    /**
     * Graph Id
     * Deleted subgraph identifier
     */
    graph_id: string;
    /**
     * Status
     * Deletion status
     */
    status: string;
    /**
     * Backup Location
     * Location of backup if created
     */
    backup_location?: string | null;
    /**
     * Deleted At
     * When deletion occurred
     */
    deleted_at: string;
    /**
     * Message
     * Additional information about the deletion
     */
    message?: string | null;
};

/**
 * DetailedTransactionsResponse
 * Detailed response for transaction queries.
 */
export type DetailedTransactionsResponse = {
    /**
     * Transactions
     */
    transactions: Array<EnhancedCreditTransactionResponse>;
    /**
     * Summary
     */
    summary: {
        [key: string]: TransactionSummaryResponse;
    };
    /**
     * Total Count
     */
    total_count: number;
    /**
     * Filtered Count
     */
    filtered_count: number;
    /**
     * Date Range
     */
    date_range: {
        [key: string]: string;
    };
};

/**
 * EmailVerificationRequest
 * Email verification request model.
 */
export type EmailVerificationRequest = {
    /**
     * Token
     * Email verification token from email link
     */
    token: string;
};

/**
 * EnhancedCreditTransactionResponse
 * Enhanced credit transaction response with more details.
 */
export type EnhancedCreditTransactionResponse = {
    /**
     * Id
     */
    id: string;
    /**
     * Type
     */
    type: string;
    /**
     * Amount
     */
    amount: number;
    /**
     * Description
     */
    description: string;
    /**
     * Metadata
     */
    metadata: {
        [key: string]: unknown;
    };
    /**
     * Created At
     */
    created_at: string;
    /**
     * Operation Id
     */
    operation_id?: string | null;
    /**
     * Idempotency Key
     */
    idempotency_key?: string | null;
    /**
     * Request Id
     */
    request_id?: string | null;
    /**
     * User Id
     */
    user_id?: string | null;
};

/**
 * ErrorResponse
 * Standard error response format used across all API endpoints.
 *
 * This model ensures consistent error responses for SDK generation
 * and client error handling.
 */
export type ErrorResponse = {
    /**
     * Detail
     * Human-readable error message explaining what went wrong
     */
    detail: string;
    /**
     * Code
     * Machine-readable error code for programmatic handling
     */
    code?: string | null;
    /**
     * Request Id
     * Unique request ID for tracking and debugging
     */
    request_id?: string | null;
    /**
     * Timestamp
     * Timestamp when the error occurred
     */
    timestamp?: string | null;
};

/**
 * ExchangeTokenRequest
 * Exchange temporary token for permanent credentials.
 */
export type ExchangeTokenRequest = {
    /**
     * Connection Id
     * Connection ID to update
     */
    connection_id: string;
    /**
     * Public Token
     * Temporary token from embedded auth
     */
    public_token: string;
    /**
     * Metadata
     * Provider-specific metadata
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
};

/**
 * FileInfo
 */
export type FileInfo = {
    /**
     * File Id
     * Unique file identifier
     */
    file_id: string;
    /**
     * File Name
     * Original file name
     */
    file_name: string;
    /**
     * File Format
     * File format (parquet, csv, etc.)
     */
    file_format: string;
    /**
     * Size Bytes
     * File size in bytes
     */
    size_bytes: number;
    /**
     * Row Count
     * Estimated row count
     */
    row_count?: number | null;
    /**
     * Upload Status
     * Current upload status
     */
    upload_status: string;
    /**
     * Upload Method
     * Upload method used
     */
    upload_method: string;
    /**
     * Created At
     * File creation timestamp
     */
    created_at?: string | null;
    /**
     * Uploaded At
     * File upload completion timestamp
     */
    uploaded_at?: string | null;
    /**
     * S3 Key
     * S3 object key
     */
    s3_key: string;
};

/**
 * FileStatusUpdate
 */
export type FileStatusUpdate = {
    /**
     * Status
     * File status: 'uploaded' (ready for ingest), 'disabled' (exclude from ingest), 'archived' (soft deleted)
     */
    status: string;
};

/**
 * FileUploadRequest
 */
export type FileUploadRequest = {
    /**
     * File Name
     * File name to upload
     */
    file_name: string;
    /**
     * Content Type
     * File MIME type
     */
    content_type?: string;
};

/**
 * FileUploadResponse
 */
export type FileUploadResponse = {
    /**
     * Upload Url
     * Presigned S3 upload URL
     */
    upload_url: string;
    /**
     * Expires In
     * URL expiration time in seconds
     */
    expires_in: number;
    /**
     * File Id
     * File tracking ID
     */
    file_id: string;
    /**
     * S3 Key
     * S3 object key
     */
    s3_key: string;
};

/**
 * ForgotPasswordRequest
 * Forgot password request model.
 */
export type ForgotPasswordRequest = {
    /**
     * Email
     * Email address to send reset link
     */
    email: string;
};

/**
 * GetFileInfoResponse
 */
export type GetFileInfoResponse = {
    /**
     * File Id
     * Unique file identifier
     */
    file_id: string;
    /**
     * Graph Id
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Table Id
     * Table identifier
     */
    table_id: string;
    /**
     * Table Name
     * Table name
     */
    table_name?: string | null;
    /**
     * File Name
     * Original file name
     */
    file_name: string;
    /**
     * File Format
     * File format (parquet, csv, etc.)
     */
    file_format: string;
    /**
     * Size Bytes
     * File size in bytes
     */
    size_bytes: number;
    /**
     * Row Count
     * Estimated row count
     */
    row_count?: number | null;
    /**
     * Upload Status
     * Current upload status
     */
    upload_status: string;
    /**
     * Upload Method
     * Upload method used
     */
    upload_method: string;
    /**
     * Created At
     * File creation timestamp
     */
    created_at?: string | null;
    /**
     * Uploaded At
     * File upload completion timestamp
     */
    uploaded_at?: string | null;
    /**
     * S3 Key
     * S3 object key
     */
    s3_key: string;
};

/**
 * GraphInfo
 * Graph information for user.
 */
export type GraphInfo = {
    /**
     * Graphid
     * Graph database identifier
     */
    graphId: string;
    /**
     * Graphname
     * Display name for the graph
     */
    graphName: string;
    /**
     * Role
     * User's role in this graph
     */
    role: string;
    /**
     * Isselected
     * Whether this is the currently selected graph
     */
    isSelected: boolean;
    /**
     * Createdat
     * Creation timestamp
     */
    createdAt: string;
};

/**
 * GraphMetadata
 * Metadata for graph creation.
 */
export type GraphMetadata = {
    /**
     * Graph Name
     * Display name for the graph
     */
    graph_name: string;
    /**
     * Description
     * Optional description
     */
    description?: string | null;
    /**
     * Schema Extensions
     * Schema extensions to enable
     */
    schema_extensions?: Array<string>;
    /**
     * Tags
     * Tags for organizing graphs
     */
    tags?: Array<string>;
};

/**
 * GraphMetricsResponse
 * Response model for graph metrics.
 */
export type GraphMetricsResponse = {
    /**
     * Graph Id
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Graph Name
     * Display name for the graph
     */
    graph_name?: string | null;
    /**
     * User Role
     * User's role in this graph
     */
    user_role?: string | null;
    /**
     * Timestamp
     * Metrics collection timestamp
     */
    timestamp: string;
    /**
     * Total Nodes
     * Total number of nodes
     */
    total_nodes: number;
    /**
     * Total Relationships
     * Total number of relationships
     */
    total_relationships: number;
    /**
     * Node Counts
     * Node counts by label
     */
    node_counts: {
        [key: string]: number;
    };
    /**
     * Relationship Counts
     * Relationship counts by type
     */
    relationship_counts: {
        [key: string]: number;
    };
    /**
     * Estimated Size
     * Database size estimates
     */
    estimated_size: {
        [key: string]: unknown;
    };
    /**
     * Health Status
     * Database health information
     */
    health_status: {
        [key: string]: unknown;
    };
};

/**
 * GraphUsageResponse
 * Response model for graph usage statistics.
 */
export type GraphUsageResponse = {
    /**
     * Graph Id
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Storage Usage
     * Storage usage information
     */
    storage_usage: {
        [key: string]: unknown;
    };
    /**
     * Query Statistics
     * Query statistics
     */
    query_statistics: {
        [key: string]: unknown;
    };
    /**
     * Recent Activity
     * Recent activity summary
     */
    recent_activity: {
        [key: string]: unknown;
    };
    /**
     * Timestamp
     * Usage collection timestamp
     */
    timestamp: string;
};

/**
 * HTTPValidationError
 */
export type HttpValidationError = {
    /**
     * Detail
     */
    detail?: Array<ValidationError>;
};

/**
 * HealthStatus
 * Health check status information.
 */
export type HealthStatus = {
    /**
     * Status
     * Current health status
     */
    status: string;
    /**
     * Timestamp
     * Time of health check
     */
    timestamp: string;
    /**
     * Details
     * Additional health check details
     */
    details?: {
        [key: string]: unknown;
    } | null;
};

/**
 * InitialEntityData
 * Initial entity data for graph creation.
 */
export type InitialEntityData = {
    /**
     * Name
     * Entity name
     */
    name: string;
    /**
     * Uri
     * Entity website or URI
     */
    uri: string;
    /**
     * Cik
     * CIK number for SEC filings
     */
    cik?: string | null;
    /**
     * Sic
     * SIC code
     */
    sic?: string | null;
    /**
     * Sic Description
     * SIC description
     */
    sic_description?: string | null;
    /**
     * Category
     * Business category
     */
    category?: string | null;
    /**
     * State Of Incorporation
     * State of incorporation
     */
    state_of_incorporation?: string | null;
    /**
     * Fiscal Year End
     * Fiscal year end (MMDD)
     */
    fiscal_year_end?: string | null;
    /**
     * Ein
     * Employer Identification Number
     */
    ein?: string | null;
};

/**
 * LinkTokenRequest
 * Request to create a link token for embedded authentication.
 */
export type LinkTokenRequest = {
    /**
     * Entity Id
     * Entity identifier
     */
    entity_id: string;
    /**
     * User Id
     * User identifier
     */
    user_id: string;
    /**
     * Provider
     * Provider type (defaults based on connection)
     */
    provider?: ('sec' | 'quickbooks' | 'plaid') | null;
    /**
     * Products
     * Data products to request (provider-specific)
     */
    products?: Array<string> | null;
    /**
     * Options
     * Provider-specific options
     */
    options?: {
        [key: string]: unknown;
    } | null;
};

/**
 * ListSubgraphsResponse
 * Response model for listing subgraphs.
 */
export type ListSubgraphsResponse = {
    /**
     * Parent Graph Id
     * Parent graph identifier
     */
    parent_graph_id: string;
    /**
     * Parent Graph Name
     * Parent graph name
     */
    parent_graph_name: string;
    /**
     * Parent Graph Tier
     * Parent graph tier
     */
    parent_graph_tier: string;
    /**
     * Subgraph Count
     * Total number of subgraphs
     */
    subgraph_count: number;
    /**
     * Max Subgraphs
     * Maximum allowed subgraphs for this tier (None = unlimited)
     */
    max_subgraphs?: number | null;
    /**
     * Total Size Mb
     * Combined size of all subgraphs in megabytes
     */
    total_size_mb?: number | null;
    /**
     * Subgraphs
     * List of subgraphs
     */
    subgraphs: Array<SubgraphSummary>;
};

/**
 * ListTableFilesResponse
 */
export type ListTableFilesResponse = {
    /**
     * Graph Id
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Table Name
     * Table name
     */
    table_name: string;
    /**
     * Files
     * List of files in the table
     */
    files: Array<FileInfo>;
    /**
     * Total Files
     * Total number of files
     */
    total_files: number;
    /**
     * Total Size Bytes
     * Total size of all files in bytes
     */
    total_size_bytes: number;
};

/**
 * LoginRequest
 * Login request model.
 */
export type LoginRequest = {
    /**
     * Email
     * User's email address
     */
    email: string;
    /**
     * Password
     * User's password
     */
    password: string;
};

/**
 * MCPToolCall
 * Request model for MCP tool execution.
 */
export type McpToolCall = {
    /**
     * Name
     * Name of the MCP tool to execute
     */
    name: string;
    /**
     * Arguments
     * Arguments to pass to the tool
     */
    arguments?: {
        [key: string]: unknown;
    };
};

/**
 * MCPToolsResponse
 * Response model for MCP tools listing.
 */
export type McpToolsResponse = {
    /**
     * Tools
     * List of available MCP tools with their schemas
     */
    tools: Array<{
        [key: string]: unknown;
    }>;
};

/**
 * OAuthCallbackRequest
 * OAuth callback parameters.
 */
export type OAuthCallbackRequest = {
    /**
     * Code
     * Authorization code from OAuth provider
     */
    code: string;
    /**
     * State
     * OAuth state for verification
     */
    state: string;
    /**
     * Realm Id
     * QuickBooks-specific realm ID
     */
    realm_id?: string | null;
    /**
     * Error
     * OAuth error if authorization failed
     */
    error?: string | null;
    /**
     * Error Description
     * OAuth error details
     */
    error_description?: string | null;
};

/**
 * OAuthInitRequest
 * Request to initiate OAuth flow.
 */
export type OAuthInitRequest = {
    /**
     * Connection Id
     * Connection ID to link OAuth to
     */
    connection_id: string;
    /**
     * Redirect Uri
     * Override default redirect URI
     */
    redirect_uri?: string | null;
    /**
     * Additional Params
     * Provider-specific parameters
     */
    additional_params?: {
        [key: string]: string;
    } | null;
};

/**
 * OAuthInitResponse
 * Response with OAuth authorization URL.
 */
export type OAuthInitResponse = {
    /**
     * Auth Url
     * URL to redirect user for authorization
     */
    auth_url: string;
    /**
     * State
     * OAuth state for security
     */
    state: string;
    /**
     * Expires At
     * When this OAuth request expires
     */
    expires_at: string;
};

/**
 * PasswordCheckRequest
 * Password strength check request model.
 */
export type PasswordCheckRequest = {
    /**
     * Password
     * Password to check
     */
    password: string;
    /**
     * Email
     * User email for personalization checks
     */
    email?: string | null;
};

/**
 * PasswordCheckResponse
 * Password strength check response model.
 */
export type PasswordCheckResponse = {
    /**
     * Is Valid
     * Whether password meets requirements
     */
    is_valid: boolean;
    /**
     * Strength
     * Password strength level
     */
    strength: string;
    /**
     * Score
     * Password strength score (0-100)
     */
    score: number;
    /**
     * Errors
     * Validation errors
     */
    errors: Array<string>;
    /**
     * Suggestions
     * Improvement suggestions
     */
    suggestions: Array<string>;
    /**
     * Character Types
     * Character type analysis
     */
    character_types: {
        [key: string]: boolean;
    };
};

/**
 * PasswordPolicyResponse
 * Password policy response model.
 */
export type PasswordPolicyResponse = {
    /**
     * Policy
     * Current password policy requirements
     */
    policy: {
        [key: string]: unknown;
    };
};

/**
 * PlaidConnectionConfig
 * Plaid-specific connection configuration.
 */
export type PlaidConnectionConfig = {
    /**
     * Public Token
     * Plaid public token for exchange
     */
    public_token?: string | null;
    /**
     * Access Token
     * Plaid access token (set after exchange)
     */
    access_token?: string | null;
    /**
     * Item Id
     * Plaid item ID
     */
    item_id?: string | null;
    /**
     * Institution
     * Institution information
     */
    institution?: {
        [key: string]: unknown;
    } | null;
    /**
     * Accounts
     * Connected accounts
     */
    accounts?: Array<{
        [key: string]: unknown;
    }> | null;
};

/**
 * QuickBooksConnectionConfig
 * QuickBooks-specific connection configuration.
 */
export type QuickBooksConnectionConfig = {
    /**
     * Realm Id
     * QuickBooks Realm ID
     */
    realm_id?: string | null;
    /**
     * Refresh Token
     * OAuth refresh token
     */
    refresh_token?: string | null;
};

/**
 * RegisterRequest
 * Registration request model.
 */
export type RegisterRequest = {
    /**
     * Name
     * User's display name
     */
    name: string;
    /**
     * Email
     * User's email address
     */
    email: string;
    /**
     * Password
     * User's password (must meet security requirements)
     */
    password: string;
    /**
     * Captcha Token
     * CAPTCHA verification token (required in production)
     */
    captcha_token?: string | null;
};

/**
 * RepositoryCreditsResponse
 * Response for repository-specific credits.
 */
export type RepositoryCreditsResponse = {
    /**
     * Repository
     * Repository identifier
     */
    repository: string;
    /**
     * Has Access
     * Whether user has access
     */
    has_access: boolean;
    /**
     * Message
     * Access message
     */
    message?: string | null;
    /**
     * Credit summary if access available
     */
    credits?: CreditSummary | null;
};

/**
 * RepositoryPlan
 * Repository access plans for shared data.
 */
export type RepositoryPlan = 'starter' | 'advanced' | 'unlimited';

/**
 * RepositoryType
 * Types of shared repositories.
 */
export type RepositoryType = 'sec' | 'industry' | 'economic';

/**
 * ResetPasswordRequest
 * Reset password request model.
 */
export type ResetPasswordRequest = {
    /**
     * Token
     * Password reset token from email link
     */
    token: string;
    /**
     * New Password
     * New password (must meet security requirements)
     */
    new_password: string;
};

/**
 * ResetPasswordValidateResponse
 * Password reset token validation response model.
 */
export type ResetPasswordValidateResponse = {
    /**
     * Valid
     * Whether the token is valid
     */
    valid: boolean;
    /**
     * Email
     * Masked email address if token is valid
     */
    email?: string | null;
};

/**
 * ResponseMode
 * Response modes for execution.
 */
export type ResponseMode = 'auto' | 'sync' | 'async' | 'stream';

/**
 * SECConnectionConfig
 * SEC-specific connection configuration.
 */
export type SecConnectionConfig = {
    /**
     * Cik
     * 10-digit CIK number
     */
    cik: string;
    /**
     * Entity Name
     * Entity name from SEC
     */
    entity_name?: string | null;
};

/**
 * SSOCompleteRequest
 * SSO completion request model.
 */
export type SsoCompleteRequest = {
    /**
     * Session Id
     * Temporary session ID from secure handoff
     */
    session_id: string;
};

/**
 * SSOExchangeRequest
 * SSO token exchange request model.
 */
export type SsoExchangeRequest = {
    /**
     * Token
     * Temporary SSO token
     */
    token: string;
    /**
     * Target App
     * Target application identifier
     */
    target_app: string;
    /**
     * Return Url
     * Optional return URL after authentication
     */
    return_url?: string | null;
};

/**
 * SSOExchangeResponse
 * SSO token exchange response model.
 */
export type SsoExchangeResponse = {
    /**
     * Session Id
     * Temporary session ID for secure handoff
     */
    session_id: string;
    /**
     * Redirect Url
     * URL to redirect to for authentication
     */
    redirect_url: string;
    /**
     * Expires At
     * Session expiration time
     */
    expires_at: string;
};

/**
 * SSOTokenResponse
 * SSO token response model.
 */
export type SsoTokenResponse = {
    /**
     * Token
     * Temporary SSO token for cross-app authentication
     */
    token: string;
    /**
     * Expires At
     * Token expiration time
     */
    expires_at: string;
    /**
     * Apps
     * Available apps for this user
     */
    apps: Array<string>;
};

/**
 * SchemaExportResponse
 * Response model for schema export.
 */
export type SchemaExportResponse = {
    /**
     * Graph Id
     * Graph ID
     */
    graph_id: string;
    /**
     * Schema Definition
     * Exported schema definition
     */
    schema_definition: {
        [key: string]: unknown;
    } | string;
    /**
     * Format
     * Export format used
     */
    format: string;
    /**
     * Exported At
     * Export timestamp
     */
    exported_at: string;
    /**
     * Data Stats
     * Data statistics if requested
     */
    data_stats?: {
        [key: string]: unknown;
    } | null;
};

/**
 * SchemaValidationRequest
 * Request model for schema validation.
 */
export type SchemaValidationRequest = {
    /**
     * Schema Definition
     * Schema definition as JSON dict or JSON/YAML string
     */
    schema_definition: {
        [key: string]: unknown;
    } | string;
    /**
     * Format
     * Schema format: json, yaml, or dict
     */
    format?: string;
    /**
     * Check Compatibility
     * List of existing schema extensions to check compatibility with
     */
    check_compatibility?: Array<string> | null;
};

/**
 * SchemaValidationResponse
 * Response model for schema validation.
 */
export type SchemaValidationResponse = {
    /**
     * Valid
     * Whether the schema is valid
     */
    valid: boolean;
    /**
     * Message
     * Validation message
     */
    message: string;
    /**
     * Errors
     * List of validation errors
     */
    errors?: Array<string> | null;
    /**
     * Warnings
     * List of warnings
     */
    warnings?: Array<string> | null;
    /**
     * Stats
     * Schema statistics (nodes, relationships, properties)
     */
    stats?: {
        [key: string]: number;
    } | null;
    /**
     * Compatibility
     * Compatibility check results if requested
     */
    compatibility?: {
        [key: string]: unknown;
    } | null;
};

/**
 * SelectionCriteria
 * Criteria for agent selection.
 */
export type SelectionCriteria = {
    /**
     * Min Confidence
     * Minimum confidence score
     */
    min_confidence?: number;
    /**
     * Required Capabilities
     * Required agent capabilities
     */
    required_capabilities?: Array<string>;
    /**
     * Preferred execution mode
     */
    preferred_mode?: AgentMode | null;
    /**
     * Max Response Time
     * Maximum response time in seconds
     */
    max_response_time?: number;
    /**
     * Excluded Agents
     * Agents to exclude from selection
     */
    excluded_agents?: Array<string>;
};

/**
 * StorageLimitResponse
 * Storage limit information response.
 */
export type StorageLimitResponse = {
    /**
     * Graph Id
     */
    graph_id: string;
    /**
     * Current Storage Gb
     */
    current_storage_gb: number;
    /**
     * Effective Limit Gb
     */
    effective_limit_gb: number;
    /**
     * Usage Percentage
     */
    usage_percentage: number;
    /**
     * Within Limit
     */
    within_limit: boolean;
    /**
     * Approaching Limit
     */
    approaching_limit: boolean;
    /**
     * Needs Warning
     */
    needs_warning: boolean;
    /**
     * Has Override
     */
    has_override: boolean;
    /**
     * Recommendations
     */
    recommendations?: Array<string> | null;
};

/**
 * SubgraphQuotaResponse
 * Response model for subgraph quota information.
 */
export type SubgraphQuotaResponse = {
    /**
     * Parent Graph Id
     * Parent graph identifier
     */
    parent_graph_id: string;
    /**
     * Tier
     * Graph tier
     */
    tier: string;
    /**
     * Current Count
     * Current number of subgraphs
     */
    current_count: number;
    /**
     * Max Allowed
     * Maximum allowed subgraphs (None = unlimited)
     */
    max_allowed?: number | null;
    /**
     * Remaining
     * Remaining subgraphs that can be created
     */
    remaining?: number | null;
    /**
     * Total Size Mb
     * Total size of all subgraphs
     */
    total_size_mb?: number | null;
    /**
     * Max Size Mb
     * Maximum allowed total size
     */
    max_size_mb?: number | null;
};

/**
 * SubgraphResponse
 * Response model for a subgraph.
 */
export type SubgraphResponse = {
    /**
     * Graph Id
     * Full subgraph identifier (e.g., kg123_dev)
     */
    graph_id: string;
    /**
     * Parent Graph Id
     * Parent graph identifier
     */
    parent_graph_id: string;
    /**
     * Subgraph Index
     * Numeric index of the subgraph
     */
    subgraph_index: number;
    /**
     * Subgraph Name
     * Alphanumeric name of the subgraph
     */
    subgraph_name: string;
    /**
     * Display Name
     * Human-readable display name
     */
    display_name: string;
    /**
     * Description
     * Description of the subgraph's purpose
     */
    description?: string | null;
    /**
     * Type of subgraph
     */
    subgraph_type: SubgraphType;
    /**
     * Status
     * Current status of the subgraph
     */
    status: string;
    /**
     * Created At
     * When the subgraph was created
     */
    created_at: string;
    /**
     * Updated At
     * When the subgraph was last updated
     */
    updated_at: string;
    /**
     * Size Mb
     * Size of the subgraph database in megabytes
     */
    size_mb?: number | null;
    /**
     * Node Count
     * Number of nodes in the subgraph
     */
    node_count?: number | null;
    /**
     * Edge Count
     * Number of edges in the subgraph
     */
    edge_count?: number | null;
    /**
     * Last Accessed
     * When the subgraph was last accessed
     */
    last_accessed?: string | null;
    /**
     * Metadata
     * Additional metadata for the subgraph
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
};

/**
 * SubgraphSummary
 * Summary model for listing subgraphs.
 */
export type SubgraphSummary = {
    /**
     * Graph Id
     * Full subgraph identifier
     */
    graph_id: string;
    /**
     * Subgraph Name
     * Alphanumeric name
     */
    subgraph_name: string;
    /**
     * Display Name
     * Human-readable name
     */
    display_name: string;
    /**
     * Type of subgraph
     */
    subgraph_type: SubgraphType;
    /**
     * Status
     * Current status
     */
    status: string;
    /**
     * Size Mb
     * Size in megabytes
     */
    size_mb?: number | null;
    /**
     * Created At
     * Creation timestamp
     */
    created_at: string;
    /**
     * Last Accessed
     * Last access timestamp
     */
    last_accessed?: string | null;
};

/**
 * SubgraphType
 * Types of subgraphs.
 */
export type SubgraphType = 'static' | 'temporal' | 'versioned' | 'memory';

/**
 * SubscriptionInfo
 * User subscription information.
 */
export type SubscriptionInfo = {
    /**
     * Id
     * Subscription ID
     */
    id: string;
    /**
     * User Id
     * User ID
     */
    user_id: string;
    /**
     * Addon Type
     * Add-on type
     */
    addon_type: string;
    /**
     * Addon Tier
     * Subscription tier
     */
    addon_tier: string;
    /**
     * Is Active
     * Whether subscription is active
     */
    is_active: boolean;
    /**
     * Activated At
     * Activation date (ISO format)
     */
    activated_at: string;
    /**
     * Expires At
     * Expiration date (ISO format)
     */
    expires_at?: string | null;
    /**
     * Monthly Price Cents
     * Monthly price in cents
     */
    monthly_price_cents: number;
    /**
     * Features
     * List of features
     */
    features: Array<string>;
    /**
     * Metadata
     * Additional metadata
     */
    metadata: {
        [key: string]: unknown;
    };
};

/**
 * SubscriptionRequest
 * Request to create a new subscription.
 */
export type SubscriptionRequest = {
    /**
     * Type of repository to subscribe to
     */
    repository_type: RepositoryType;
    /**
     * Repository plan
     */
    repository_plan?: RepositoryPlan;
};

/**
 * SubscriptionResponse
 * Response for subscription creation.
 */
export type SubscriptionResponse = {
    /**
     * Message
     * Success message
     */
    message: string;
    /**
     * Created subscription details
     */
    subscription: SubscriptionInfo;
};

/**
 * SuccessResponse
 * Standard success response for operations without specific return data.
 */
export type SuccessResponse = {
    /**
     * Success
     * Indicates the operation completed successfully
     */
    success?: boolean;
    /**
     * Message
     * Human-readable success message
     */
    message: string;
    /**
     * Data
     * Optional additional data related to the operation
     */
    data?: {
        [key: string]: unknown;
    } | null;
};

/**
 * SyncConnectionRequest
 * Request to sync a connection.
 */
export type SyncConnectionRequest = {
    /**
     * Full Sync
     * Perform full sync vs incremental
     */
    full_sync?: boolean;
    /**
     * Sync Options
     * Provider-specific sync options
     */
    sync_options?: {
        [key: string]: unknown;
    } | null;
};

/**
 * TableInfo
 */
export type TableInfo = {
    /**
     * Table Name
     * Table name
     */
    table_name: string;
    /**
     * Row Count
     * Approximate row count
     */
    row_count: number;
    /**
     * File Count
     * Number of files
     */
    file_count?: number;
    /**
     * Total Size Bytes
     * Total size in bytes
     */
    total_size_bytes?: number;
    /**
     * S3 Location
     * S3 location for external tables
     */
    s3_location?: string | null;
};

/**
 * TableIngestResult
 */
export type TableIngestResult = {
    /**
     * Table Name
     * Table name
     */
    table_name: string;
    /**
     * Status
     * Ingestion status (success/failed/skipped)
     */
    status: string;
    /**
     * Rows Ingested
     * Number of rows ingested
     */
    rows_ingested?: number;
    /**
     * Execution Time Ms
     * Ingestion time in milliseconds
     */
    execution_time_ms?: number;
    /**
     * Error
     * Error message if failed
     */
    error?: string | null;
};

/**
 * TableListResponse
 */
export type TableListResponse = {
    /**
     * Tables
     * List of tables
     */
    tables: Array<TableInfo>;
    /**
     * Total Count
     * Total number of tables
     */
    total_count: number;
};

/**
 * TableQueryRequest
 */
export type TableQueryRequest = {
    /**
     * Sql
     * SQL query to execute on staging tables
     */
    sql: string;
};

/**
 * TableQueryResponse
 */
export type TableQueryResponse = {
    /**
     * Columns
     * Column names
     */
    columns: Array<string>;
    /**
     * Rows
     * Query results
     */
    rows: Array<Array<unknown>>;
    /**
     * Row Count
     * Number of rows returned
     */
    row_count: number;
    /**
     * Execution Time Ms
     * Query execution time
     */
    execution_time_ms: number;
};

/**
 * TierUpgradeRequest
 * Request to upgrade subscription tier.
 */
export type TierUpgradeRequest = {
    /**
     * New repository plan
     */
    new_plan: RepositoryPlan;
};

/**
 * TransactionSummaryResponse
 * Summary of transactions by operation type.
 */
export type TransactionSummaryResponse = {
    /**
     * Operation Type
     */
    operation_type: string;
    /**
     * Total Amount
     */
    total_amount: number;
    /**
     * Transaction Count
     */
    transaction_count: number;
    /**
     * Average Amount
     */
    average_amount: number;
    /**
     * First Transaction
     */
    first_transaction?: string | null;
    /**
     * Last Transaction
     */
    last_transaction?: string | null;
};

/**
 * UpdateAPIKeyRequest
 * Request model for updating an API key.
 */
export type UpdateApiKeyRequest = {
    /**
     * Name
     * New name for the API key
     */
    name?: string | null;
    /**
     * Description
     * New description
     */
    description?: string | null;
};

/**
 * UpdatePasswordRequest
 * Request model for updating user password.
 */
export type UpdatePasswordRequest = {
    /**
     * Current Password
     * Current password
     */
    current_password: string;
    /**
     * New Password
     * New password
     */
    new_password: string;
    /**
     * Confirm Password
     * Confirm new password
     */
    confirm_password: string;
};

/**
 * UpdateUserRequest
 * Request model for updating user profile.
 */
export type UpdateUserRequest = {
    /**
     * Name
     * User's display name
     */
    name?: string | null;
    /**
     * Email
     * User's email address
     */
    email?: string | null;
};

/**
 * UserAnalyticsResponse
 * Response model for comprehensive user analytics.
 */
export type UserAnalyticsResponse = {
    /**
     * User Info
     * User information
     */
    user_info: {
        [key: string]: unknown;
    };
    /**
     * Graph Usage
     * Graph usage statistics
     */
    graph_usage: {
        [key: string]: unknown;
    };
    /**
     * Api Usage
     * API usage statistics
     */
    api_usage: {
        [key: string]: unknown;
    };
    /**
     * Limits
     * Current limits and restrictions
     */
    limits: {
        [key: string]: unknown;
    };
    /**
     * Recent Activity
     * Recent user activity
     */
    recent_activity: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Timestamp
     * Analytics generation timestamp
     */
    timestamp: string;
};

/**
 * UserGraphSummary
 * Summary of a single graph for user analytics.
 */
export type UserGraphSummary = {
    /**
     * Graph Id
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Graph Name
     * Display name for the graph
     */
    graph_name?: string | null;
    /**
     * Role
     * User's role in this graph
     */
    role: string;
    /**
     * Total Nodes
     * Total number of nodes
     */
    total_nodes: number;
    /**
     * Total Relationships
     * Total number of relationships
     */
    total_relationships: number;
    /**
     * Estimated Size Mb
     * Estimated database size in MB
     */
    estimated_size_mb: number;
    /**
     * Last Accessed
     * Last access timestamp
     */
    last_accessed?: string | null;
};

/**
 * UserGraphsResponse
 * User graphs response model.
 */
export type UserGraphsResponse = {
    /**
     * Graphs
     * List of accessible graphs
     */
    graphs: Array<GraphInfo>;
    /**
     * Selectedgraphid
     * Currently selected graph ID
     */
    selectedGraphId?: string | null;
};

/**
 * UserLimitsResponse
 * Response model for user limits information.
 *
 * UserLimits is now a simple safety valve to prevent runaway graph creation.
 * Subscription tiers and rate limits are handled at the graph level.
 */
export type UserLimitsResponse = {
    /**
     * Id
     * Unique limits identifier
     */
    id: string;
    /**
     * User Id
     * Associated user ID
     */
    user_id: string;
    /**
     * Max User Graphs
     * Maximum number of user graphs allowed (safety limit)
     */
    max_user_graphs: number;
    /**
     * Created At
     * Limits creation timestamp
     */
    created_at: string;
    /**
     * Updated At
     * Last update timestamp
     */
    updated_at: string;
};

/**
 * UserResponse
 * User information response model.
 */
export type UserResponse = {
    /**
     * Id
     * Unique identifier for the user
     */
    id: string;
    /**
     * Name
     * User's display name
     */
    name?: string | null;
    /**
     * Email
     * User's email address
     */
    email?: string | null;
    /**
     * Accounts
     * User's authentication accounts
     */
    accounts?: Array<AccountInfo>;
};

/**
 * UserSubscriptionsResponse
 * Response for user subscriptions.
 */
export type UserSubscriptionsResponse = {
    /**
     * Subscriptions
     * List of user subscriptions
     */
    subscriptions: Array<SubscriptionInfo>;
    /**
     * Total Count
     * Total number of subscriptions
     */
    total_count: number;
    /**
     * Active Count
     * Number of active subscriptions
     */
    active_count: number;
};

/**
 * UserUsageResponse
 * Response model for user usage statistics.
 *
 * Simplified to only show graph usage as UserLimits is now just a safety valve.
 * Other usage tracking (MCP, Agent calls) happens at the graph level.
 */
export type UserUsageResponse = {
    /**
     * User Id
     * User identifier
     */
    user_id: string;
    /**
     * Graphs
     * Graph usage statistics (current/limit/remaining)
     */
    graphs: {
        [key: string]: unknown;
    };
    /**
     * Current user limits
     */
    limits: UserLimitsResponse;
};

/**
 * UserUsageSummaryResponse
 * Response model for user usage summary.
 */
export type UserUsageSummaryResponse = {
    /**
     * User Id
     * User identifier
     */
    user_id: string;
    /**
     * Graph Count
     * Number of accessible graphs
     */
    graph_count: number;
    /**
     * Total Nodes
     * Total nodes across all graphs
     */
    total_nodes: number;
    /**
     * Total Relationships
     * Total relationships across all graphs
     */
    total_relationships: number;
    /**
     * Usage Vs Limits
     * Usage compared to limits
     */
    usage_vs_limits: {
        [key: string]: unknown;
    };
    /**
     * Graphs
     * Summary of each graph
     */
    graphs: Array<UserGraphSummary>;
    /**
     * Timestamp
     * Summary generation timestamp
     */
    timestamp: string;
};

/**
 * ValidationError
 */
export type ValidationError = {
    /**
     * Location
     */
    loc: Array<string | number>;
    /**
     * Message
     */
    msg: string;
    /**
     * Error Type
     */
    type: string;
};

export type RegisterUserData = {
    body: RegisterRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/register';
};

export type RegisterUserErrors = {
    /**
     * Invalid request data or missing CAPTCHA token (production only)
     */
    400: ErrorResponse;
    /**
     * Email already registered
     */
    409: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Registration temporarily disabled
     */
    503: ErrorResponse;
};

export type RegisterUserError = RegisterUserErrors[keyof RegisterUserErrors];

export type RegisterUserResponses = {
    /**
     * Successful Response
     */
    201: AuthResponse;
};

export type RegisterUserResponse = RegisterUserResponses[keyof RegisterUserResponses];

export type LoginUserData = {
    body: LoginRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/login';
};

export type LoginUserErrors = {
    /**
     * Invalid request data
     */
    400: ErrorResponse;
    /**
     * Invalid credentials
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type LoginUserError = LoginUserErrors[keyof LoginUserErrors];

export type LoginUserResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type LoginUserResponse = LoginUserResponses[keyof LoginUserResponses];

export type LogoutUserData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: never;
    url: '/v1/auth/logout';
};

export type LogoutUserErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type LogoutUserError = LogoutUserErrors[keyof LogoutUserErrors];

export type LogoutUserResponses = {
    /**
     * Response Logoutuser
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type LogoutUserResponse = LogoutUserResponses[keyof LogoutUserResponses];

export type GetCurrentAuthUserData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: never;
    url: '/v1/auth/me';
};

export type GetCurrentAuthUserErrors = {
    /**
     * Not authenticated
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetCurrentAuthUserError = GetCurrentAuthUserErrors[keyof GetCurrentAuthUserErrors];

export type GetCurrentAuthUserResponses = {
    /**
     * Response Getcurrentauthuser
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetCurrentAuthUserResponse = GetCurrentAuthUserResponses[keyof GetCurrentAuthUserResponses];

export type RefreshAuthSessionData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: never;
    url: '/v1/auth/refresh';
};

export type RefreshAuthSessionErrors = {
    /**
     * Not authenticated
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type RefreshAuthSessionError = RefreshAuthSessionErrors[keyof RefreshAuthSessionErrors];

export type RefreshAuthSessionResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type RefreshAuthSessionResponse = RefreshAuthSessionResponses[keyof RefreshAuthSessionResponses];

export type ResendVerificationEmailData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: never;
    url: '/v1/auth/email/resend';
};

export type ResendVerificationEmailErrors = {
    /**
     * Email already verified
     */
    400: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: ErrorResponse;
    /**
     * Email service unavailable
     */
    503: ErrorResponse;
};

export type ResendVerificationEmailError = ResendVerificationEmailErrors[keyof ResendVerificationEmailErrors];

export type ResendVerificationEmailResponses = {
    /**
     * Response Resendverificationemail
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type ResendVerificationEmailResponse = ResendVerificationEmailResponses[keyof ResendVerificationEmailResponses];

export type VerifyEmailData = {
    body: EmailVerificationRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/email/verify';
};

export type VerifyEmailErrors = {
    /**
     * Invalid or expired token
     */
    400: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type VerifyEmailError = VerifyEmailErrors[keyof VerifyEmailErrors];

export type VerifyEmailResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type VerifyEmailResponse = VerifyEmailResponses[keyof VerifyEmailResponses];

export type GetPasswordPolicyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/password/policy';
};

export type GetPasswordPolicyResponses = {
    /**
     * Password policy requirements
     */
    200: PasswordPolicyResponse;
};

export type GetPasswordPolicyResponse = GetPasswordPolicyResponses[keyof GetPasswordPolicyResponses];

export type CheckPasswordStrengthData = {
    body: PasswordCheckRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/password/check';
};

export type CheckPasswordStrengthErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CheckPasswordStrengthError = CheckPasswordStrengthErrors[keyof CheckPasswordStrengthErrors];

export type CheckPasswordStrengthResponses = {
    /**
     * Password strength analysis
     */
    200: PasswordCheckResponse;
};

export type CheckPasswordStrengthResponse = CheckPasswordStrengthResponses[keyof CheckPasswordStrengthResponses];

export type ForgotPasswordData = {
    body: ForgotPasswordRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/password/forgot';
};

export type ForgotPasswordErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: ErrorResponse;
};

export type ForgotPasswordError = ForgotPasswordErrors[keyof ForgotPasswordErrors];

export type ForgotPasswordResponses = {
    /**
     * Response Forgotpassword
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type ForgotPasswordResponse = ForgotPasswordResponses[keyof ForgotPasswordResponses];

export type ValidateResetTokenData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Token
         * Password reset token
         */
        token: string;
    };
    url: '/v1/auth/password/reset/validate';
};

export type ValidateResetTokenErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ValidateResetTokenError = ValidateResetTokenErrors[keyof ValidateResetTokenErrors];

export type ValidateResetTokenResponses = {
    /**
     * Successful Response
     */
    200: ResetPasswordValidateResponse;
};

export type ValidateResetTokenResponse = ValidateResetTokenResponses[keyof ValidateResetTokenResponses];

export type ResetPasswordData = {
    body: ResetPasswordRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/password/reset';
};

export type ResetPasswordErrors = {
    /**
     * Invalid token or password
     */
    400: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ResetPasswordError = ResetPasswordErrors[keyof ResetPasswordErrors];

export type ResetPasswordResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type ResetPasswordResponse = ResetPasswordResponses[keyof ResetPasswordResponses];

export type GenerateSsoTokenData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: never;
    url: '/v1/auth/sso-token';
};

export type GenerateSsoTokenErrors = {
    /**
     * Not authenticated
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GenerateSsoTokenError = GenerateSsoTokenErrors[keyof GenerateSsoTokenErrors];

export type GenerateSsoTokenResponses = {
    /**
     * Successful Response
     */
    200: SsoTokenResponse;
};

export type GenerateSsoTokenResponse = GenerateSsoTokenResponses[keyof GenerateSsoTokenResponses];

export type SsoTokenExchangeData = {
    body: SsoExchangeRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/sso-exchange';
};

export type SsoTokenExchangeErrors = {
    /**
     * Invalid request data
     */
    400: ErrorResponse;
    /**
     * Invalid SSO token
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type SsoTokenExchangeError = SsoTokenExchangeErrors[keyof SsoTokenExchangeErrors];

export type SsoTokenExchangeResponses = {
    /**
     * Successful Response
     */
    200: SsoExchangeResponse;
};

export type SsoTokenExchangeResponse = SsoTokenExchangeResponses[keyof SsoTokenExchangeResponses];

export type CompleteSsoAuthData = {
    body: SsoCompleteRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/sso-complete';
};

export type CompleteSsoAuthErrors = {
    /**
     * Invalid session
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CompleteSsoAuthError = CompleteSsoAuthErrors[keyof CompleteSsoAuthErrors];

export type CompleteSsoAuthResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type CompleteSsoAuthResponse = CompleteSsoAuthResponses[keyof CompleteSsoAuthResponses];

export type GetCaptchaConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/captcha/config';
};

export type GetCaptchaConfigResponses = {
    /**
     * CAPTCHA configuration
     */
    200: unknown;
};

export type GetServiceStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/status';
};

export type GetServiceStatusResponses = {
    /**
     * Service is healthy
     */
    200: HealthStatus;
};

export type GetServiceStatusResponse = GetServiceStatusResponses[keyof GetServiceStatusResponses];

export type GetCurrentUserData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user';
};

export type GetCurrentUserErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetCurrentUserError = GetCurrentUserErrors[keyof GetCurrentUserErrors];

export type GetCurrentUserResponses = {
    /**
     * Successful Response
     */
    200: UserResponse;
};

export type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type UpdateUserData = {
    body: UpdateUserRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user';
};

export type UpdateUserErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];

export type UpdateUserResponses = {
    /**
     * Successful Response
     */
    200: UserResponse;
};

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export type GetAllCreditSummariesData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/credits';
};

export type GetAllCreditSummariesErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve credit summaries
     */
    500: ErrorResponse;
};

export type GetAllCreditSummariesError = GetAllCreditSummariesErrors[keyof GetAllCreditSummariesErrors];

export type GetAllCreditSummariesResponses = {
    /**
     * Response Getallcreditsummaries
     * Credit summaries retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetAllCreditSummariesResponse = GetAllCreditSummariesResponses[keyof GetAllCreditSummariesResponses];

export type UpdateUserPasswordData = {
    body: UpdatePasswordRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/password';
};

export type UpdateUserPasswordErrors = {
    /**
     * Invalid password or validation error
     */
    400: ErrorResponse;
    /**
     * User not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Error updating password
     */
    500: ErrorResponse;
};

export type UpdateUserPasswordError = UpdateUserPasswordErrors[keyof UpdateUserPasswordErrors];

export type UpdateUserPasswordResponses = {
    /**
     * Password updated successfully
     */
    200: SuccessResponse;
};

export type UpdateUserPasswordResponse = UpdateUserPasswordResponses[keyof UpdateUserPasswordResponses];

export type ListUserApiKeysData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/api-keys';
};

export type ListUserApiKeysErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListUserApiKeysError = ListUserApiKeysErrors[keyof ListUserApiKeysErrors];

export type ListUserApiKeysResponses = {
    /**
     * Successful Response
     */
    200: ApiKeysResponse;
};

export type ListUserApiKeysResponse = ListUserApiKeysResponses[keyof ListUserApiKeysResponses];

export type CreateUserApiKeyData = {
    body: CreateApiKeyRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/api-keys';
};

export type CreateUserApiKeyErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateUserApiKeyError = CreateUserApiKeyErrors[keyof CreateUserApiKeyErrors];

export type CreateUserApiKeyResponses = {
    /**
     * Successful Response
     */
    201: CreateApiKeyResponse;
};

export type CreateUserApiKeyResponse = CreateUserApiKeyResponses[keyof CreateUserApiKeyResponses];

export type RevokeUserApiKeyData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Api Key Id
         */
        api_key_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/api-keys/{api_key_id}';
};

export type RevokeUserApiKeyErrors = {
    /**
     * API key not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Error revoking API key
     */
    500: ErrorResponse;
};

export type RevokeUserApiKeyError = RevokeUserApiKeyErrors[keyof RevokeUserApiKeyErrors];

export type RevokeUserApiKeyResponses = {
    /**
     * API key revoked successfully
     */
    200: SuccessResponse;
};

export type RevokeUserApiKeyResponse = RevokeUserApiKeyResponses[keyof RevokeUserApiKeyResponses];

export type UpdateUserApiKeyData = {
    body: UpdateApiKeyRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Api Key Id
         */
        api_key_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/api-keys/{api_key_id}';
};

export type UpdateUserApiKeyErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UpdateUserApiKeyError = UpdateUserApiKeyErrors[keyof UpdateUserApiKeyErrors];

export type UpdateUserApiKeyResponses = {
    /**
     * Successful Response
     */
    200: ApiKeyInfo;
};

export type UpdateUserApiKeyResponse = UpdateUserApiKeyResponses[keyof UpdateUserApiKeyResponses];

export type GetUserLimitsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/limits';
};

export type GetUserLimitsErrors = {
    /**
     * User limits not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetUserLimitsError = GetUserLimitsErrors[keyof GetUserLimitsErrors];

export type GetUserLimitsResponses = {
    /**
     * User limits retrieved successfully
     */
    200: UserLimitsResponse;
};

export type GetUserLimitsResponse = GetUserLimitsResponses[keyof GetUserLimitsResponses];

export type GetUserUsageData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/limits/usage';
};

export type GetUserUsageErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetUserUsageError = GetUserUsageErrors[keyof GetUserUsageErrors];

export type GetUserUsageResponses = {
    /**
     * User usage statistics retrieved successfully
     */
    200: UserUsageResponse;
};

export type GetUserUsageResponse = GetUserUsageResponses[keyof GetUserUsageResponses];

export type GetAllSharedRepositoryLimitsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/limits/shared-repositories/summary';
};

export type GetAllSharedRepositoryLimitsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetAllSharedRepositoryLimitsError = GetAllSharedRepositoryLimitsErrors[keyof GetAllSharedRepositoryLimitsErrors];

export type GetAllSharedRepositoryLimitsResponses = {
    /**
     * Response Getallsharedrepositorylimits
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetAllSharedRepositoryLimitsResponse = GetAllSharedRepositoryLimitsResponses[keyof GetAllSharedRepositoryLimitsResponses];

export type GetSharedRepositoryLimitsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Repository
         * Repository name (e.g., 'sec')
         */
        repository: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/limits/shared-repositories/{repository}';
};

export type GetSharedRepositoryLimitsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetSharedRepositoryLimitsError = GetSharedRepositoryLimitsErrors[keyof GetSharedRepositoryLimitsErrors];

export type GetSharedRepositoryLimitsResponses = {
    /**
     * Response Getsharedrepositorylimits
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetSharedRepositoryLimitsResponse = GetSharedRepositoryLimitsResponses[keyof GetSharedRepositoryLimitsResponses];

export type GetUserUsageOverviewData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/analytics/overview';
};

export type GetUserUsageOverviewErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetUserUsageOverviewError = GetUserUsageOverviewErrors[keyof GetUserUsageOverviewErrors];

export type GetUserUsageOverviewResponses = {
    /**
     * Successful Response
     */
    200: UserUsageSummaryResponse;
};

export type GetUserUsageOverviewResponse = GetUserUsageOverviewResponses[keyof GetUserUsageOverviewResponses];

export type GetDetailedUserAnalyticsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Include Api Stats
         * Include API usage statistics
         */
        include_api_stats?: boolean;
        /**
         * Include Recent Activity
         * Include recent activity
         */
        include_recent_activity?: boolean;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/analytics/detailed';
};

export type GetDetailedUserAnalyticsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetDetailedUserAnalyticsError = GetDetailedUserAnalyticsErrors[keyof GetDetailedUserAnalyticsErrors];

export type GetDetailedUserAnalyticsResponses = {
    /**
     * Successful Response
     */
    200: UserAnalyticsResponse;
};

export type GetDetailedUserAnalyticsResponse = GetDetailedUserAnalyticsResponses[keyof GetDetailedUserAnalyticsResponses];

export type GetUserSharedSubscriptionsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Active Only
         * Only return active subscriptions
         */
        active_only?: boolean;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/subscriptions/shared-repositories';
};

export type GetUserSharedSubscriptionsErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetUserSharedSubscriptionsError = GetUserSharedSubscriptionsErrors[keyof GetUserSharedSubscriptionsErrors];

export type GetUserSharedSubscriptionsResponses = {
    /**
     * Successfully retrieved user subscriptions
     */
    200: UserSubscriptionsResponse;
};

export type GetUserSharedSubscriptionsResponse = GetUserSharedSubscriptionsResponses[keyof GetUserSharedSubscriptionsResponses];

export type SubscribeToSharedRepositoryData = {
    body: SubscriptionRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/subscriptions/shared-repositories/subscribe';
};

export type SubscribeToSharedRepositoryErrors = {
    /**
     * Invalid add-on type or tier, or user already has active subscription
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type SubscribeToSharedRepositoryError = SubscribeToSharedRepositoryErrors[keyof SubscribeToSharedRepositoryErrors];

export type SubscribeToSharedRepositoryResponses = {
    /**
     * Successfully subscribed to shared repository
     */
    201: SubscriptionResponse;
};

export type SubscribeToSharedRepositoryResponse = SubscribeToSharedRepositoryResponses[keyof SubscribeToSharedRepositoryResponses];

export type UpgradeSharedRepositorySubscriptionData = {
    body: TierUpgradeRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Subscription Id
         */
        subscription_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/subscriptions/shared-repositories/{subscription_id}/upgrade';
};

export type UpgradeSharedRepositorySubscriptionErrors = {
    /**
     * Invalid tier for add-on type
     */
    400: unknown;
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Subscription not found or not owned by user
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpgradeSharedRepositorySubscriptionError = UpgradeSharedRepositorySubscriptionErrors[keyof UpgradeSharedRepositorySubscriptionErrors];

export type UpgradeSharedRepositorySubscriptionResponses = {
    /**
     * Successfully upgraded subscription tier
     */
    200: unknown;
};

export type CancelSharedRepositorySubscriptionData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Subscription Id
         */
        subscription_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/subscriptions/shared-repositories/{subscription_id}';
};

export type CancelSharedRepositorySubscriptionErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Subscription not found or not owned by user
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CancelSharedRepositorySubscriptionError = CancelSharedRepositorySubscriptionErrors[keyof CancelSharedRepositorySubscriptionErrors];

export type CancelSharedRepositorySubscriptionResponses = {
    /**
     * Successfully cancelled subscription
     */
    200: CancellationResponse;
};

export type CancelSharedRepositorySubscriptionResponse = CancelSharedRepositorySubscriptionResponses[keyof CancelSharedRepositorySubscriptionResponses];

export type GetSharedRepositoryCreditsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/subscriptions/shared-repositories/credits';
};

export type GetSharedRepositoryCreditsErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetSharedRepositoryCreditsError = GetSharedRepositoryCreditsErrors[keyof GetSharedRepositoryCreditsErrors];

export type GetSharedRepositoryCreditsResponses = {
    /**
     * Successfully retrieved credit balances
     */
    200: CreditsSummaryResponse;
};

export type GetSharedRepositoryCreditsResponse = GetSharedRepositoryCreditsResponses[keyof GetSharedRepositoryCreditsResponses];

export type GetRepositoryCreditsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Repository
         */
        repository: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/user/subscriptions/shared-repositories/credits/{repository}';
};

export type GetRepositoryCreditsErrors = {
    /**
     * Authentication required
     */
    401: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetRepositoryCreditsError = GetRepositoryCreditsErrors[keyof GetRepositoryCreditsErrors];

export type GetRepositoryCreditsResponses = {
    /**
     * Successfully retrieved repository credits
     */
    200: RepositoryCreditsResponse;
};

export type GetRepositoryCreditsResponse = GetRepositoryCreditsResponses[keyof GetRepositoryCreditsResponses];

export type ListConnectionsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Entity Id
         * Filter by entity ID
         */
        entity_id?: string | null;
        /**
         * Provider
         * Filter by provider type
         */
        provider?: ('sec' | 'quickbooks' | 'plaid') | null;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections';
};

export type ListConnectionsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to list connections
     */
    500: ErrorResponse;
};

export type ListConnectionsError = ListConnectionsErrors[keyof ListConnectionsErrors];

export type ListConnectionsResponses = {
    /**
     * Response Listconnections
     * Connections retrieved successfully
     */
    200: Array<ConnectionResponse>;
};

export type ListConnectionsResponse = ListConnectionsResponses[keyof ListConnectionsResponses];

export type CreateConnectionData = {
    body: CreateConnectionRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections';
};

export type CreateConnectionErrors = {
    /**
     * Invalid connection configuration
     */
    400: ErrorResponse;
    /**
     * Access denied - admin role required
     */
    403: ErrorResponse;
    /**
     * Connection already exists
     */
    409: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to create connection
     */
    500: ErrorResponse;
};

export type CreateConnectionError = CreateConnectionErrors[keyof CreateConnectionErrors];

export type CreateConnectionResponses = {
    /**
     * Connection created successfully
     */
    201: ConnectionResponse;
};

export type CreateConnectionResponse = CreateConnectionResponses[keyof CreateConnectionResponses];

export type GetConnectionOptionsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections/options';
};

export type GetConnectionOptionsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve options
     */
    500: ErrorResponse;
};

export type GetConnectionOptionsError = GetConnectionOptionsErrors[keyof GetConnectionOptionsErrors];

export type GetConnectionOptionsResponses = {
    /**
     * Connection options retrieved successfully
     */
    200: ConnectionOptionsResponse;
};

export type GetConnectionOptionsResponse = GetConnectionOptionsResponses[keyof GetConnectionOptionsResponses];

export type ExchangeLinkTokenData = {
    body: ExchangeTokenRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections/link/exchange';
};

export type ExchangeLinkTokenErrors = {
    /**
     * Invalid token or provider
     */
    400: ErrorResponse;
    /**
     * Connection not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Token exchange failed
     */
    500: ErrorResponse;
};

export type ExchangeLinkTokenError = ExchangeLinkTokenErrors[keyof ExchangeLinkTokenErrors];

export type ExchangeLinkTokenResponses = {
    /**
     * Token exchanged successfully
     */
    200: unknown;
};

export type CreateLinkTokenData = {
    body: LinkTokenRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections/link/token';
};

export type CreateLinkTokenErrors = {
    /**
     * Invalid provider or request
     */
    400: ErrorResponse;
    /**
     * Entity not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to create link token
     */
    500: ErrorResponse;
};

export type CreateLinkTokenError = CreateLinkTokenErrors[keyof CreateLinkTokenErrors];

export type CreateLinkTokenResponses = {
    /**
     * Link token created successfully
     */
    200: unknown;
};

export type InitOAuthData = {
    body: OAuthInitRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections/oauth/init';
};

export type InitOAuthErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type InitOAuthError = InitOAuthErrors[keyof InitOAuthErrors];

export type InitOAuthResponses = {
    /**
     * Successful Response
     */
    200: OAuthInitResponse;
};

export type InitOAuthResponse = InitOAuthResponses[keyof InitOAuthResponses];

export type OauthCallbackData = {
    body: OAuthCallbackRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Provider
         * OAuth provider name
         */
        provider: string;
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections/oauth/callback/{provider}';
};

export type OauthCallbackErrors = {
    /**
     * OAuth error or invalid state
     */
    400: ErrorResponse;
    /**
     * State does not match user
     */
    403: ErrorResponse;
    /**
     * Connection not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * OAuth callback processing failed
     */
    500: ErrorResponse;
};

export type OauthCallbackError = OauthCallbackErrors[keyof OauthCallbackErrors];

export type OauthCallbackResponses = {
    /**
     * OAuth flow completed successfully
     */
    200: unknown;
};

export type DeleteConnectionData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
        /**
         * Connection Id
         * Connection identifier
         */
        connection_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections/{connection_id}';
};

export type DeleteConnectionErrors = {
    /**
     * Access denied - admin role required
     */
    403: ErrorResponse;
    /**
     * Connection not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to delete connection
     */
    500: ErrorResponse;
};

export type DeleteConnectionError = DeleteConnectionErrors[keyof DeleteConnectionErrors];

export type DeleteConnectionResponses = {
    /**
     * Connection deleted successfully
     */
    200: SuccessResponse;
};

export type DeleteConnectionResponse = DeleteConnectionResponses[keyof DeleteConnectionResponses];

export type GetConnectionData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
        /**
         * Connection Id
         * Unique connection identifier
         */
        connection_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections/{connection_id}';
};

export type GetConnectionErrors = {
    /**
     * Access denied to connection
     */
    403: ErrorResponse;
    /**
     * Connection not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve connection
     */
    500: ErrorResponse;
};

export type GetConnectionError = GetConnectionErrors[keyof GetConnectionErrors];

export type GetConnectionResponses = {
    /**
     * Connection details retrieved successfully
     */
    200: ConnectionResponse;
};

export type GetConnectionResponse = GetConnectionResponses[keyof GetConnectionResponses];

export type SyncConnectionData = {
    body: SyncConnectionRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
        /**
         * Connection Id
         * Connection identifier
         */
        connection_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/connections/{connection_id}/sync';
};

export type SyncConnectionErrors = {
    /**
     * Access denied - admin role required
     */
    403: ErrorResponse;
    /**
     * Connection not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to start sync
     */
    500: ErrorResponse;
};

export type SyncConnectionError = SyncConnectionErrors[keyof SyncConnectionErrors];

export type SyncConnectionResponses = {
    /**
     * Response Syncconnection
     * Sync started successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type SyncConnectionResponse = SyncConnectionResponses[keyof SyncConnectionResponses];

export type AutoSelectAgentData = {
    body: AgentRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/agent';
};

export type AutoSelectAgentErrors = {
    /**
     * Invalid request parameters
     */
    400: unknown;
    /**
     * Insufficient credits for selected agent
     */
    402: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: unknown;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type AutoSelectAgentError = AutoSelectAgentErrors[keyof AutoSelectAgentErrors];

export type AutoSelectAgentResponses = {
    /**
     * Query successfully processed by selected agent
     */
    200: AgentResponse;
};

export type AutoSelectAgentResponse = AutoSelectAgentResponses[keyof AutoSelectAgentResponses];

export type ExecuteSpecificAgentData = {
    body: AgentRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Agent Type
         */
        agent_type: string;
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/agent/{agent_type}';
};

export type ExecuteSpecificAgentErrors = {
    /**
     * Invalid agent type or request parameters
     */
    400: unknown;
    /**
     * Insufficient credits for specified agent
     */
    402: unknown;
    /**
     * Agent type not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: unknown;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type ExecuteSpecificAgentError = ExecuteSpecificAgentErrors[keyof ExecuteSpecificAgentErrors];

export type ExecuteSpecificAgentResponses = {
    /**
     * Query successfully processed by specified agent
     */
    200: AgentResponse;
};

export type ExecuteSpecificAgentResponse = ExecuteSpecificAgentResponses[keyof ExecuteSpecificAgentResponses];

export type BatchProcessQueriesData = {
    body: BatchAgentRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/agent/batch';
};

export type BatchProcessQueriesErrors = {
    /**
     * Invalid batch request or too many queries
     */
    400: unknown;
    /**
     * Insufficient credits for batch processing
     */
    402: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error during batch processing
     */
    500: unknown;
};

export type BatchProcessQueriesError = BatchProcessQueriesErrors[keyof BatchProcessQueriesErrors];

export type BatchProcessQueriesResponses = {
    /**
     * Batch processing completed successfully
     */
    200: BatchAgentResponse;
};

export type BatchProcessQueriesResponse = BatchProcessQueriesResponses[keyof BatchProcessQueriesResponses];

export type ListAgentsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Capability
         * Filter by capability (e.g., 'financial_analysis', 'rag_search')
         */
        capability?: string | null;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/agent/list';
};

export type ListAgentsErrors = {
    /**
     * Unauthorized - Invalid or missing authentication
     */
    401: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListAgentsError = ListAgentsErrors[keyof ListAgentsErrors];

export type ListAgentsResponses = {
    /**
     * List of agents retrieved successfully
     */
    200: AgentListResponse;
};

export type ListAgentsResponse = ListAgentsResponses[keyof ListAgentsResponses];

export type GetAgentMetadataData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
        /**
         * Agent Type
         * Agent type identifier (e.g., 'financial', 'research', 'rag')
         */
        agent_type: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/agent/{agent_type}/metadata';
};

export type GetAgentMetadataErrors = {
    /**
     * Agent type not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetAgentMetadataError = GetAgentMetadataErrors[keyof GetAgentMetadataErrors];

export type GetAgentMetadataResponses = {
    /**
     * Agent metadata retrieved successfully
     */
    200: AgentMetadataResponse;
};

export type GetAgentMetadataResponse = GetAgentMetadataResponses[keyof GetAgentMetadataResponses];

export type RecommendAgentData = {
    body: AgentRecommendationRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/agent/recommend';
};

export type RecommendAgentErrors = {
    /**
     * Invalid recommendation request
     */
    400: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type RecommendAgentError = RecommendAgentErrors[keyof RecommendAgentErrors];

export type RecommendAgentResponses = {
    /**
     * Recommendations generated successfully
     */
    200: AgentRecommendationResponse;
};

export type RecommendAgentResponse = RecommendAgentResponses[keyof RecommendAgentResponses];

export type ListMcpToolsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/mcp/tools';
};

export type ListMcpToolsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve MCP tools
     */
    500: ErrorResponse;
};

export type ListMcpToolsError = ListMcpToolsErrors[keyof ListMcpToolsErrors];

export type ListMcpToolsResponses = {
    /**
     * MCP tools retrieved successfully
     */
    200: McpToolsResponse;
};

export type ListMcpToolsResponse = ListMcpToolsResponses[keyof ListMcpToolsResponses];

export type CallMcpToolData = {
    body: McpToolCall;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Format
         * Response format override (json, sse, ndjson)
         */
        format?: string | null;
        /**
         * Test Mode
         * Enable test mode for debugging
         */
        test_mode?: boolean;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/mcp/call-tool';
};

export type CallMcpToolErrors = {
    /**
     * Invalid tool call
     */
    400: ErrorResponse;
    /**
     * Insufficient credits
     */
    402: ErrorResponse;
    /**
     * Access denied
     */
    403: ErrorResponse;
    /**
     * Execution timeout
     */
    408: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
    /**
     * Service unavailable
     */
    503: ErrorResponse;
};

export type CallMcpToolError = CallMcpToolErrors[keyof CallMcpToolErrors];

export type CallMcpToolResponses = {
    /**
     * Tool executed successfully
     */
    200: unknown;
    /**
     * Tool queued for execution
     */
    202: unknown;
};

export type ListBackupsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Limit
         * Maximum number of backups to return
         */
        limit?: number;
        /**
         * Offset
         * Number of backups to skip
         */
        offset?: number;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/backups';
};

export type ListBackupsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListBackupsError = ListBackupsErrors[keyof ListBackupsErrors];

export type ListBackupsResponses = {
    /**
     * Successful Response
     */
    200: BackupListResponse;
};

export type ListBackupsResponse = ListBackupsResponses[keyof ListBackupsResponses];

export type CreateBackupData = {
    body: BackupCreateRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/backups';
};

export type CreateBackupErrors = {
    /**
     * Invalid backup configuration
     */
    400: ErrorResponse;
    /**
     * Access denied - admin role required
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to initiate backup
     */
    500: ErrorResponse;
};

export type CreateBackupError = CreateBackupErrors[keyof CreateBackupErrors];

export type CreateBackupResponses = {
    /**
     * Backup creation started
     */
    202: unknown;
};

export type GetBackupDownloadUrlData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Backup Id
         * Backup identifier
         */
        backup_id: string;
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Expires In
         * URL expiration time in seconds
         */
        expires_in?: number;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/backups/{backup_id}/download';
};

export type GetBackupDownloadUrlErrors = {
    /**
     * Access denied or backup is encrypted
     */
    403: unknown;
    /**
     * Backup not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to generate download URL
     */
    500: unknown;
};

export type GetBackupDownloadUrlError = GetBackupDownloadUrlErrors[keyof GetBackupDownloadUrlErrors];

export type GetBackupDownloadUrlResponses = {
    /**
     * Response Getbackupdownloadurl
     * Download URL generated successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetBackupDownloadUrlResponse = GetBackupDownloadUrlResponses[keyof GetBackupDownloadUrlResponses];

export type RestoreBackupData = {
    body: BackupRestoreRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Backup Id
         * Backup identifier
         */
        backup_id: string;
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/backups/{backup_id}/restore';
};

export type RestoreBackupErrors = {
    /**
     * Invalid restore configuration
     */
    400: ErrorResponse;
    /**
     * Access denied - admin role required
     */
    403: ErrorResponse;
    /**
     * Backup not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to initiate restore
     */
    500: ErrorResponse;
};

export type RestoreBackupError = RestoreBackupErrors[keyof RestoreBackupErrors];

export type RestoreBackupResponses = {
    /**
     * Restore started
     */
    202: unknown;
};

export type GetBackupStatsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/backups/stats';
};

export type GetBackupStatsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetBackupStatsError = GetBackupStatsErrors[keyof GetBackupStatsErrors];

export type GetBackupStatsResponses = {
    /**
     * Successful Response
     */
    200: BackupStatsResponse;
};

export type GetBackupStatsResponse = GetBackupStatsResponses[keyof GetBackupStatsResponses];

export type GetGraphMetricsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * The graph ID to get metrics for
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/analytics';
};

export type GetGraphMetricsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Graph not found or metrics unavailable
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve metrics
     */
    500: ErrorResponse;
};

export type GetGraphMetricsError = GetGraphMetricsErrors[keyof GetGraphMetricsErrors];

export type GetGraphMetricsResponses = {
    /**
     * Graph metrics retrieved successfully
     */
    200: GraphMetricsResponse;
};

export type GetGraphMetricsResponse = GetGraphMetricsResponses[keyof GetGraphMetricsResponses];

export type GetGraphUsageStatsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * The graph ID to get usage stats for
         */
        graph_id: string;
    };
    query?: {
        /**
         * Include Details
         * Include detailed metrics (may be slower)
         */
        include_details?: boolean;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/analytics/usage';
};

export type GetGraphUsageStatsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve usage statistics
     */
    500: ErrorResponse;
};

export type GetGraphUsageStatsError = GetGraphUsageStatsErrors[keyof GetGraphUsageStatsErrors];

export type GetGraphUsageStatsResponses = {
    /**
     * Usage statistics retrieved successfully
     */
    200: GraphUsageResponse;
};

export type GetGraphUsageStatsResponse = GetGraphUsageStatsResponses[keyof GetGraphUsageStatsResponses];

export type ExecuteCypherQueryData = {
    body: CypherQueryRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Mode
         * Response mode override
         */
        mode?: ResponseMode | null;
        /**
         * Chunk Size
         * Rows per chunk for streaming
         */
        chunk_size?: number;
        /**
         * Test Mode
         * Enable test mode for better debugging
         */
        test_mode?: boolean;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/query';
};

export type ExecuteCypherQueryErrors = {
    /**
     * Invalid query or parameters
     */
    400: unknown;
    /**
     * Access denied
     */
    403: unknown;
    /**
     * Query timeout
     */
    408: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: unknown;
    /**
     * Internal error
     */
    500: unknown;
    /**
     * Service unavailable
     */
    503: unknown;
};

export type ExecuteCypherQueryError = ExecuteCypherQueryErrors[keyof ExecuteCypherQueryErrors];

export type ExecuteCypherQueryResponses = {
    /**
     * Query executed successfully
     */
    200: unknown;
    /**
     * Query queued for execution
     */
    202: unknown;
};

export type GetGraphSchemaData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * The graph database to get schema for
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/schema';
};

export type GetGraphSchemaErrors = {
    /**
     * Access denied to graph
     */
    403: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve schema
     */
    500: unknown;
};

export type GetGraphSchemaError = GetGraphSchemaErrors[keyof GetGraphSchemaErrors];

export type GetGraphSchemaResponses = {
    /**
     * Response Getgraphschema
     * Schema information retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetGraphSchemaResponse = GetGraphSchemaResponses[keyof GetGraphSchemaResponses];

export type ExportGraphSchemaData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * The graph ID to export schema from
         */
        graph_id: string;
    };
    query?: {
        /**
         * Format
         * Export format: json, yaml, or cypher
         */
        format?: string;
        /**
         * Include Data Stats
         * Include statistics about actual data in the graph
         */
        include_data_stats?: boolean;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/schema/export';
};

export type ExportGraphSchemaErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ExportGraphSchemaError = ExportGraphSchemaErrors[keyof ExportGraphSchemaErrors];

export type ExportGraphSchemaResponses = {
    /**
     * Successful Response
     */
    200: SchemaExportResponse;
};

export type ExportGraphSchemaResponse = ExportGraphSchemaResponses[keyof ExportGraphSchemaResponses];

export type ValidateSchemaData = {
    /**
     * Schema definition to validate
     */
    body: SchemaValidationRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/schema/validate';
};

export type ValidateSchemaErrors = {
    /**
     * Invalid schema format
     */
    400: ErrorResponse;
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Schema validation failed
     */
    422: ErrorResponse;
    /**
     * Validation error
     */
    500: ErrorResponse;
};

export type ValidateSchemaError = ValidateSchemaErrors[keyof ValidateSchemaErrors];

export type ValidateSchemaResponses = {
    /**
     * Schema validation completed
     */
    200: SchemaValidationResponse;
};

export type ValidateSchemaResponse = ValidateSchemaResponses[keyof ValidateSchemaResponses];

export type GetCurrentGraphBillData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/billing/current';
};

export type GetCurrentGraphBillErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to calculate bill
     */
    500: ErrorResponse;
};

export type GetCurrentGraphBillError = GetCurrentGraphBillErrors[keyof GetCurrentGraphBillErrors];

export type GetCurrentGraphBillResponses = {
    /**
     * Response Getcurrentgraphbill
     * Current bill retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetCurrentGraphBillResponse = GetCurrentGraphBillResponses[keyof GetCurrentGraphBillResponses];

export type GetGraphUsageDetailsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Year
         * Year (defaults to current)
         */
        year?: number | null;
        /**
         * Month
         * Month (defaults to current)
         */
        month?: number | null;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/billing/usage';
};

export type GetGraphUsageDetailsErrors = {
    /**
     * Invalid year or month
     */
    400: ErrorResponse;
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve usage
     */
    500: ErrorResponse;
};

export type GetGraphUsageDetailsError = GetGraphUsageDetailsErrors[keyof GetGraphUsageDetailsErrors];

export type GetGraphUsageDetailsResponses = {
    /**
     * Response Getgraphusagedetails
     * Usage details retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetGraphUsageDetailsResponse = GetGraphUsageDetailsResponses[keyof GetGraphUsageDetailsResponses];

export type GetGraphBillingHistoryData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Months
         * Number of months to retrieve (1-24)
         */
        months?: number;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/billing/history';
};

export type GetGraphBillingHistoryErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve history
     */
    500: ErrorResponse;
};

export type GetGraphBillingHistoryError = GetGraphBillingHistoryErrors[keyof GetGraphBillingHistoryErrors];

export type GetGraphBillingHistoryResponses = {
    /**
     * Response Getgraphbillinghistory
     * Billing history retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetGraphBillingHistoryResponse = GetGraphBillingHistoryResponses[keyof GetGraphBillingHistoryResponses];

export type GetGraphMonthlyBillData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Year
         * Year (2024-2030)
         */
        year: number;
        /**
         * Month
         * Month (1-12)
         */
        month: number;
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/billing/history/{year}/{month}';
};

export type GetGraphMonthlyBillErrors = {
    /**
     * Invalid year or month
     */
    400: ErrorResponse;
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Graph not found or no data for period
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to calculate bill
     */
    500: ErrorResponse;
};

export type GetGraphMonthlyBillError = GetGraphMonthlyBillErrors[keyof GetGraphMonthlyBillErrors];

export type GetGraphMonthlyBillResponses = {
    /**
     * Response Getgraphmonthlybill
     * Monthly bill retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetGraphMonthlyBillResponse = GetGraphMonthlyBillResponses[keyof GetGraphMonthlyBillResponses];

export type GetCreditSummaryData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/credits/summary';
};

export type GetCreditSummaryErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Credit pool not found for graph
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve credit summary
     */
    500: ErrorResponse;
};

export type GetCreditSummaryError = GetCreditSummaryErrors[keyof GetCreditSummaryErrors];

export type GetCreditSummaryResponses = {
    /**
     * Credit summary retrieved successfully
     */
    200: CreditSummaryResponse;
};

export type GetCreditSummaryResponse = GetCreditSummaryResponses[keyof GetCreditSummaryResponses];

export type ListCreditTransactionsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Transaction Type
         * Filter by transaction type (allocation, consumption, bonus, refund)
         */
        transaction_type?: string | null;
        /**
         * Operation Type
         * Filter by operation type (e.g., entity_lookup, cypher_query)
         */
        operation_type?: string | null;
        /**
         * Start Date
         * Start date for filtering (ISO format: YYYY-MM-DD)
         */
        start_date?: string | null;
        /**
         * End Date
         * End date for filtering (ISO format: YYYY-MM-DD)
         */
        end_date?: string | null;
        /**
         * Limit
         * Maximum number of transactions to return
         */
        limit?: number;
        /**
         * Offset
         * Number of transactions to skip
         */
        offset?: number;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/credits/transactions';
};

export type ListCreditTransactionsErrors = {
    /**
     * Invalid transaction type filter
     */
    400: ErrorResponse;
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve transactions
     */
    500: ErrorResponse;
};

export type ListCreditTransactionsError = ListCreditTransactionsErrors[keyof ListCreditTransactionsErrors];

export type ListCreditTransactionsResponses = {
    /**
     * Transaction history retrieved successfully
     */
    200: DetailedTransactionsResponse;
};

export type ListCreditTransactionsResponse = ListCreditTransactionsResponses[keyof ListCreditTransactionsResponses];

export type CheckCreditBalanceData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query: {
        /**
         * Operation Type
         * Type of operation to check
         */
        operation_type: string;
        /**
         * Base Cost
         * Custom base cost (uses default if not provided)
         */
        base_cost?: number | string | null;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/credits/balance/check';
};

export type CheckCreditBalanceErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Credit pool not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Credit check failed
     */
    500: ErrorResponse;
};

export type CheckCreditBalanceError = CheckCreditBalanceErrors[keyof CheckCreditBalanceErrors];

export type CheckCreditBalanceResponses = {
    /**
     * Response Checkcreditbalance
     * Credit check completed
     */
    200: {
        [key: string]: unknown;
    };
};

export type CheckCreditBalanceResponse = CheckCreditBalanceResponses[keyof CheckCreditBalanceResponses];

export type GetStorageUsageData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Days
         * Number of days of history to return
         */
        days?: number;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/credits/storage/usage';
};

export type GetStorageUsageErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve storage usage
     */
    500: ErrorResponse;
};

export type GetStorageUsageError = GetStorageUsageErrors[keyof GetStorageUsageErrors];

export type GetStorageUsageResponses = {
    /**
     * Response Getstorageusage
     * Storage usage retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetStorageUsageResponse = GetStorageUsageResponses[keyof GetStorageUsageResponses];

export type CheckStorageLimitsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/credits/storage/limits';
};

export type CheckStorageLimitsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * No credit pool found for graph
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve storage limits
     */
    500: ErrorResponse;
};

export type CheckStorageLimitsError = CheckStorageLimitsErrors[keyof CheckStorageLimitsErrors];

export type CheckStorageLimitsResponses = {
    /**
     * Storage limit information retrieved successfully
     */
    200: StorageLimitResponse;
};

export type CheckStorageLimitsResponse = CheckStorageLimitsResponses[keyof CheckStorageLimitsResponses];

export type GetDatabaseHealthData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/health';
};

export type GetDatabaseHealthErrors = {
    /**
     * Access denied to graph
     */
    403: unknown;
    /**
     * Graph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve health information
     */
    500: unknown;
};

export type GetDatabaseHealthError = GetDatabaseHealthErrors[keyof GetDatabaseHealthErrors];

export type GetDatabaseHealthResponses = {
    /**
     * Database health retrieved successfully
     */
    200: DatabaseHealthResponse;
};

export type GetDatabaseHealthResponse = GetDatabaseHealthResponses[keyof GetDatabaseHealthResponses];

export type GetDatabaseInfoData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/info';
};

export type GetDatabaseInfoErrors = {
    /**
     * Access denied to graph
     */
    403: unknown;
    /**
     * Graph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve database information
     */
    500: unknown;
};

export type GetDatabaseInfoError = GetDatabaseInfoErrors[keyof GetDatabaseInfoErrors];

export type GetDatabaseInfoResponses = {
    /**
     * Database information retrieved successfully
     */
    200: DatabaseInfoResponse;
};

export type GetDatabaseInfoResponse = GetDatabaseInfoResponses[keyof GetDatabaseInfoResponses];

export type GetGraphLimitsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier (user graph or shared repository)
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/limits';
};

export type GetGraphLimitsErrors = {
    /**
     * Access denied to graph
     */
    403: unknown;
    /**
     * Graph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve limits
     */
    500: unknown;
};

export type GetGraphLimitsError = GetGraphLimitsErrors[keyof GetGraphLimitsErrors];

export type GetGraphLimitsResponses = {
    /**
     * Response Getgraphlimits
     * Limits retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetGraphLimitsResponse = GetGraphLimitsResponses[keyof GetGraphLimitsResponses];

export type ListSubgraphsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Parent graph ID (e.g., 'kg1a2b3c4d5')
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/subgraphs';
};

export type ListSubgraphsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListSubgraphsError = ListSubgraphsErrors[keyof ListSubgraphsErrors];

export type ListSubgraphsResponses = {
    /**
     * Successful Response
     */
    200: ListSubgraphsResponse;
};

export type ListSubgraphsResponse2 = ListSubgraphsResponses[keyof ListSubgraphsResponses];

export type CreateSubgraphData = {
    body: CreateSubgraphRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Parent graph ID (e.g., 'kg1a2b3c4d5')
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/subgraphs';
};

export type CreateSubgraphErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateSubgraphError = CreateSubgraphErrors[keyof CreateSubgraphErrors];

export type CreateSubgraphResponses = {
    /**
     * Successful Response
     */
    201: SubgraphResponse;
};

export type CreateSubgraphResponse = CreateSubgraphResponses[keyof CreateSubgraphResponses];

export type DeleteSubgraphData = {
    body: DeleteSubgraphRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Parent graph identifier
         */
        graph_id: string;
        /**
         * Subgraph Id
         * Subgraph identifier to delete
         */
        subgraph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_id}';
};

export type DeleteSubgraphErrors = {
    /**
     * Invalid subgraph identifier
     */
    400: unknown;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Insufficient permissions
     */
    403: unknown;
    /**
     * Subgraph not found
     */
    404: unknown;
    /**
     * Subgraph contains data (use force=true)
     */
    409: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeleteSubgraphError = DeleteSubgraphErrors[keyof DeleteSubgraphErrors];

export type DeleteSubgraphResponses = {
    /**
     * Subgraph deleted successfully
     */
    200: DeleteSubgraphResponse;
};

export type DeleteSubgraphResponse2 = DeleteSubgraphResponses[keyof DeleteSubgraphResponses];

export type GetSubgraphInfoData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Parent graph identifier
         */
        graph_id: string;
        /**
         * Subgraph Id
         * Subgraph identifier
         */
        subgraph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_id}/info';
};

export type GetSubgraphInfoErrors = {
    /**
     * Not a valid subgraph
     */
    400: unknown;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied
     */
    403: unknown;
    /**
     * Subgraph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetSubgraphInfoError = GetSubgraphInfoErrors[keyof GetSubgraphInfoErrors];

export type GetSubgraphInfoResponses = {
    /**
     * Subgraph information retrieved
     */
    200: SubgraphResponse;
};

export type GetSubgraphInfoResponse = GetSubgraphInfoResponses[keyof GetSubgraphInfoResponses];

export type GetSubgraphQuotaData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Parent graph identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/subgraphs/quota';
};

export type GetSubgraphQuotaErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied to parent graph
     */
    403: unknown;
    /**
     * Parent graph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetSubgraphQuotaError = GetSubgraphQuotaErrors[keyof GetSubgraphQuotaErrors];

export type GetSubgraphQuotaResponses = {
    /**
     * Quota information retrieved
     */
    200: SubgraphQuotaResponse;
};

export type GetSubgraphQuotaResponse = GetSubgraphQuotaResponses[keyof GetSubgraphQuotaResponses];

export type ListTablesData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/tables';
};

export type ListTablesErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - insufficient permissions for this graph
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListTablesError = ListTablesErrors[keyof ListTablesErrors];

export type ListTablesResponses = {
    /**
     * Tables retrieved successfully with full metrics
     */
    200: TableListResponse;
};

export type ListTablesResponse = ListTablesResponses[keyof ListTablesResponses];

export type ListTableFilesData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
        /**
         * Table Name
         * Table name
         */
        table_name: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/tables/{table_name}/files';
};

export type ListTableFilesErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - insufficient permissions for this graph
     */
    403: ErrorResponse;
    /**
     * Graph or table not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListTableFilesError = ListTableFilesErrors[keyof ListTableFilesErrors];

export type ListTableFilesResponses = {
    /**
     * Files retrieved successfully with full metadata
     */
    200: ListTableFilesResponse;
};

export type ListTableFilesResponse2 = ListTableFilesResponses[keyof ListTableFilesResponses];

export type GetUploadUrlData = {
    /**
     * Upload request
     */
    body: FileUploadRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
        /**
         * Table Name
         * Table name
         */
        table_name: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/tables/{table_name}/files';
};

export type GetUploadUrlErrors = {
    /**
     * Invalid file format, name, or extension mismatch
     */
    400: ErrorResponse;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - shared repositories or insufficient permissions
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetUploadUrlError = GetUploadUrlErrors[keyof GetUploadUrlErrors];

export type GetUploadUrlResponses = {
    /**
     * Upload URL generated successfully
     */
    200: FileUploadResponse;
};

export type GetUploadUrlResponse = GetUploadUrlResponses[keyof GetUploadUrlResponses];

export type DeleteFileData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
        /**
         * File Id
         * File ID
         */
        file_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/tables/files/{file_id}';
};

export type DeleteFileErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - shared repositories or insufficient permissions
     */
    403: ErrorResponse;
    /**
     * File not found in graph
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeleteFileError = DeleteFileErrors[keyof DeleteFileErrors];

export type DeleteFileResponses = {
    /**
     * File deleted successfully
     */
    200: DeleteFileResponse;
};

export type DeleteFileResponse2 = DeleteFileResponses[keyof DeleteFileResponses];

export type GetFileInfoData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
        /**
         * File Id
         * File ID
         */
        file_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/tables/files/{file_id}';
};

export type GetFileInfoErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - insufficient permissions for this graph
     */
    403: ErrorResponse;
    /**
     * File not found in graph
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetFileInfoError = GetFileInfoErrors[keyof GetFileInfoErrors];

export type GetFileInfoResponses = {
    /**
     * File information retrieved successfully
     */
    200: GetFileInfoResponse;
};

export type GetFileInfoResponse2 = GetFileInfoResponses[keyof GetFileInfoResponses];

export type UpdateFileStatusData = {
    /**
     * Status update
     */
    body: FileStatusUpdate;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
        /**
         * File Id
         * File identifier
         */
        file_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/tables/files/{file_id}';
};

export type UpdateFileStatusErrors = {
    /**
     * Invalid status, file too large, or empty file
     */
    400: ErrorResponse;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - shared repositories or insufficient permissions
     */
    403: ErrorResponse;
    /**
     * Graph, file, or S3 object not found
     */
    404: ErrorResponse;
    /**
     * Storage limit exceeded for tier
     */
    413: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdateFileStatusError = UpdateFileStatusErrors[keyof UpdateFileStatusErrors];

export type UpdateFileStatusResponses = {
    /**
     * Response Updatefilestatus
     * File status updated successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type UpdateFileStatusResponse = UpdateFileStatusResponses[keyof UpdateFileStatusResponses];

export type IngestTablesData = {
    /**
     * Ingestion request
     */
    body: BulkIngestRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/tables/ingest';
};

export type IngestTablesErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - shared repositories or insufficient permissions
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Conflict - another ingestion is already in progress for this graph
     */
    409: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Ingestion failed - check per-table results for details
     */
    500: ErrorResponse;
};

export type IngestTablesError = IngestTablesErrors[keyof IngestTablesErrors];

export type IngestTablesResponses = {
    /**
     * Ingestion completed with detailed per-table results
     */
    200: BulkIngestResponse;
};

export type IngestTablesResponse = IngestTablesResponses[keyof IngestTablesResponses];

export type QueryTablesData = {
    /**
     * SQL query request
     */
    body: TableQueryRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/tables/query';
};

export type QueryTablesErrors = {
    /**
     * Invalid SQL query syntax or execution error
     */
    400: ErrorResponse;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - shared repositories or insufficient permissions
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Query timeout exceeded
     */
    408: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type QueryTablesError = QueryTablesErrors[keyof QueryTablesErrors];

export type QueryTablesResponses = {
    /**
     * Query executed successfully
     */
    200: TableQueryResponse;
};

export type QueryTablesResponse = QueryTablesResponses[keyof QueryTablesResponses];

export type GetGraphsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs';
};

export type GetGraphsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetGraphsError = GetGraphsErrors[keyof GetGraphsErrors];

export type GetGraphsResponses = {
    /**
     * Successful Response
     */
    200: UserGraphsResponse;
};

export type GetGraphsResponse = GetGraphsResponses[keyof GetGraphsResponses];

export type CreateGraphData = {
    body: CreateGraphRequest;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path?: never;
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs';
};

export type CreateGraphErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateGraphError = CreateGraphErrors[keyof CreateGraphErrors];

export type CreateGraphResponses = {
    /**
     * Successful Response
     */
    202: unknown;
};

export type GetAvailableExtensionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/graphs/extensions';
};

export type GetAvailableExtensionsResponses = {
    /**
     * Successful Response
     */
    200: AvailableExtensionsResponse;
};

export type GetAvailableExtensionsResponse = GetAvailableExtensionsResponses[keyof GetAvailableExtensionsResponses];

export type SelectGraphData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/graphs/{graph_id}/select';
};

export type SelectGraphErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Error selecting graph
     */
    500: ErrorResponse;
};

export type SelectGraphError = SelectGraphErrors[keyof SelectGraphErrors];

export type SelectGraphResponses = {
    /**
     * Graph selected successfully
     */
    200: SuccessResponse;
};

export type SelectGraphResponse = SelectGraphResponses[keyof SelectGraphResponses];

export type GetServiceOfferingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/offering';
};

export type GetServiceOfferingsErrors = {
    /**
     * Failed to retrieve service offerings
     */
    500: ErrorResponse;
};

export type GetServiceOfferingsError = GetServiceOfferingsErrors[keyof GetServiceOfferingsErrors];

export type GetServiceOfferingsResponses = {
    /**
     * Complete service offerings retrieved successfully
     */
    200: unknown;
};

export type StreamOperationEventsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Operation Id
         * Operation identifier from initial submission
         */
        operation_id: string;
    };
    query?: {
        /**
         * From Sequence
         * Start streaming from this sequence number (0 = from beginning)
         */
        from_sequence?: number;
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/operations/{operation_id}/stream';
};

export type StreamOperationEventsErrors = {
    /**
     * Access denied to operation
     */
    403: unknown;
    /**
     * Operation not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to create event stream
     */
    500: unknown;
};

export type StreamOperationEventsError = StreamOperationEventsErrors[keyof StreamOperationEventsErrors];

export type StreamOperationEventsResponses = {
    /**
     * SSE stream of operation events
     */
    200: unknown;
};

export type GetOperationStatusData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Operation Id
         * Operation identifier
         */
        operation_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/operations/{operation_id}/status';
};

export type GetOperationStatusErrors = {
    /**
     * Access denied to operation
     */
    403: unknown;
    /**
     * Operation not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve operation status
     */
    500: unknown;
};

export type GetOperationStatusError = GetOperationStatusErrors[keyof GetOperationStatusErrors];

export type GetOperationStatusResponses = {
    /**
     * Response Getoperationstatus
     * Operation status retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetOperationStatusResponse = GetOperationStatusResponses[keyof GetOperationStatusResponses];

export type CancelOperationData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Operation Id
         * Operation identifier
         */
        operation_id: string;
    };
    query?: {
        /**
         * Token
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/operations/{operation_id}';
};

export type CancelOperationErrors = {
    /**
     * Access denied to operation
     */
    403: unknown;
    /**
     * Operation not found
     */
    404: unknown;
    /**
     * Operation cannot be cancelled (already completed)
     */
    409: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to cancel operation
     */
    500: unknown;
};

export type CancelOperationError = CancelOperationErrors[keyof CancelOperationErrors];

export type CancelOperationResponses = {
    /**
     * Response Canceloperation
     * Operation cancelled successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type CancelOperationResponse = CancelOperationResponses[keyof CancelOperationResponses];

export type ClientOptions = {
    baseUrl: 'http://localhost:8000';
};