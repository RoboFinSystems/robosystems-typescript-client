// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'http://localhost:8000';
};

/**
 * APIKeyInfo
 *
 * API key information response model.
 */
export type ApiKeyInfo = {
    /**
     * Id
     *
     * API key ID
     */
    id: string;
    /**
     * Name
     *
     * API key name
     */
    name: string;
    /**
     * Description
     *
     * API key description
     */
    description?: string | null;
    /**
     * Prefix
     *
     * API key prefix for identification
     */
    prefix: string;
    /**
     * Is Active
     *
     * Whether the key is active
     */
    is_active: boolean;
    /**
     * Last Used At
     *
     * Last used timestamp
     */
    last_used_at?: string | null;
    /**
     * Expires At
     *
     * Expiration timestamp
     */
    expires_at?: string | null;
    /**
     * Created At
     *
     * Creation timestamp
     */
    created_at: string;
};

/**
 * APIKeysResponse
 *
 * Response model for listing API keys.
 */
export type ApiKeysResponse = {
    /**
     * Api Keys
     *
     * List of user's API keys
     */
    api_keys: Array<ApiKeyInfo>;
};

/**
 * AccountInfo
 *
 * Provider account information.
 */
export type AccountInfo = {
    /**
     * Provider
     *
     * Authentication provider ID (e.g., 'github', 'google')
     */
    provider: string;
    /**
     * Provider Type
     *
     * Type of provider
     */
    provider_type: string;
    /**
     * Provider Account Id
     *
     * Account ID at the provider
     */
    provider_account_id: string;
};

/**
 * AgentListResponse
 *
 * Response for listing available agents.
 */
export type AgentListResponse = {
    /**
     * Agents
     *
     * Dictionary of available agents with metadata
     */
    agents: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    /**
     * Total
     *
     * Total number of agents
     */
    total: number;
};

/**
 * AgentMessage
 *
 * Message in conversation history.
 */
export type AgentMessage = {
    /**
     * Role
     *
     * Message role (user/assistant)
     */
    role: string;
    /**
     * Content
     *
     * Message content
     */
    content: string;
    /**
     * Timestamp
     *
     * Message timestamp
     */
    timestamp?: string | null;
};

/**
 * AgentMetadataResponse
 *
 * Response for agent metadata.
 */
export type AgentMetadataResponse = {
    /**
     * Name
     *
     * Agent name
     */
    name: string;
    /**
     * Description
     *
     * Agent description
     */
    description: string;
    /**
     * Version
     *
     * Agent version
     */
    version: string;
    /**
     * Capabilities
     *
     * Agent capabilities
     */
    capabilities: Array<string>;
    /**
     * Supported Modes
     *
     * Supported execution modes
     */
    supported_modes: Array<string>;
    /**
     * Requires Credits
     *
     * Whether agent requires credits
     */
    requires_credits: boolean;
    /**
     * Author
     *
     * Agent author
     */
    author?: string | null;
    /**
     * Tags
     *
     * Agent tags
     */
    tags?: Array<string>;
};

/**
 * AgentMode
 *
 * Agent execution modes.
 */
export type AgentMode = 'quick' | 'standard' | 'extended' | 'streaming';

/**
 * AgentRecommendation
 *
 * Single agent recommendation.
 */
export type AgentRecommendation = {
    /**
     * Agent Type
     *
     * Agent type identifier
     */
    agent_type: string;
    /**
     * Agent Name
     *
     * Agent display name
     */
    agent_name: string;
    /**
     * Confidence
     *
     * Confidence score (0-1)
     */
    confidence: number;
    /**
     * Capabilities
     *
     * Agent capabilities
     */
    capabilities: Array<string>;
    /**
     * Reason
     *
     * Reason for recommendation
     */
    reason?: string | null;
};

/**
 * AgentRecommendationRequest
 *
 * Request for agent recommendations.
 */
export type AgentRecommendationRequest = {
    /**
     * Query
     *
     * Query to analyze
     */
    query: string;
    /**
     * Context
     *
     * Additional context
     */
    context?: {
        [key: string]: unknown;
    } | null;
};

/**
 * AgentRecommendationResponse
 *
 * Response for agent recommendations.
 */
export type AgentRecommendationResponse = {
    /**
     * Recommendations
     *
     * List of agent recommendations sorted by confidence
     */
    recommendations: Array<AgentRecommendation>;
    /**
     * Query
     *
     * The analyzed query
     */
    query: string;
};

/**
 * AgentRequest
 *
 * Request model for agent interactions.
 */
export type AgentRequest = {
    /**
     * Message
     *
     * The query or message to process
     */
    message: string;
    /**
     * History
     *
     * Conversation history
     */
    history?: Array<AgentMessage>;
    /**
     * Context
     *
     * Additional context for analysis (e.g., enable_rag, include_schema)
     */
    context?: {
        [key: string]: unknown;
    } | null;
    /**
     * Execution mode
     */
    mode?: AgentMode | null;
    /**
     * Agent Type
     *
     * Specific agent type to use (optional)
     */
    agent_type?: string | null;
    /**
     * Criteria for agent selection
     */
    selection_criteria?: SelectionCriteria | null;
    /**
     * Force Extended Analysis
     *
     * Force extended analysis mode with comprehensive research
     */
    force_extended_analysis?: boolean;
    /**
     * Enable Rag
     *
     * Enable RAG context enrichment
     */
    enable_rag?: boolean;
    /**
     * Stream
     *
     * Enable streaming response
     */
    stream?: boolean;
};

/**
 * AgentResponse
 *
 * Response model for agent interactions.
 */
export type AgentResponse = {
    /**
     * Content
     *
     * The agent's response content
     */
    content: string;
    /**
     * Agent Used
     *
     * The agent type that handled the request
     */
    agent_used: string;
    /**
     * The execution mode used
     */
    mode_used: AgentMode;
    /**
     * Metadata
     *
     * Response metadata including routing info
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Tokens Used
     *
     * Token usage statistics
     */
    tokens_used?: {
        [key: string]: number;
    } | null;
    /**
     * Confidence Score
     *
     * Confidence score of the response (0.0-1.0 scale)
     */
    confidence_score?: number | null;
    /**
     * Operation Id
     *
     * Operation ID for SSE monitoring
     */
    operation_id?: string | null;
    /**
     * Is Partial
     *
     * Whether this is a partial response
     */
    is_partial?: boolean;
    /**
     * Error Details
     *
     * Error details if any
     */
    error_details?: {
        [key: string]: unknown;
    } | null;
    /**
     * Execution Time
     *
     * Execution time in seconds
     */
    execution_time?: number | null;
    /**
     * Timestamp
     *
     * Response timestamp
     */
    timestamp?: string;
};

/**
 * AuthResponse
 *
 * Authentication response model.
 */
export type AuthResponse = {
    /**
     * User
     *
     * User information
     */
    user: {
        [key: string]: unknown;
    };
    /**
     * Org
     *
     * Organization information (personal org created automatically on registration)
     */
    org?: {
        [key: string]: unknown;
    } | null;
    /**
     * Message
     *
     * Success message
     */
    message: string;
    /**
     * Token
     *
     * JWT authentication token (optional for cookie-based auth)
     */
    token?: string | null;
    /**
     * Expires In
     *
     * Token expiry time in seconds from now
     */
    expires_in?: number | null;
    /**
     * Refresh Threshold
     *
     * Recommended refresh threshold in seconds before expiry
     */
    refresh_threshold?: number | null;
};

/**
 * AvailableExtension
 */
export type AvailableExtension = {
    /**
     * Name
     */
    name: string;
    /**
     * Description
     */
    description: string;
    /**
     * Enabled
     */
    enabled?: boolean;
};

/**
 * AvailableExtensionsResponse
 */
export type AvailableExtensionsResponse = {
    /**
     * Extensions
     */
    extensions: Array<AvailableExtension>;
};

/**
 * AvailableGraphTiersResponse
 *
 * Response containing available graph tiers.
 */
export type AvailableGraphTiersResponse = {
    /**
     * Tiers
     *
     * List of available tiers
     */
    tiers: Array<GraphTierInfo>;
};

/**
 * BackupCreateRequest
 *
 * Request model for creating a backup.
 */
export type BackupCreateRequest = {
    /**
     * Backup Format
     *
     * Backup format - only 'full_dump' is supported (complete .lbug database file)
     */
    backup_format?: string;
    /**
     * Backup Type
     *
     * Backup type - only 'full' is supported
     */
    backup_type?: string;
    /**
     * Retention Days
     *
     * Retention period in days
     */
    retention_days?: number;
    /**
     * Compression
     *
     * Enable compression (always enabled for optimal storage)
     */
    compression?: boolean;
    /**
     * Encryption
     *
     * Enable encryption (encrypted backups cannot be downloaded)
     */
    encryption?: boolean;
    /**
     * Schedule
     *
     * Optional cron schedule for automated backups
     */
    schedule?: string | null;
};

/**
 * BackupDownloadUrlResponse
 *
 * Response model for backup download URL generation.
 */
export type BackupDownloadUrlResponse = {
    /**
     * Download Url
     *
     * Pre-signed S3 URL for downloading the backup file
     */
    download_url: string;
    /**
     * Expires In
     *
     * URL expiration time in seconds from now
     */
    expires_in: number;
    /**
     * Expires At
     *
     * Unix timestamp when the URL expires
     */
    expires_at: number;
    /**
     * Backup Id
     *
     * Backup identifier
     */
    backup_id: string;
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
};

/**
 * BackupLimits
 *
 * Backup operation limits.
 */
export type BackupLimits = {
    /**
     * Max Backup Size Gb
     *
     * Maximum backup size in GB
     */
    max_backup_size_gb: number;
    /**
     * Backup Retention Days
     *
     * Backup retention period in days
     */
    backup_retention_days: number;
    /**
     * Max Backups Per Day
     *
     * Maximum backups per day
     */
    max_backups_per_day: number;
};

/**
 * BackupListResponse
 *
 * Response model for backup list.
 */
export type BackupListResponse = {
    /**
     * Backups
     */
    backups: Array<BackupResponse>;
    /**
     * Total Count
     */
    total_count: number;
    /**
     * Graph Id
     */
    graph_id: string;
    /**
     * Is Shared Repository
     *
     * Whether this is a shared repository (limits apply)
     */
    is_shared_repository?: boolean;
    /**
     * Download quota for shared repositories
     */
    download_quota?: DownloadQuota | null;
};

/**
 * BackupResponse
 *
 * Response model for backup information.
 */
export type BackupResponse = {
    /**
     * Backup Id
     */
    backup_id: string;
    /**
     * Graph Id
     */
    graph_id: string;
    /**
     * Backup Format
     */
    backup_format: string;
    /**
     * Backup Type
     */
    backup_type: string;
    /**
     * Status
     */
    status: string;
    /**
     * Original Size Bytes
     */
    original_size_bytes: number;
    /**
     * Compressed Size Bytes
     */
    compressed_size_bytes: number;
    /**
     * Compression Ratio
     */
    compression_ratio: number;
    /**
     * Node Count
     */
    node_count: number;
    /**
     * Relationship Count
     */
    relationship_count: number;
    /**
     * Backup Duration Seconds
     */
    backup_duration_seconds: number;
    /**
     * Encryption Enabled
     */
    encryption_enabled: boolean;
    /**
     * Compression Enabled
     */
    compression_enabled: boolean;
    /**
     * Allow Export
     */
    allow_export: boolean;
    /**
     * Created At
     */
    created_at: string;
    /**
     * Completed At
     */
    completed_at: string | null;
    /**
     * Expires At
     */
    expires_at: string | null;
};

/**
 * BackupRestoreRequest
 *
 * Request model for restoring from a backup.
 */
export type BackupRestoreRequest = {
    /**
     * Create System Backup
     *
     * Create a system backup of existing database before restore
     */
    create_system_backup?: boolean;
    /**
     * Verify After Restore
     *
     * Verify database integrity after restore
     */
    verify_after_restore?: boolean;
};

/**
 * BackupStatsResponse
 *
 * Response model for backup statistics.
 */
export type BackupStatsResponse = {
    /**
     * Graph Id
     */
    graph_id: string;
    /**
     * Total Backups
     */
    total_backups: number;
    /**
     * Successful Backups
     */
    successful_backups: number;
    /**
     * Failed Backups
     */
    failed_backups: number;
    /**
     * Success Rate
     */
    success_rate: number;
    /**
     * Total Original Size Bytes
     */
    total_original_size_bytes: number;
    /**
     * Total Compressed Size Bytes
     */
    total_compressed_size_bytes: number;
    /**
     * Storage Saved Bytes
     */
    storage_saved_bytes: number;
    /**
     * Average Compression Ratio
     */
    average_compression_ratio: number;
    /**
     * Latest Backup Date
     */
    latest_backup_date: string | null;
    /**
     * Backup Formats
     */
    backup_formats: {
        [key: string]: number;
    };
};

/**
 * BatchAgentRequest
 *
 * Request for batch processing multiple queries.
 */
export type BatchAgentRequest = {
    /**
     * Queries
     *
     * List of queries to process (max 10)
     */
    queries: Array<AgentRequest>;
    /**
     * Parallel
     *
     * Process queries in parallel
     */
    parallel?: boolean;
};

/**
 * BatchAgentResponse
 *
 * Response for batch processing.
 */
export type BatchAgentResponse = {
    /**
     * Results
     *
     * List of agent responses (includes successes and failures)
     */
    results: Array<AgentResponse>;
    /**
     * Total Execution Time
     *
     * Total execution time in seconds
     */
    total_execution_time: number;
    /**
     * Parallel Processed
     *
     * Whether queries were processed in parallel
     */
    parallel_processed: boolean;
};

/**
 * BillingCustomer
 *
 * Billing customer information for an organization.
 */
export type BillingCustomer = {
    /**
     * Org Id
     *
     * Organization ID
     */
    org_id: string;
    /**
     * Has Payment Method
     *
     * Whether organization has a payment method on file
     */
    has_payment_method: boolean;
    /**
     * Invoice Billing Enabled
     *
     * Whether invoice billing is enabled (enterprise customers)
     */
    invoice_billing_enabled: boolean;
    /**
     * Payment Methods
     *
     * List of payment methods on file
     */
    payment_methods: Array<PaymentMethod>;
    /**
     * Stripe Customer Id
     *
     * Stripe customer ID if applicable
     */
    stripe_customer_id?: string | null;
    /**
     * Created At
     *
     * Customer creation timestamp (ISO format)
     */
    created_at: string;
};

/**
 * CheckoutResponse
 *
 * Response from checkout session creation.
 */
export type CheckoutResponse = {
    /**
     * Checkout Url
     *
     * URL to redirect user to for payment
     */
    checkout_url?: string | null;
    /**
     * Session Id
     *
     * Checkout session ID for status polling
     */
    session_id?: string | null;
    /**
     * Subscription Id
     *
     * Internal subscription ID
     */
    subscription_id?: string | null;
    /**
     * Requires Checkout
     *
     * Whether checkout is required
     */
    requires_checkout?: boolean;
    /**
     * Billing Disabled
     *
     * Whether billing is disabled on this instance
     */
    billing_disabled?: boolean;
};

/**
 * CheckoutStatusResponse
 *
 * Status of a checkout session.
 */
export type CheckoutStatusResponse = {
    /**
     * Status
     *
     * Checkout status: 'pending_payment', 'provisioning', 'active', 'failed', 'canceled'
     */
    status: string;
    /**
     * Subscription Id
     *
     * Internal subscription ID
     */
    subscription_id: string;
    /**
     * Resource Id
     *
     * Resource ID (graph_id for both graphs and repositories) once provisioned. For repositories, this is the repository slug (e.g., 'sec')
     */
    resource_id?: string | null;
    /**
     * Operation Id
     *
     * SSE operation ID for monitoring provisioning progress
     */
    operation_id?: string | null;
    /**
     * Error
     *
     * Error message if checkout failed
     */
    error?: string | null;
};

/**
 * ContentLimits
 *
 * Graph content limits (nodes, relationships, rows).
 */
export type ContentLimits = {
    /**
     * Max Nodes
     *
     * Maximum nodes allowed
     */
    max_nodes: number;
    /**
     * Current Nodes
     *
     * Current node count
     */
    current_nodes?: number | null;
    /**
     * Max Relationships
     *
     * Maximum relationships allowed
     */
    max_relationships: number;
    /**
     * Current Relationships
     *
     * Current relationship count
     */
    current_relationships?: number | null;
    /**
     * Max Rows Per Copy
     *
     * Maximum rows per copy/materialization operation
     */
    max_rows_per_copy: number;
    /**
     * Max Single Table Rows
     *
     * Maximum rows per staging table
     */
    max_single_table_rows: number;
    /**
     * Chunk Size Rows
     *
     * Rows per materialization chunk
     */
    chunk_size_rows: number;
    /**
     * Approaching Limits
     *
     * List of limits being approached (>80%)
     */
    approaching_limits?: Array<string>;
};

/**
 * CopyOperationLimits
 *
 * Copy/ingestion operation limits.
 */
export type CopyOperationLimits = {
    /**
     * Max File Size Gb
     *
     * Maximum file size in GB
     */
    max_file_size_gb: number;
    /**
     * Timeout Seconds
     *
     * Operation timeout in seconds
     */
    timeout_seconds: number;
    /**
     * Concurrent Operations
     *
     * Maximum concurrent operations
     */
    concurrent_operations: number;
    /**
     * Max Files Per Operation
     *
     * Maximum files per operation
     */
    max_files_per_operation: number;
    /**
     * Daily Copy Operations
     *
     * Daily operation limit
     */
    daily_copy_operations: number;
    /**
     * Supported Formats
     *
     * Supported file formats
     */
    supported_formats: Array<string>;
};

/**
 * CreateAPIKeyRequest
 *
 * Request model for creating a new API key.
 */
export type CreateApiKeyRequest = {
    /**
     * Name
     *
     * Name for the API key
     */
    name: string;
    /**
     * Description
     *
     * Optional description
     */
    description?: string | null;
    /**
     * Expires At
     *
     * Optional expiration date in ISO format (e.g. 2024-12-31T23:59:59Z)
     */
    expires_at?: string | null;
};

/**
 * CreateAPIKeyResponse
 *
 * Response model for creating a new API key.
 */
export type CreateApiKeyResponse = {
    /**
     * API key information
     */
    api_key: ApiKeyInfo;
    /**
     * Key
     *
     * The actual API key (only shown once)
     */
    key: string;
};

/**
 * CreateCheckoutRequest
 *
 * Request to create a checkout session for payment collection.
 */
export type CreateCheckoutRequest = {
    /**
     * Plan Name
     *
     * Billing plan name (e.g., 'ladybug-standard')
     */
    plan_name: string;
    /**
     * Resource Type
     *
     * Resource type ('graph' or 'repository')
     */
    resource_type: string;
    /**
     * Resource Config
     *
     * Configuration for the resource to be provisioned. For repositories: {'repository_name': 'graph_id'} where graph_id is the repository slug (e.g., 'sec')
     */
    resource_config: {
        [key: string]: unknown;
    };
};

/**
 * CreateGraphRequest
 *
 * Request model for creating a new graph.
 *
 * Use this to create either:
 * - **Entity graphs**: Standard graphs with entity schema and optional extensions
 * - **Custom graphs**: Generic graphs with fully custom schema definitions
 */
export type CreateGraphRequest = {
    /**
     * Graph metadata including name, description, and schema extensions
     */
    metadata: GraphMetadata;
    /**
     * Instance Tier
     *
     * Instance tier: ladybug-standard, ladybug-large, ladybug-xlarge
     */
    instance_tier?: string;
    /**
     * Custom schema definition to apply. If provided, creates a generic custom graph. If omitted, creates an entity graph using schema_extensions.
     */
    custom_schema?: CustomSchemaDefinition | null;
    /**
     * Optional initial entity to create in the graph. If provided with entity graph, populates the first entity node.
     */
    initial_entity?: InitialEntityData | null;
    /**
     * Create Entity
     *
     * Whether to create the entity node and upload initial data. Only applies when initial_entity is provided. Set to False to create graph without populating entity data (useful for file-based ingestion workflows).
     */
    create_entity?: boolean;
    /**
     * Tags
     *
     * Optional tags for organization
     */
    tags?: Array<string>;
};

/**
 * CreateOrgRequest
 *
 * Request to create an organization.
 */
export type CreateOrgRequest = {
    /**
     * Name
     */
    name: string;
    org_type?: OrgType;
};

/**
 * CreateRepositorySubscriptionRequest
 *
 * Request to create a repository subscription.
 */
export type CreateRepositorySubscriptionRequest = {
    /**
     * Plan Name
     *
     * Plan name for the repository subscription
     */
    plan_name: string;
};

/**
 * CreateSubgraphRequest
 *
 * Request model for creating a subgraph.
 */
export type CreateSubgraphRequest = {
    /**
     * Name
     *
     * Alphanumeric name for the subgraph (e.g., dev, staging, prod1)
     */
    name: string;
    /**
     * Display Name
     *
     * Human-readable display name for the subgraph
     */
    display_name: string;
    /**
     * Description
     *
     * Optional description of the subgraph's purpose
     */
    description?: string | null;
    /**
     * Schema Extensions
     *
     * Schema extensions to include (inherits from parent by default)
     */
    schema_extensions?: Array<string>;
    /**
     * Type of subgraph (currently only 'static' is supported)
     */
    subgraph_type?: SubgraphType;
    /**
     * Metadata
     *
     * Additional metadata for the subgraph
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
    /**
     * Fork Parent
     *
     * If true, copy all data from parent graph to create a 'fork'
     */
    fork_parent?: boolean;
};

/**
 * CreditLimits
 *
 * AI credit limits (optional).
 */
export type CreditLimits = {
    /**
     * Monthly Ai Credits
     *
     * Monthly AI credits allocation
     */
    monthly_ai_credits: number;
    /**
     * Current Balance
     *
     * Current credit balance
     */
    current_balance: number;
};

/**
 * CreditSummary
 *
 * Credit consumption summary.
 */
export type CreditSummary = {
    /**
     * Graph Tier
     *
     * Subscription tier
     */
    graph_tier: string;
    /**
     * Total Credits Consumed
     *
     * Total credits consumed
     */
    total_credits_consumed: number;
    /**
     * Total Base Cost
     *
     * Total base cost before multipliers
     */
    total_base_cost: number;
    /**
     * Operation Breakdown
     *
     * Credit usage by operation type
     */
    operation_breakdown: {
        [key: string]: unknown;
    };
    /**
     * Cached Operations
     *
     * Number of cached operations
     */
    cached_operations: number;
    /**
     * Billable Operations
     *
     * Number of billable operations
     */
    billable_operations: number;
    /**
     * Transaction Count
     *
     * Total transaction count
     */
    transaction_count: number;
};

/**
 * CreditSummaryResponse
 *
 * Credit summary response model.
 */
export type CreditSummaryResponse = {
    /**
     * Graph Id
     */
    graph_id: string;
    /**
     * Graph Tier
     */
    graph_tier: string;
    /**
     * Current Balance
     */
    current_balance: number;
    /**
     * Monthly Allocation
     */
    monthly_allocation: number;
    /**
     * Consumed This Month
     */
    consumed_this_month: number;
    /**
     * Transaction Count
     */
    transaction_count: number;
    /**
     * Usage Percentage
     */
    usage_percentage: number;
    /**
     * Last Allocation Date
     */
    last_allocation_date?: string | null;
};

/**
 * CustomSchemaDefinition
 *
 * Custom schema definition for generic graphs.
 *
 * This model allows you to define custom node types, relationship types, and properties
 * for graphs that don't fit the standard entity-based schema. Perfect for domain-specific
 * applications like inventory systems, org charts, project management, etc.
 */
export type CustomSchemaDefinition = {
    /**
     * Name
     *
     * Schema name
     */
    name: string;
    /**
     * Version
     *
     * Schema version
     */
    version?: string;
    /**
     * Description
     *
     * Schema description
     */
    description?: string | null;
    /**
     * Extends
     *
     * Base schema to extend (e.g., 'base' for common utilities)
     */
    extends?: string | null;
    /**
     * Nodes
     *
     * List of node definitions with properties
     */
    nodes?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Relationships
     *
     * List of relationship definitions
     */
    relationships?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Metadata
     *
     * Additional schema metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * CypherQueryRequest
 *
 * Request model for Cypher query execution.
 */
export type CypherQueryRequest = {
    /**
     * Query
     *
     * The Cypher query to execute. Use parameters ($param_name) for all dynamic values to prevent injection attacks.
     */
    query: string;
    /**
     * Parameters
     *
     * Query parameters for safe value substitution. ALWAYS use parameters instead of string interpolation.
     */
    parameters?: {
        [key: string]: unknown;
    } | null;
    /**
     * Timeout
     *
     * Query timeout in seconds (1-300)
     */
    timeout?: number | null;
};

/**
 * DatabaseHealthResponse
 *
 * Response model for database health check.
 */
export type DatabaseHealthResponse = {
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Status
     *
     * Overall health status
     */
    status: string;
    /**
     * Connection Status
     *
     * Database connection status
     */
    connection_status: string;
    /**
     * Uptime Seconds
     *
     * Database uptime in seconds
     */
    uptime_seconds: number;
    /**
     * Last Query Time
     *
     * Timestamp of last query execution
     */
    last_query_time?: string | null;
    /**
     * Query Count 24H
     *
     * Number of queries executed in last 24 hours
     */
    query_count_24h: number;
    /**
     * Avg Query Time Ms
     *
     * Average query execution time in milliseconds
     */
    avg_query_time_ms: number;
    /**
     * Error Rate 24H
     *
     * Error rate in last 24 hours (percentage)
     */
    error_rate_24h: number;
    /**
     * Memory Usage Mb
     *
     * Memory usage in MB
     */
    memory_usage_mb?: number | null;
    /**
     * Storage Usage Mb
     *
     * Storage usage in MB
     */
    storage_usage_mb?: number | null;
    /**
     * Alerts
     *
     * Active alerts or warnings
     */
    alerts?: Array<string>;
};

/**
 * DatabaseInfoResponse
 *
 * Response model for database information and statistics.
 */
export type DatabaseInfoResponse = {
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Database Name
     *
     * Database name
     */
    database_name: string;
    /**
     * Database Size Bytes
     *
     * Database size in bytes
     */
    database_size_bytes: number;
    /**
     * Database Size Mb
     *
     * Database size in MB
     */
    database_size_mb: number;
    /**
     * Node Count
     *
     * Total number of nodes
     */
    node_count: number;
    /**
     * Relationship Count
     *
     * Total number of relationships
     */
    relationship_count: number;
    /**
     * Node Labels
     *
     * List of node labels
     */
    node_labels: Array<string>;
    /**
     * Relationship Types
     *
     * List of relationship types
     */
    relationship_types: Array<string>;
    /**
     * Created At
     *
     * Database creation timestamp
     */
    created_at: string;
    /**
     * Last Modified
     *
     * Last modification timestamp
     */
    last_modified: string;
    /**
     * Schema Version
     *
     * Schema version
     */
    schema_version?: string | null;
    /**
     * Read Only
     *
     * Whether database is read-only
     */
    read_only: boolean;
    /**
     * Backup Count
     *
     * Number of available backups
     */
    backup_count: number;
    /**
     * Last Backup Date
     *
     * Date of last backup
     */
    last_backup_date?: string | null;
};

/**
 * DeleteFileResponse
 */
export type DeleteFileResponse = {
    /**
     * Status
     *
     * Deletion status
     */
    status: string;
    /**
     * File Id
     *
     * Deleted file ID
     */
    file_id: string;
    /**
     * File Name
     *
     * Deleted file name
     */
    file_name: string;
    /**
     * Message
     *
     * Operation message
     */
    message: string;
    /**
     * Cascade Deleted
     *
     * Whether cascade deletion was performed
     */
    cascade_deleted?: boolean;
    /**
     * Tables Affected
     *
     * Tables from which file data was deleted (if cascade=true)
     */
    tables_affected?: Array<string> | null;
    /**
     * Graph Marked Stale
     *
     * Whether graph was marked as stale
     */
    graph_marked_stale?: boolean;
};

/**
 * DeleteSubgraphRequest
 *
 * Request model for deleting a subgraph.
 */
export type DeleteSubgraphRequest = {
    /**
     * Force
     *
     * Force deletion even if subgraph contains data
     */
    force?: boolean;
    /**
     * Backup First
     *
     * Create a backup before deletion
     */
    backup_first?: boolean;
    /**
     * Backup Location
     *
     * S3 location for backup (uses default if not specified)
     */
    backup_location?: string | null;
};

/**
 * DeleteSubgraphResponse
 *
 * Response model for subgraph deletion.
 */
export type DeleteSubgraphResponse = {
    /**
     * Graph Id
     *
     * Deleted subgraph identifier
     */
    graph_id: string;
    /**
     * Status
     *
     * Deletion status
     */
    status: string;
    /**
     * Backup Location
     *
     * Location of backup if created
     */
    backup_location?: string | null;
    /**
     * Deleted At
     *
     * When deletion occurred
     */
    deleted_at: string;
    /**
     * Message
     *
     * Additional information about the deletion
     */
    message?: string | null;
};

/**
 * DetailedTransactionsResponse
 *
 * Detailed response for transaction queries.
 */
export type DetailedTransactionsResponse = {
    /**
     * Transactions
     */
    transactions: Array<EnhancedCreditTransactionResponse>;
    /**
     * Summary
     */
    summary: {
        [key: string]: TransactionSummaryResponse;
    };
    /**
     * Total Count
     */
    total_count: number;
    /**
     * Filtered Count
     */
    filtered_count: number;
    /**
     * Date Range
     */
    date_range: {
        [key: string]: string;
    };
};

/**
 * DownloadQuota
 *
 * Download quota information for shared repository backups.
 */
export type DownloadQuota = {
    /**
     * Limit Per Day
     *
     * Maximum downloads allowed per day
     */
    limit_per_day: number;
    /**
     * Used Today
     *
     * Number of downloads used today
     */
    used_today: number;
    /**
     * Remaining
     *
     * Downloads remaining today
     */
    remaining: number;
    /**
     * Resets At
     *
     * When the daily limit resets (UTC)
     */
    resets_at: string;
};

/**
 * EmailVerificationRequest
 *
 * Email verification request model.
 */
export type EmailVerificationRequest = {
    /**
     * Token
     *
     * Email verification token from email link
     */
    token: string;
};

/**
 * EnhancedCreditTransactionResponse
 *
 * Enhanced credit transaction response with more details.
 */
export type EnhancedCreditTransactionResponse = {
    /**
     * Id
     */
    id: string;
    /**
     * Type
     */
    type: string;
    /**
     * Amount
     */
    amount: number;
    /**
     * Description
     */
    description: string;
    /**
     * Metadata
     */
    metadata: {
        [key: string]: unknown;
    };
    /**
     * Created At
     */
    created_at: string;
    /**
     * Operation Id
     */
    operation_id?: string | null;
    /**
     * Idempotency Key
     */
    idempotency_key?: string | null;
    /**
     * Request Id
     */
    request_id?: string | null;
    /**
     * User Id
     */
    user_id?: string | null;
};

/**
 * EnhancedFileStatusLayers
 */
export type EnhancedFileStatusLayers = {
    /**
     * S3 layer status (immutable source)
     */
    s3: FileLayerStatus;
    /**
     * DuckDB layer status (mutable staging)
     */
    duckdb: FileLayerStatus;
    /**
     * Graph layer status (immutable materialized view)
     */
    graph: FileLayerStatus;
};

/**
 * ErrorResponse
 *
 * Standard error response format used across all API endpoints.
 *
 * This model ensures consistent error responses for SDK generation
 * and client error handling.
 */
export type ErrorResponse = {
    /**
     * Detail
     *
     * Human-readable error message explaining what went wrong
     */
    detail: string;
    /**
     * Code
     *
     * Machine-readable error code for programmatic handling
     */
    code?: string | null;
    /**
     * Request Id
     *
     * Unique request ID for tracking and debugging
     */
    request_id?: string | null;
    /**
     * Timestamp
     *
     * Timestamp when the error occurred
     */
    timestamp?: string | null;
};

/**
 * FileInfo
 */
export type FileInfo = {
    /**
     * File Id
     *
     * Unique file identifier
     */
    file_id: string;
    /**
     * File Name
     *
     * Original file name
     */
    file_name: string;
    /**
     * File Format
     *
     * File format (parquet, csv, etc.)
     */
    file_format: string;
    /**
     * Size Bytes
     *
     * File size in bytes
     */
    size_bytes: number;
    /**
     * Row Count
     *
     * Estimated row count
     */
    row_count?: number | null;
    /**
     * Upload Status
     *
     * Current upload status
     */
    upload_status: string;
    /**
     * Upload Method
     *
     * Upload method used
     */
    upload_method: string;
    /**
     * Created At
     *
     * File creation timestamp
     */
    created_at?: string | null;
    /**
     * Uploaded At
     *
     * File upload completion timestamp
     */
    uploaded_at?: string | null;
    /**
     * S3 Key
     *
     * S3 object key
     */
    s3_key: string;
};

/**
 * FileLayerStatus
 */
export type FileLayerStatus = {
    /**
     * Status
     *
     * Layer status
     */
    status: string;
    /**
     * Timestamp
     *
     * Status timestamp
     */
    timestamp?: string | null;
    /**
     * Row Count
     *
     * Row count (if available)
     */
    row_count?: number | null;
    /**
     * Size Bytes
     *
     * Size in bytes (S3 layer only)
     */
    size_bytes?: number | null;
};

/**
 * FileStatusUpdate
 */
export type FileStatusUpdate = {
    /**
     * Status
     *
     * File status: 'uploaded' (ready for ingest), 'disabled' (exclude from ingest), 'archived' (soft deleted)
     */
    status: string;
    /**
     * Ingest To Graph
     *
     * Auto-ingest to graph after DuckDB staging. Default=false (batch mode). Set to true for real-time incremental updates.
     */
    ingest_to_graph?: boolean;
};

/**
 * FileUploadRequest
 */
export type FileUploadRequest = {
    /**
     * File Name
     *
     * File name to upload
     */
    file_name: string;
    /**
     * Content Type
     *
     * File MIME type
     */
    content_type?: string;
    /**
     * Table Name
     *
     * Table name to associate file with (required for first-class /files endpoint)
     */
    table_name?: string | null;
};

/**
 * FileUploadResponse
 */
export type FileUploadResponse = {
    /**
     * Upload Url
     *
     * Presigned S3 upload URL
     */
    upload_url: string;
    /**
     * Expires In
     *
     * URL expiration time in seconds
     */
    expires_in: number;
    /**
     * File Id
     *
     * File tracking ID
     */
    file_id: string;
    /**
     * S3 Key
     *
     * S3 object key
     */
    s3_key: string;
};

/**
 * ForgotPasswordRequest
 *
 * Forgot password request model.
 */
export type ForgotPasswordRequest = {
    /**
     * Email
     *
     * Email address to send reset link
     */
    email: string;
};

/**
 * GetFileInfoResponse
 */
export type GetFileInfoResponse = {
    /**
     * File Id
     *
     * Unique file identifier
     */
    file_id: string;
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Table Id
     *
     * Table identifier
     */
    table_id: string;
    /**
     * Table Name
     *
     * Table name
     */
    table_name?: string | null;
    /**
     * File Name
     *
     * Original file name
     */
    file_name: string;
    /**
     * File Format
     *
     * File format (parquet, csv, etc.)
     */
    file_format: string;
    /**
     * Size Bytes
     *
     * File size in bytes
     */
    size_bytes: number;
    /**
     * Row Count
     *
     * Estimated row count
     */
    row_count?: number | null;
    /**
     * Upload Status
     *
     * Current upload status
     */
    upload_status: string;
    /**
     * Upload Method
     *
     * Upload method used
     */
    upload_method: string;
    /**
     * Created At
     *
     * File creation timestamp
     */
    created_at?: string | null;
    /**
     * Uploaded At
     *
     * File upload completion timestamp
     */
    uploaded_at?: string | null;
    /**
     * S3 Key
     *
     * S3 object key
     */
    s3_key: string;
    /**
     * Multi-layer pipeline status (S3 → DuckDB → Graph). Shows status, timestamps, and row counts for each layer independently.
     */
    layers?: EnhancedFileStatusLayers | null;
};

/**
 * GraphInfo
 *
 * Graph information for user.
 */
export type GraphInfo = {
    /**
     * Graphid
     *
     * Graph database identifier
     */
    graphId: string;
    /**
     * Graphname
     *
     * Display name for the graph
     */
    graphName: string;
    /**
     * Role
     *
     * User's role/access level
     */
    role: string;
    /**
     * Isselected
     *
     * Whether this is the currently selected graph
     */
    isSelected: boolean;
    /**
     * Createdat
     *
     * Creation timestamp
     */
    createdAt: string;
    /**
     * Isrepository
     *
     * Whether this is a shared repository (vs user graph)
     */
    isRepository?: boolean;
    /**
     * Repositorytype
     *
     * Repository type if isRepository=true
     */
    repositoryType?: string | null;
    /**
     * Schemaextensions
     *
     * List of schema extensions installed on this graph
     */
    schemaExtensions?: Array<string>;
    /**
     * Issubgraph
     *
     * Whether this is a subgraph (vs a main graph)
     */
    isSubgraph?: boolean;
    /**
     * Parentgraphid
     *
     * Parent graph ID if this is a subgraph
     */
    parentGraphId?: string | null;
    /**
     * Graphtype
     *
     * Type of graph: generic, entity, or repository
     */
    graphType?: string;
};

/**
 * GraphLimitsResponse
 *
 * Response model for comprehensive graph operational limits.
 */
export type GraphLimitsResponse = {
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Subscription Tier
     *
     * User's subscription tier
     */
    subscription_tier: string;
    /**
     * Graph Tier
     *
     * Graph's database tier
     */
    graph_tier: string;
    /**
     * Is Shared Repository
     *
     * Whether this is a shared repository
     */
    is_shared_repository: boolean;
    /**
     * Storage limits and usage
     */
    storage: StorageLimits;
    /**
     * Query operation limits
     */
    queries: QueryLimits;
    /**
     * Copy/ingestion operation limits
     */
    copy_operations: CopyOperationLimits;
    /**
     * Backup operation limits
     */
    backups: BackupLimits;
    /**
     * API rate limits
     */
    rate_limits: RateLimits;
    /**
     * AI credit limits (if applicable)
     */
    credits?: CreditLimits | null;
    /**
     * Graph content limits (if applicable)
     */
    content?: ContentLimits | null;
};

/**
 * GraphMetadata
 *
 * Metadata for graph creation.
 */
export type GraphMetadata = {
    /**
     * Graph Name
     *
     * Display name for the graph
     */
    graph_name: string;
    /**
     * Description
     *
     * Optional description
     */
    description?: string | null;
    /**
     * Schema Extensions
     *
     * Schema extensions to enable
     */
    schema_extensions?: Array<string>;
    /**
     * Tags
     *
     * Tags for organizing graphs
     */
    tags?: Array<string>;
};

/**
 * GraphMetricsResponse
 *
 * Response model for graph metrics.
 */
export type GraphMetricsResponse = {
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Graph Name
     *
     * Display name for the graph
     */
    graph_name?: string | null;
    /**
     * User Role
     *
     * User's role in this graph
     */
    user_role?: string | null;
    /**
     * Timestamp
     *
     * Metrics collection timestamp
     */
    timestamp: string;
    /**
     * Total Nodes
     *
     * Total number of nodes
     */
    total_nodes: number;
    /**
     * Total Relationships
     *
     * Total number of relationships
     */
    total_relationships: number;
    /**
     * Node Counts
     *
     * Node counts by label
     */
    node_counts: {
        [key: string]: number;
    };
    /**
     * Relationship Counts
     *
     * Relationship counts by type
     */
    relationship_counts: {
        [key: string]: number;
    };
    /**
     * Estimated Size
     *
     * Database size estimates
     */
    estimated_size: {
        [key: string]: unknown;
    };
    /**
     * Health Status
     *
     * Database health information
     */
    health_status: {
        [key: string]: unknown;
    };
};

/**
 * GraphSubscriptionResponse
 *
 * Response for graph or repository subscription details.
 */
export type GraphSubscriptionResponse = {
    /**
     * Id
     *
     * Subscription ID
     */
    id: string;
    /**
     * Resource Type
     *
     * Resource type (graph or repository)
     */
    resource_type: string;
    /**
     * Resource Id
     *
     * Resource identifier
     */
    resource_id: string;
    /**
     * Plan Name
     *
     * Current plan name
     */
    plan_name: string;
    /**
     * Plan Display Name
     *
     * Human-readable plan name for UI display
     */
    plan_display_name: string;
    /**
     * Billing Interval
     *
     * Billing interval
     */
    billing_interval: string;
    /**
     * Status
     *
     * Subscription status
     */
    status: string;
    /**
     * Base Price Cents
     *
     * Base price in cents
     */
    base_price_cents: number;
    /**
     * Current Period Start
     *
     * Current billing period start
     */
    current_period_start?: string | null;
    /**
     * Current Period End
     *
     * Current billing period end
     */
    current_period_end?: string | null;
    /**
     * Started At
     *
     * Subscription start date
     */
    started_at?: string | null;
    /**
     * Canceled At
     *
     * Cancellation date
     */
    canceled_at?: string | null;
    /**
     * Ends At
     *
     * Subscription end date (when access will be revoked, especially relevant for cancelled subscriptions)
     */
    ends_at?: string | null;
    /**
     * Created At
     *
     * Creation timestamp
     */
    created_at: string;
};

/**
 * GraphSubscriptionTier
 *
 * Information about a graph infrastructure tier.
 *
 * Each tier represents a per-graph subscription option with specific
 * infrastructure, performance, and pricing characteristics.
 */
export type GraphSubscriptionTier = {
    /**
     * Name
     *
     * Infrastructure tier identifier (e.g., ladybug-standard)
     */
    name: string;
    /**
     * Display Name
     *
     * Display name for UI
     */
    display_name: string;
    /**
     * Description
     *
     * Tier description
     */
    description: string;
    /**
     * Monthly Price Per Graph
     *
     * Monthly price in USD per graph
     */
    monthly_price_per_graph: number;
    /**
     * Monthly Credits Per Graph
     *
     * Monthly AI credits per graph
     */
    monthly_credits_per_graph: number;
    /**
     * Infrastructure
     *
     * Infrastructure description
     */
    infrastructure: string;
    /**
     * Features
     *
     * List of features
     */
    features: Array<string>;
    /**
     * Backup Retention Days
     *
     * Backup retention in days
     */
    backup_retention_days: number;
    /**
     * Priority Support
     *
     * Whether priority support is included
     */
    priority_support: boolean;
    /**
     * Max Queries Per Hour
     *
     * Maximum queries per hour
     */
    max_queries_per_hour?: number | null;
    /**
     * Max Subgraphs
     *
     * Maximum subgraphs supported
     */
    max_subgraphs?: number;
    /**
     * Api Rate Multiplier
     *
     * API rate multiplier
     */
    api_rate_multiplier: number;
    /**
     * Backend
     *
     * Database backend (ladybug or neo4j)
     */
    backend: string;
    /**
     * Instance Type
     *
     * Instance type
     */
    instance_type?: string | null;
};

/**
 * GraphSubscriptions
 *
 * Graph subscription offerings.
 *
 * Graph subscriptions are per-graph, not per-organization. Each graph
 * created by an organization has its own subscription with its own
 * infrastructure tier, pricing, and credit allocation.
 */
export type GraphSubscriptions = {
    /**
     * Description
     *
     * Description of graph subscriptions
     */
    description: string;
    /**
     * Pricing Model
     *
     * Pricing model type (per_graph or per_organization)
     */
    pricing_model: string;
    /**
     * Tiers
     *
     * Available infrastructure tiers
     */
    tiers: Array<GraphSubscriptionTier>;
    /**
     * Notes
     *
     * Important notes
     */
    notes: Array<string>;
};

/**
 * GraphTierBackup
 *
 * Backup configuration for a tier.
 */
export type GraphTierBackup = {
    /**
     * Max Backup Size Gb
     *
     * Maximum backup size in GB
     */
    max_backup_size_gb: number;
    /**
     * Backup Retention Days
     *
     * Backup retention period in days
     */
    backup_retention_days: number;
    /**
     * Max Backups Per Day
     *
     * Maximum backups per day
     */
    max_backups_per_day: number;
};

/**
 * GraphTierCopyOperations
 *
 * Copy operation limits for a tier.
 */
export type GraphTierCopyOperations = {
    /**
     * Max File Size Gb
     *
     * Maximum file size in GB
     */
    max_file_size_gb: number;
    /**
     * Timeout Seconds
     *
     * Operation timeout in seconds
     */
    timeout_seconds: number;
    /**
     * Concurrent Operations
     *
     * Maximum concurrent operations
     */
    concurrent_operations: number;
    /**
     * Max Files Per Operation
     *
     * Maximum files per operation
     */
    max_files_per_operation: number;
    /**
     * Daily Copy Operations
     *
     * Daily operation limit
     */
    daily_copy_operations: number;
};

/**
 * GraphTierInfo
 *
 * Complete information about a graph database tier.
 */
export type GraphTierInfo = {
    /**
     * Tier
     *
     * Tier identifier
     */
    tier: string;
    /**
     * Name
     *
     * Tier name
     */
    name: string;
    /**
     * Display Name
     *
     * Display name for UI
     */
    display_name: string;
    /**
     * Description
     *
     * Tier description
     */
    description: string;
    /**
     * Backend
     *
     * Database backend (ladybug or neo4j)
     */
    backend: string;
    /**
     * Enabled
     *
     * Whether tier is available
     */
    enabled: boolean;
    /**
     * Max Subgraphs
     *
     * Maximum subgraphs allowed
     */
    max_subgraphs: number | null;
    /**
     * Monthly Credits
     *
     * Monthly AI credits
     */
    monthly_credits: number;
    /**
     * Api Rate Multiplier
     *
     * API rate limit multiplier
     */
    api_rate_multiplier: number;
    /**
     * Monthly Price
     *
     * Monthly price in USD
     */
    monthly_price?: number | null;
    /**
     * Features
     *
     * List of tier features
     */
    features: Array<string>;
    /**
     * Instance specifications
     */
    instance: GraphTierInstance;
    /**
     * Resource limits
     */
    limits: GraphTierLimits;
};

/**
 * GraphTierInstance
 *
 * Instance specifications for a tier.
 */
export type GraphTierInstance = {
    /**
     * Type
     *
     * Instance type identifier
     */
    type: string;
    /**
     * Memory Mb
     *
     * Memory allocated to your graph in megabytes
     */
    memory_mb: number;
    /**
     * Is Multitenant
     *
     * Whether this tier shares infrastructure with other graphs
     */
    is_multitenant: boolean;
};

/**
 * GraphTierLimits
 *
 * Resource limits for a tier.
 */
export type GraphTierLimits = {
    /**
     * Monthly Credits
     *
     * Monthly credit allocation
     */
    monthly_credits: number;
    /**
     * Max Subgraphs
     *
     * Maximum subgraphs (null for unlimited)
     */
    max_subgraphs: number | null;
    /**
     * Copy operation limits
     */
    copy_operations: GraphTierCopyOperations;
    /**
     * Backup configuration
     */
    backup: GraphTierBackup;
};

/**
 * GraphUsageResponse
 *
 * Response model for graph usage statistics.
 */
export type GraphUsageResponse = {
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Time Range
     *
     * Time range for usage data
     */
    time_range: string;
    /**
     * Storage usage summary
     */
    storage_summary?: StorageSummary | null;
    /**
     * Credit consumption summary
     */
    credit_summary?: CreditSummary | null;
    /**
     * Performance analytics
     */
    performance_insights?: PerformanceInsights | null;
    /**
     * Recent Events
     *
     * Recent usage events
     */
    recent_events?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Timestamp
     *
     * Usage collection timestamp
     */
    timestamp: string;
};

/**
 * HTTPValidationError
 */
export type HttpValidationError = {
    /**
     * Detail
     */
    detail?: Array<ValidationError>;
};

/**
 * HealthStatus
 *
 * Health check status information.
 */
export type HealthStatus = {
    /**
     * Status
     *
     * Current health status
     */
    status: string;
    /**
     * Timestamp
     *
     * Time of health check
     */
    timestamp: string;
    /**
     * Details
     *
     * Additional health check details
     */
    details?: {
        [key: string]: unknown;
    } | null;
};

/**
 * InitialEntityData
 *
 * Initial entity data for entity-focused graph creation.
 *
 * When creating an entity graph with an initial entity node, this model defines
 * the entity's identifying information and metadata.
 */
export type InitialEntityData = {
    /**
     * Name
     *
     * Entity name
     */
    name: string;
    /**
     * Uri
     *
     * Entity website or URI
     */
    uri: string;
    /**
     * Cik
     *
     * CIK number for SEC filings
     */
    cik?: string | null;
    /**
     * Sic
     *
     * SIC code
     */
    sic?: string | null;
    /**
     * Sic Description
     *
     * SIC description
     */
    sic_description?: string | null;
    /**
     * Category
     *
     * Business category
     */
    category?: string | null;
    /**
     * State Of Incorporation
     *
     * State of incorporation
     */
    state_of_incorporation?: string | null;
    /**
     * Fiscal Year End
     *
     * Fiscal year end (MMDD)
     */
    fiscal_year_end?: string | null;
    /**
     * Ein
     *
     * Employer Identification Number
     */
    ein?: string | null;
};

/**
 * InviteMemberRequest
 *
 * Request to invite a member to an organization.
 */
export type InviteMemberRequest = {
    /**
     * Email
     */
    email: string;
    role?: OrgRole | null;
};

/**
 * Invoice
 *
 * Invoice information.
 */
export type Invoice = {
    /**
     * Id
     *
     * Invoice ID
     */
    id: string;
    /**
     * Number
     *
     * Invoice number
     */
    number?: string | null;
    /**
     * Status
     *
     * Invoice status (paid, open, void, uncollectible)
     */
    status: string;
    /**
     * Amount Due
     *
     * Amount due in cents
     */
    amount_due: number;
    /**
     * Amount Paid
     *
     * Amount paid in cents
     */
    amount_paid: number;
    /**
     * Currency
     *
     * Currency code (usd)
     */
    currency: string;
    /**
     * Created
     *
     * Invoice creation date (ISO format)
     */
    created: string;
    /**
     * Due Date
     *
     * Invoice due date (ISO format)
     */
    due_date?: string | null;
    /**
     * Paid At
     *
     * Payment date (ISO format)
     */
    paid_at?: string | null;
    /**
     * Invoice Pdf
     *
     * PDF download URL
     */
    invoice_pdf?: string | null;
    /**
     * Hosted Invoice Url
     *
     * Hosted invoice URL
     */
    hosted_invoice_url?: string | null;
    /**
     * Line Items
     *
     * Invoice line items
     */
    line_items: Array<InvoiceLineItem>;
    /**
     * Subscription Id
     *
     * Associated subscription ID
     */
    subscription_id?: string | null;
};

/**
 * InvoiceLineItem
 *
 * Invoice line item.
 */
export type InvoiceLineItem = {
    /**
     * Description
     *
     * Line item description
     */
    description: string;
    /**
     * Amount
     *
     * Amount in cents
     */
    amount: number;
    /**
     * Quantity
     *
     * Quantity
     */
    quantity: number;
    /**
     * Period Start
     *
     * Billing period start
     */
    period_start?: string | null;
    /**
     * Period End
     *
     * Billing period end
     */
    period_end?: string | null;
};

/**
 * InvoicesResponse
 *
 * Response for invoice list.
 */
export type InvoicesResponse = {
    /**
     * Invoices
     *
     * List of invoices
     */
    invoices: Array<Invoice>;
    /**
     * Total Count
     *
     * Total number of invoices
     */
    total_count: number;
    /**
     * Has More
     *
     * Whether more invoices are available
     */
    has_more: boolean;
};

/**
 * ListSubgraphsResponse
 *
 * Response model for listing subgraphs.
 */
export type ListSubgraphsResponse = {
    /**
     * Parent Graph Id
     *
     * Parent graph identifier
     */
    parent_graph_id: string;
    /**
     * Parent Graph Name
     *
     * Parent graph name
     */
    parent_graph_name: string;
    /**
     * Parent Graph Tier
     *
     * Parent graph tier
     */
    parent_graph_tier: string;
    /**
     * Subgraphs Enabled
     *
     * Whether subgraphs are enabled for this tier (requires LadybugDB Large/XLarge or Neo4j Enterprise XLarge)
     */
    subgraphs_enabled: boolean;
    /**
     * Subgraph Count
     *
     * Total number of subgraphs
     */
    subgraph_count: number;
    /**
     * Max Subgraphs
     *
     * Maximum allowed subgraphs for this tier (None = unlimited)
     */
    max_subgraphs?: number | null;
    /**
     * Total Size Mb
     *
     * Combined size of all subgraphs in megabytes
     */
    total_size_mb?: number | null;
    /**
     * Subgraphs
     *
     * List of subgraphs
     */
    subgraphs: Array<SubgraphSummary>;
};

/**
 * ListTableFilesResponse
 */
export type ListTableFilesResponse = {
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Table Name
     *
     * Table name (null if listing all files in graph)
     */
    table_name?: string | null;
    /**
     * Files
     *
     * List of files in the table
     */
    files: Array<FileInfo>;
    /**
     * Total Files
     *
     * Total number of files
     */
    total_files: number;
    /**
     * Total Size Bytes
     *
     * Total size of all files in bytes
     */
    total_size_bytes: number;
};

/**
 * LoginRequest
 *
 * Login request model.
 */
export type LoginRequest = {
    /**
     * Email
     *
     * User's email address
     */
    email: string;
    /**
     * Password
     *
     * User's password
     */
    password: string;
};

/**
 * MCPToolCall
 *
 * Request model for MCP tool execution.
 */
export type McpToolCall = {
    /**
     * Name
     *
     * Name of the MCP tool to execute
     */
    name: string;
    /**
     * Arguments
     *
     * Arguments to pass to the tool
     */
    arguments?: {
        [key: string]: unknown;
    };
};

/**
 * MCPToolsResponse
 *
 * Response model for MCP tools listing.
 */
export type McpToolsResponse = {
    /**
     * Tools
     *
     * List of available MCP tools with their schemas
     */
    tools: Array<{
        [key: string]: unknown;
    }>;
};

/**
 * MaterializeRequest
 */
export type MaterializeRequest = {
    /**
     * Force
     *
     * Force materialization even if graph is not stale
     */
    force?: boolean;
    /**
     * Rebuild
     *
     * Delete and recreate graph database before materialization
     */
    rebuild?: boolean;
    /**
     * Ignore Errors
     *
     * Continue ingestion on row errors
     */
    ignore_errors?: boolean;
    /**
     * Dry Run
     *
     * Validate limits without executing materialization. Returns usage, limits, and warnings.
     */
    dry_run?: boolean;
};

/**
 * MaterializeResponse
 *
 * Response for queued materialization operation.
 */
export type MaterializeResponse = {
    /**
     * Status
     *
     * Operation status
     */
    status?: string;
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Operation Id
     *
     * SSE operation ID for progress tracking
     */
    operation_id: string;
    /**
     * Message
     *
     * Human-readable status message
     */
    message: string;
    /**
     * Limit Check
     *
     * Limit check results (only present for dry_run requests)
     */
    limit_check?: {
        [key: string]: unknown;
    } | null;
};

/**
 * MaterializeStatusResponse
 */
export type MaterializeStatusResponse = {
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Is Stale
     *
     * Whether graph is currently stale
     */
    is_stale: boolean;
    /**
     * Stale Reason
     *
     * Reason for staleness if applicable
     */
    stale_reason?: string | null;
    /**
     * Stale Since
     *
     * When graph became stale (ISO timestamp)
     */
    stale_since?: string | null;
    /**
     * Last Materialized At
     *
     * When graph was last materialized (ISO timestamp)
     */
    last_materialized_at?: string | null;
    /**
     * Materialization Count
     *
     * Total number of materializations performed
     */
    materialization_count?: number;
    /**
     * Hours Since Materialization
     *
     * Hours since last materialization
     */
    hours_since_materialization?: number | null;
    /**
     * Message
     *
     * Human-readable status summary
     */
    message: string;
};

/**
 * OfferingRepositoryPlan
 *
 * Information about a repository plan.
 */
export type OfferingRepositoryPlan = {
    /**
     * Plan
     *
     * Plan identifier
     */
    plan: string;
    /**
     * Name
     *
     * Plan name
     */
    name: string;
    /**
     * Monthly Price
     *
     * Monthly price in USD
     */
    monthly_price: number;
    /**
     * Monthly Credits
     *
     * Monthly credit allocation
     */
    monthly_credits: number;
    /**
     * Access Level
     *
     * Access level
     */
    access_level: string;
    /**
     * Features
     *
     * List of features
     */
    features: Array<string>;
    /**
     * Rate Limits
     *
     * Rate limits for this plan
     */
    rate_limits?: {
        [key: string]: number | null;
    } | null;
};

/**
 * OperationCosts
 *
 * Operation cost information.
 */
export type OperationCosts = {
    /**
     * Description
     *
     * Description of operation costs
     */
    description: string;
    /**
     * Ai Operations
     *
     * Base costs for AI operations
     */
    ai_operations: {
        [key: string]: number;
    };
    /**
     * Token Pricing
     *
     * Token pricing by model
     */
    token_pricing: {
        [key: string]: TokenPricing;
    };
    /**
     * Included Operations
     *
     * Operations that don't consume credits
     */
    included_operations: Array<string>;
    /**
     * Notes
     *
     * Important notes about costs
     */
    notes: Array<string>;
};

/**
 * OrgDetailResponse
 *
 * Detailed organization response.
 */
export type OrgDetailResponse = {
    /**
     * Id
     */
    id: string;
    /**
     * Name
     */
    name: string;
    org_type: OrgType;
    user_role: OrgRole;
    /**
     * Members
     */
    members: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Graphs
     */
    graphs: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Limits
     */
    limits: {
        [key: string]: unknown;
    } | null;
    /**
     * Created At
     */
    created_at: string;
    /**
     * Updated At
     */
    updated_at: string;
};

/**
 * OrgLimitsResponse
 *
 * Organization limits response.
 */
export type OrgLimitsResponse = {
    /**
     * Org Id
     */
    org_id: string;
    /**
     * Max Graphs
     */
    max_graphs: number;
    /**
     * Current Usage
     */
    current_usage: {
        [key: string]: unknown;
    };
    /**
     * Warnings
     */
    warnings: Array<string>;
    /**
     * Can Create Graph
     */
    can_create_graph: boolean;
};

/**
 * OrgListResponse
 *
 * List of organizations response.
 */
export type OrgListResponse = {
    /**
     * Orgs
     */
    orgs: Array<OrgResponse>;
    /**
     * Total
     */
    total: number;
};

/**
 * OrgMemberListResponse
 *
 * List of organization members response.
 */
export type OrgMemberListResponse = {
    /**
     * Members
     */
    members: Array<OrgMemberResponse>;
    /**
     * Total
     */
    total: number;
    /**
     * Org Id
     */
    org_id: string;
};

/**
 * OrgMemberResponse
 *
 * Organization member response.
 */
export type OrgMemberResponse = {
    /**
     * User Id
     */
    user_id: string;
    /**
     * Name
     */
    name: string;
    /**
     * Email
     */
    email: string;
    role: OrgRole;
    /**
     * Joined At
     */
    joined_at: string;
    /**
     * Is Active
     */
    is_active: boolean;
};

/**
 * OrgResponse
 *
 * Organization summary response.
 */
export type OrgResponse = {
    /**
     * Id
     */
    id: string;
    /**
     * Name
     */
    name: string;
    org_type: OrgType;
    role: OrgRole;
    /**
     * Member Count
     */
    member_count: number;
    /**
     * Graph Count
     */
    graph_count: number;
    /**
     * Created At
     */
    created_at: string;
    /**
     * Joined At
     */
    joined_at: string;
};

/**
 * OrgRole
 */
export type OrgRole = 'owner' | 'admin' | 'member';

/**
 * OrgType
 */
export type OrgType = 'personal' | 'team' | 'enterprise';

/**
 * OrgUsageResponse
 *
 * Organization usage response.
 */
export type OrgUsageResponse = {
    /**
     * Org Id
     */
    org_id: string;
    /**
     * Period Days
     */
    period_days: number;
    /**
     * Start Date
     */
    start_date: string;
    /**
     * End Date
     */
    end_date: string;
    summary: OrgUsageSummary;
    /**
     * Graph Details
     */
    graph_details: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Daily Trend
     */
    daily_trend: Array<{
        [key: string]: unknown;
    }>;
};

/**
 * OrgUsageSummary
 *
 * Organization usage summary.
 */
export type OrgUsageSummary = {
    /**
     * Total Credits Used
     */
    total_credits_used: number;
    /**
     * Total Ai Operations
     */
    total_ai_operations: number;
    /**
     * Total Storage Gb
     */
    total_storage_gb: number;
    /**
     * Total Api Calls
     */
    total_api_calls: number;
    /**
     * Daily Avg Credits
     */
    daily_avg_credits: number;
    /**
     * Daily Avg Api Calls
     */
    daily_avg_api_calls: number;
    /**
     * Projected Monthly Credits
     */
    projected_monthly_credits: number;
    /**
     * Projected Monthly Api Calls
     */
    projected_monthly_api_calls: number;
    /**
     * Credits Limit
     */
    credits_limit: number | null;
    /**
     * Api Calls Limit
     */
    api_calls_limit: number | null;
    /**
     * Storage Limit Gb
     */
    storage_limit_gb: number | null;
};

/**
 * PasswordCheckRequest
 *
 * Password strength check request model.
 */
export type PasswordCheckRequest = {
    /**
     * Password
     *
     * Password to check
     */
    password: string;
    /**
     * Email
     *
     * User email for personalization checks
     */
    email?: string | null;
};

/**
 * PasswordCheckResponse
 *
 * Password strength check response model.
 */
export type PasswordCheckResponse = {
    /**
     * Is Valid
     *
     * Whether password meets requirements
     */
    is_valid: boolean;
    /**
     * Strength
     *
     * Password strength level
     */
    strength: string;
    /**
     * Score
     *
     * Password strength score (0-100)
     */
    score: number;
    /**
     * Errors
     *
     * Validation errors
     */
    errors: Array<string>;
    /**
     * Suggestions
     *
     * Improvement suggestions
     */
    suggestions: Array<string>;
    /**
     * Character Types
     *
     * Character type analysis
     */
    character_types: {
        [key: string]: boolean;
    };
};

/**
 * PasswordPolicyResponse
 *
 * Password policy response model.
 */
export type PasswordPolicyResponse = {
    /**
     * Policy
     *
     * Current password policy requirements
     */
    policy: {
        [key: string]: unknown;
    };
};

/**
 * PaymentMethod
 *
 * Payment method information.
 */
export type PaymentMethod = {
    /**
     * Id
     *
     * Payment method ID
     */
    id: string;
    /**
     * Type
     *
     * Payment method type (card, bank_account, etc.)
     */
    type: string;
    /**
     * Brand
     *
     * Card brand (visa, mastercard, etc.)
     */
    brand?: string | null;
    /**
     * Last4
     *
     * Last 4 digits of the card or account number
     */
    last4?: string | null;
    /**
     * Exp Month
     *
     * Expiration month of the card
     */
    exp_month?: number | null;
    /**
     * Exp Year
     *
     * Expiration year of the card
     */
    exp_year?: number | null;
    /**
     * Is Default
     *
     * Whether this is the default payment method
     */
    is_default: boolean;
};

/**
 * PerformanceInsights
 *
 * Performance analytics.
 */
export type PerformanceInsights = {
    /**
     * Analysis Period Days
     *
     * Analysis period in days
     */
    analysis_period_days: number;
    /**
     * Total Operations
     *
     * Total operations analyzed
     */
    total_operations: number;
    /**
     * Operation Stats
     *
     * Performance stats by operation type
     */
    operation_stats: {
        [key: string]: unknown;
    };
    /**
     * Slow Queries
     *
     * Top slow queries (over 5 seconds)
     */
    slow_queries: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Performance Score
     *
     * Performance score (0-100)
     */
    performance_score: number;
};

/**
 * PortalSessionResponse
 *
 * Response for customer portal session creation.
 */
export type PortalSessionResponse = {
    /**
     * Portal Url
     *
     * Stripe Customer Portal URL where user can manage payment methods
     */
    portal_url: string;
};

/**
 * QueryLimits
 *
 * Query operation limits.
 */
export type QueryLimits = {
    /**
     * Max Timeout Seconds
     *
     * Maximum query timeout in seconds
     */
    max_timeout_seconds: number;
    /**
     * Chunk Size
     *
     * Maximum chunk size for result streaming
     */
    chunk_size: number;
    /**
     * Max Rows Per Query
     *
     * Maximum rows returned per query
     */
    max_rows_per_query: number;
    /**
     * Concurrent Queries
     *
     * Maximum concurrent queries allowed
     */
    concurrent_queries: number;
};

/**
 * RateLimits
 *
 * API rate limits.
 */
export type RateLimits = {
    /**
     * Requests Per Minute
     *
     * Requests per minute limit
     */
    requests_per_minute: number;
    /**
     * Requests Per Hour
     *
     * Requests per hour limit
     */
    requests_per_hour: number;
    /**
     * Burst Capacity
     *
     * Burst capacity for short spikes
     */
    burst_capacity: number;
};

/**
 * RegisterRequest
 *
 * Registration request model.
 */
export type RegisterRequest = {
    /**
     * Name
     *
     * User's display name
     */
    name: string;
    /**
     * Email
     *
     * User's email address
     */
    email: string;
    /**
     * Password
     *
     * User's password (must meet security requirements)
     */
    password: string;
    /**
     * Captcha Token
     *
     * CAPTCHA verification token (required in production)
     */
    captcha_token?: string | null;
};

/**
 * RepositoryInfo
 *
 * Information about a shared repository.
 */
export type RepositoryInfo = {
    /**
     * Type
     *
     * Repository type identifier
     */
    type: string;
    /**
     * Name
     *
     * Repository name
     */
    name: string;
    /**
     * Description
     *
     * Repository description
     */
    description: string;
    /**
     * Enabled
     *
     * Whether repository is enabled
     */
    enabled: boolean;
    /**
     * Coming Soon
     *
     * Whether repository is coming soon
     */
    coming_soon: boolean;
    /**
     * Plans
     *
     * Available plans
     */
    plans: Array<OfferingRepositoryPlan>;
};

/**
 * RepositorySubscriptions
 *
 * Repository subscription offerings.
 *
 * Repository subscriptions are per-organization, not per-graph. All members
 * of an organization share access to subscribed repositories.
 */
export type RepositorySubscriptions = {
    /**
     * Description
     *
     * Description of repository subscriptions
     */
    description: string;
    /**
     * Pricing Model
     *
     * Pricing model type (per_graph or per_organization)
     */
    pricing_model: string;
    /**
     * Repositories
     *
     * Available repositories
     */
    repositories: Array<RepositoryInfo>;
    /**
     * Notes
     *
     * Important notes
     */
    notes: Array<string>;
};

/**
 * ResetPasswordRequest
 *
 * Reset password request model.
 */
export type ResetPasswordRequest = {
    /**
     * Token
     *
     * Password reset token from email link
     */
    token: string;
    /**
     * New Password
     *
     * New password (must meet security requirements)
     */
    new_password: string;
};

/**
 * ResetPasswordValidateResponse
 *
 * Password reset token validation response model.
 */
export type ResetPasswordValidateResponse = {
    /**
     * Valid
     *
     * Whether the token is valid
     */
    valid: boolean;
    /**
     * Email
     *
     * Masked email address if token is valid
     */
    email?: string | null;
};

/**
 * ResponseMode
 *
 * Response modes for execution.
 */
export type ResponseMode = 'auto' | 'sync' | 'async' | 'stream';

/**
 * SSOCompleteRequest
 *
 * SSO completion request model.
 */
export type SsoCompleteRequest = {
    /**
     * Session Id
     *
     * Temporary session ID from secure handoff
     */
    session_id: string;
};

/**
 * SSOExchangeRequest
 *
 * SSO token exchange request model.
 */
export type SsoExchangeRequest = {
    /**
     * Token
     *
     * Temporary SSO token
     */
    token: string;
    /**
     * Target App
     *
     * Target application identifier
     */
    target_app: string;
    /**
     * Return Url
     *
     * Optional return URL after authentication
     */
    return_url?: string | null;
};

/**
 * SSOExchangeResponse
 *
 * SSO token exchange response model.
 */
export type SsoExchangeResponse = {
    /**
     * Session Id
     *
     * Temporary session ID for secure handoff
     */
    session_id: string;
    /**
     * Redirect Url
     *
     * URL to redirect to for authentication
     */
    redirect_url: string;
    /**
     * Expires At
     *
     * Session expiration time
     */
    expires_at: string;
};

/**
 * SSOTokenResponse
 *
 * SSO token response model.
 */
export type SsoTokenResponse = {
    /**
     * Token
     *
     * Temporary SSO token for cross-app authentication
     */
    token: string;
    /**
     * Expires At
     *
     * Token expiration time
     */
    expires_at: string;
    /**
     * Apps
     *
     * Available apps for this user
     */
    apps: Array<string>;
};

/**
 * SchemaExportResponse
 *
 * Response model for schema export.
 */
export type SchemaExportResponse = {
    /**
     * Graph Id
     *
     * Graph ID
     */
    graph_id: string;
    /**
     * Schema Definition
     *
     * Exported schema definition (format depends on 'format' parameter)
     */
    schema_definition: {
        [key: string]: unknown;
    } | string;
    /**
     * Format
     *
     * Export format used
     */
    format: string;
    /**
     * Exported At
     *
     * Export timestamp
     */
    exported_at: string;
    /**
     * Data Stats
     *
     * Data statistics if requested (only when include_data_stats=true)
     */
    data_stats?: {
        [key: string]: unknown;
    } | null;
};

/**
 * SchemaInfoResponse
 *
 * Response model for runtime schema introspection.
 *
 * This model represents the actual current state of the graph database,
 * showing what node labels, relationship types, and properties exist right now.
 */
export type SchemaInfoResponse = {
    /**
     * Graph Id
     *
     * Graph database identifier
     */
    graph_id: string;
    /**
     * Schema
     *
     * Runtime schema information showing actual database structure
     */
    schema: {
        [key: string]: unknown;
    };
};

/**
 * SchemaValidationRequest
 *
 * Request model for schema validation.
 */
export type SchemaValidationRequest = {
    /**
     * Schema Definition
     *
     * Schema definition as JSON dict or JSON/YAML string
     */
    schema_definition: {
        [key: string]: unknown;
    } | string;
    /**
     * Format
     *
     * Schema format: json, yaml, or dict
     */
    format?: string;
    /**
     * Check Compatibility
     *
     * List of existing schema extensions to check compatibility with
     */
    check_compatibility?: Array<string> | null;
};

/**
 * SchemaValidationResponse
 *
 * Response model for schema validation.
 */
export type SchemaValidationResponse = {
    /**
     * Valid
     *
     * Whether the schema is valid
     */
    valid: boolean;
    /**
     * Message
     *
     * Validation message
     */
    message: string;
    /**
     * Errors
     *
     * List of validation errors (only present when valid=false)
     */
    errors?: Array<string> | null;
    /**
     * Warnings
     *
     * List of validation warnings (schema is still valid but has potential issues)
     */
    warnings?: Array<string> | null;
    /**
     * Stats
     *
     * Schema statistics (only present when valid=true)
     */
    stats?: {
        [key: string]: number;
    } | null;
    /**
     * Compatibility
     *
     * Compatibility check results (only when check_compatibility specified)
     */
    compatibility?: {
        [key: string]: unknown;
    } | null;
};

/**
 * SelectionCriteria
 *
 * Criteria for agent selection.
 */
export type SelectionCriteria = {
    /**
     * Min Confidence
     *
     * Minimum confidence score
     */
    min_confidence?: number;
    /**
     * Required Capabilities
     *
     * Required agent capabilities
     */
    required_capabilities?: Array<string>;
    /**
     * Preferred execution mode
     */
    preferred_mode?: AgentMode | null;
    /**
     * Max Response Time
     *
     * Maximum response time in seconds
     */
    max_response_time?: number;
    /**
     * Excluded Agents
     *
     * Agents to exclude from selection
     */
    excluded_agents?: Array<string>;
};

/**
 * ServiceOfferingSummary
 *
 * Summary of service offerings.
 */
export type ServiceOfferingSummary = {
    /**
     * Total Graph Tiers
     *
     * Total number of graph tiers
     */
    total_graph_tiers: number;
    /**
     * Total Repositories
     *
     * Total number of repositories
     */
    total_repositories: number;
    /**
     * Enabled Repositories
     *
     * Number of enabled repositories
     */
    enabled_repositories: number;
    /**
     * Coming Soon Repositories
     *
     * Number of coming soon repositories
     */
    coming_soon_repositories: number;
};

/**
 * ServiceOfferingsResponse
 *
 * Complete service offerings response.
 */
export type ServiceOfferingsResponse = {
    /**
     * Billing Enabled
     *
     * Whether billing and payments are enabled
     */
    billing_enabled: boolean;
    /**
     * Graph subscription offerings
     */
    graph_subscriptions: GraphSubscriptions;
    /**
     * Repository subscription offerings
     */
    repository_subscriptions: RepositorySubscriptions;
    /**
     * Operation cost information
     */
    operation_costs: OperationCosts;
    /**
     * Summary information
     */
    summary: ServiceOfferingSummary;
};

/**
 * StorageLimitResponse
 *
 * Storage limit information response.
 */
export type StorageLimitResponse = {
    /**
     * Graph Id
     */
    graph_id: string;
    /**
     * Current Storage Gb
     */
    current_storage_gb: number;
    /**
     * Effective Limit Gb
     */
    effective_limit_gb: number;
    /**
     * Usage Percentage
     */
    usage_percentage: number;
    /**
     * Within Limit
     */
    within_limit: boolean;
    /**
     * Approaching Limit
     */
    approaching_limit: boolean;
    /**
     * Needs Warning
     */
    needs_warning: boolean;
    /**
     * Has Override
     */
    has_override: boolean;
    /**
     * Recommendations
     */
    recommendations?: Array<string> | null;
};

/**
 * StorageLimits
 *
 * Storage limits information.
 */
export type StorageLimits = {
    /**
     * Current Usage Gb
     *
     * Current storage usage in GB
     */
    current_usage_gb?: number | null;
    /**
     * Max Storage Gb
     *
     * Maximum storage limit in GB
     */
    max_storage_gb: number;
    /**
     * Approaching Limit
     *
     * Whether approaching storage limit (>80%)
     */
    approaching_limit: boolean;
};

/**
 * StorageSummary
 *
 * Storage usage summary.
 */
export type StorageSummary = {
    /**
     * Graph Tier
     *
     * Subscription tier
     */
    graph_tier: string;
    /**
     * Avg Storage Gb
     *
     * Average storage in GB
     */
    avg_storage_gb: number;
    /**
     * Max Storage Gb
     *
     * Peak storage in GB
     */
    max_storage_gb: number;
    /**
     * Min Storage Gb
     *
     * Minimum storage in GB
     */
    min_storage_gb: number;
    /**
     * Total Gb Hours
     *
     * Total GB-hours for billing
     */
    total_gb_hours: number;
    /**
     * Measurement Count
     *
     * Number of measurements taken
     */
    measurement_count: number;
};

/**
 * SubgraphQuotaResponse
 *
 * Response model for subgraph quota information.
 */
export type SubgraphQuotaResponse = {
    /**
     * Parent Graph Id
     *
     * Parent graph identifier
     */
    parent_graph_id: string;
    /**
     * Tier
     *
     * Graph tier
     */
    tier: string;
    /**
     * Current Count
     *
     * Current number of subgraphs
     */
    current_count: number;
    /**
     * Max Allowed
     *
     * Maximum allowed subgraphs (None = unlimited)
     */
    max_allowed?: number | null;
    /**
     * Remaining
     *
     * Remaining subgraphs that can be created
     */
    remaining?: number | null;
    /**
     * Total Size Mb
     *
     * Total size of all subgraphs
     */
    total_size_mb?: number | null;
    /**
     * Max Size Mb
     *
     * Maximum allowed total size
     */
    max_size_mb?: number | null;
};

/**
 * SubgraphResponse
 *
 * Response model for a subgraph.
 */
export type SubgraphResponse = {
    /**
     * Graph Id
     *
     * Full subgraph identifier (e.g., kg123_dev)
     */
    graph_id: string;
    /**
     * Parent Graph Id
     *
     * Parent graph identifier
     */
    parent_graph_id: string;
    /**
     * Subgraph Index
     *
     * Numeric index of the subgraph
     */
    subgraph_index: number;
    /**
     * Subgraph Name
     *
     * Alphanumeric name of the subgraph
     */
    subgraph_name: string;
    /**
     * Display Name
     *
     * Human-readable display name
     */
    display_name: string;
    /**
     * Description
     *
     * Description of the subgraph's purpose
     */
    description?: string | null;
    /**
     * Type of subgraph
     */
    subgraph_type: SubgraphType;
    /**
     * Status
     *
     * Current status of the subgraph
     */
    status: string;
    /**
     * Created At
     *
     * When the subgraph was created
     */
    created_at: string;
    /**
     * Updated At
     *
     * When the subgraph was last updated
     */
    updated_at: string;
    /**
     * Size Mb
     *
     * Size of the subgraph database in megabytes
     */
    size_mb?: number | null;
    /**
     * Node Count
     *
     * Number of nodes in the subgraph
     */
    node_count?: number | null;
    /**
     * Edge Count
     *
     * Number of edges in the subgraph
     */
    edge_count?: number | null;
    /**
     * Last Accessed
     *
     * When the subgraph was last accessed
     */
    last_accessed?: string | null;
    /**
     * Metadata
     *
     * Additional metadata for the subgraph
     */
    metadata?: {
        [key: string]: unknown;
    } | null;
};

/**
 * SubgraphSummary
 *
 * Summary model for listing subgraphs.
 */
export type SubgraphSummary = {
    /**
     * Graph Id
     *
     * Full subgraph identifier
     */
    graph_id: string;
    /**
     * Subgraph Name
     *
     * Alphanumeric name
     */
    subgraph_name: string;
    /**
     * Display Name
     *
     * Human-readable name
     */
    display_name: string;
    /**
     * Type of subgraph
     */
    subgraph_type: SubgraphType;
    /**
     * Status
     *
     * Current status
     */
    status: string;
    /**
     * Size Mb
     *
     * Size in megabytes
     */
    size_mb?: number | null;
    /**
     * Created At
     *
     * Creation timestamp
     */
    created_at: string;
    /**
     * Last Accessed
     *
     * Last access timestamp
     */
    last_accessed?: string | null;
};

/**
 * SubgraphType
 *
 * Types of subgraphs.
 */
export type SubgraphType = 'static' | 'temporal' | 'versioned' | 'memory';

/**
 * SuccessResponse
 *
 * Standard success response for operations without specific return data.
 */
export type SuccessResponse = {
    /**
     * Success
     *
     * Indicates the operation completed successfully
     */
    success?: boolean;
    /**
     * Message
     *
     * Human-readable success message
     */
    message: string;
    /**
     * Data
     *
     * Optional additional data related to the operation
     */
    data?: {
        [key: string]: unknown;
    } | null;
};

/**
 * TableInfo
 */
export type TableInfo = {
    /**
     * Table Name
     *
     * Table name
     */
    table_name: string;
    /**
     * Row Count
     *
     * Approximate row count
     */
    row_count: number;
    /**
     * File Count
     *
     * Number of files
     */
    file_count?: number;
    /**
     * Total Size Bytes
     *
     * Total size in bytes
     */
    total_size_bytes?: number;
    /**
     * S3 Location
     *
     * S3 location for external tables
     */
    s3_location?: string | null;
};

/**
 * TableListResponse
 */
export type TableListResponse = {
    /**
     * Tables
     *
     * List of tables
     */
    tables: Array<TableInfo>;
    /**
     * Total Count
     *
     * Total number of tables
     */
    total_count: number;
};

/**
 * TableQueryRequest
 */
export type TableQueryRequest = {
    /**
     * Sql
     *
     * SQL query to execute on staging tables. Use ? placeholders or $param_name for dynamic values to prevent SQL injection.
     */
    sql: string;
    /**
     * Parameters
     *
     * Query parameters for safe value substitution. ALWAYS use parameters instead of string concatenation.
     */
    parameters?: Array<unknown> | null;
};

/**
 * TableQueryResponse
 */
export type TableQueryResponse = {
    /**
     * Columns
     *
     * Column names
     */
    columns: Array<string>;
    /**
     * Rows
     *
     * Query results
     */
    rows: Array<Array<unknown>>;
    /**
     * Row Count
     *
     * Number of rows returned
     */
    row_count: number;
    /**
     * Execution Time Ms
     *
     * Query execution time
     */
    execution_time_ms: number;
};

/**
 * TokenPricing
 *
 * AI token pricing for a specific model.
 */
export type TokenPricing = {
    /**
     * Input Per 1K Tokens
     *
     * Credits per 1K input tokens
     */
    input_per_1k_tokens: number;
    /**
     * Output Per 1K Tokens
     *
     * Credits per 1K output tokens
     */
    output_per_1k_tokens: number;
};

/**
 * TransactionSummaryResponse
 *
 * Summary of transactions by operation type.
 */
export type TransactionSummaryResponse = {
    /**
     * Operation Type
     */
    operation_type: string;
    /**
     * Total Amount
     */
    total_amount: number;
    /**
     * Transaction Count
     */
    transaction_count: number;
    /**
     * Average Amount
     */
    average_amount: number;
    /**
     * First Transaction
     */
    first_transaction?: string | null;
    /**
     * Last Transaction
     */
    last_transaction?: string | null;
};

/**
 * UpcomingInvoice
 *
 * Upcoming invoice preview.
 */
export type UpcomingInvoice = {
    /**
     * Amount Due
     *
     * Estimated amount due in cents
     */
    amount_due: number;
    /**
     * Currency
     *
     * Currency code
     */
    currency: string;
    /**
     * Period Start
     *
     * Billing period start
     */
    period_start: string;
    /**
     * Period End
     *
     * Billing period end
     */
    period_end: string;
    /**
     * Line Items
     *
     * Estimated line items
     */
    line_items: Array<InvoiceLineItem>;
    /**
     * Subscription Id
     *
     * Associated subscription ID
     */
    subscription_id?: string | null;
};

/**
 * UpdateAPIKeyRequest
 *
 * Request model for updating an API key.
 */
export type UpdateApiKeyRequest = {
    /**
     * Name
     *
     * New name for the API key
     */
    name?: string | null;
    /**
     * Description
     *
     * New description
     */
    description?: string | null;
};

/**
 * UpdateMemberRoleRequest
 *
 * Request to update a member's role.
 */
export type UpdateMemberRoleRequest = {
    role: OrgRole;
};

/**
 * UpdateOrgRequest
 *
 * Request to update organization details.
 */
export type UpdateOrgRequest = {
    /**
     * Name
     */
    name?: string | null;
    org_type?: OrgType | null;
};

/**
 * UpdatePasswordRequest
 *
 * Request model for updating user password.
 */
export type UpdatePasswordRequest = {
    /**
     * Current Password
     *
     * Current password
     */
    current_password: string;
    /**
     * New Password
     *
     * New password
     */
    new_password: string;
    /**
     * Confirm Password
     *
     * Confirm new password
     */
    confirm_password: string;
};

/**
 * UpdateUserRequest
 *
 * Request model for updating user profile.
 */
export type UpdateUserRequest = {
    /**
     * Name
     *
     * User's display name
     */
    name?: string | null;
    /**
     * Email
     *
     * User's email address
     */
    email?: string | null;
};

/**
 * UpgradeSubscriptionRequest
 *
 * Request to upgrade a subscription.
 */
export type UpgradeSubscriptionRequest = {
    /**
     * New Plan Name
     *
     * New plan name to upgrade to
     */
    new_plan_name: string;
};

/**
 * UserGraphsResponse
 *
 * User graphs response model.
 */
export type UserGraphsResponse = {
    /**
     * Graphs
     *
     * List of accessible graphs
     */
    graphs: Array<GraphInfo>;
    /**
     * Selectedgraphid
     *
     * Currently selected graph ID
     */
    selectedGraphId?: string | null;
};

/**
 * UserResponse
 *
 * User information response model.
 */
export type UserResponse = {
    /**
     * Id
     *
     * Unique identifier for the user
     */
    id: string;
    /**
     * Name
     *
     * User's display name
     */
    name?: string | null;
    /**
     * Email
     *
     * User's email address
     */
    email?: string | null;
    /**
     * Accounts
     *
     * User's authentication accounts
     */
    accounts?: Array<AccountInfo>;
};

/**
 * ValidationError
 */
export type ValidationError = {
    /**
     * Location
     */
    loc: Array<string | number>;
    /**
     * Message
     */
    msg: string;
    /**
     * Error Type
     */
    type: string;
    /**
     * Input
     */
    input?: unknown;
    /**
     * Context
     */
    ctx?: {
        [key: string]: unknown;
    };
};

export type RegisterUserData = {
    body: RegisterRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/register';
};

export type RegisterUserErrors = {
    /**
     * Invalid request data or missing CAPTCHA token (production only)
     */
    400: ErrorResponse;
    /**
     * Email already registered
     */
    409: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Registration temporarily disabled
     */
    503: ErrorResponse;
};

export type RegisterUserError = RegisterUserErrors[keyof RegisterUserErrors];

export type RegisterUserResponses = {
    /**
     * Successful Response
     */
    201: AuthResponse;
};

export type RegisterUserResponse = RegisterUserResponses[keyof RegisterUserResponses];

export type LoginUserData = {
    body: LoginRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/login';
};

export type LoginUserErrors = {
    /**
     * Invalid request data
     */
    400: ErrorResponse;
    /**
     * Invalid credentials
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type LoginUserError = LoginUserErrors[keyof LoginUserErrors];

export type LoginUserResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type LoginUserResponse = LoginUserResponses[keyof LoginUserResponses];

export type LogoutUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/logout';
};

export type LogoutUserResponses = {
    /**
     * Response Logoutuser
     *
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type LogoutUserResponse = LogoutUserResponses[keyof LogoutUserResponses];

export type GetCurrentAuthUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/me';
};

export type GetCurrentAuthUserErrors = {
    /**
     * Not authenticated
     */
    401: ErrorResponse;
};

export type GetCurrentAuthUserError = GetCurrentAuthUserErrors[keyof GetCurrentAuthUserErrors];

export type GetCurrentAuthUserResponses = {
    /**
     * Response Getcurrentauthuser
     *
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetCurrentAuthUserResponse = GetCurrentAuthUserResponses[keyof GetCurrentAuthUserResponses];

export type RefreshAuthSessionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/refresh';
};

export type RefreshAuthSessionErrors = {
    /**
     * Not authenticated
     */
    401: ErrorResponse;
};

export type RefreshAuthSessionError = RefreshAuthSessionErrors[keyof RefreshAuthSessionErrors];

export type RefreshAuthSessionResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type RefreshAuthSessionResponse = RefreshAuthSessionResponses[keyof RefreshAuthSessionResponses];

export type ResendVerificationEmailData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/email/resend';
};

export type ResendVerificationEmailErrors = {
    /**
     * Email already verified
     */
    400: ErrorResponse;
    /**
     * Rate limit exceeded
     */
    429: ErrorResponse;
    /**
     * Email service unavailable
     */
    503: ErrorResponse;
};

export type ResendVerificationEmailError = ResendVerificationEmailErrors[keyof ResendVerificationEmailErrors];

export type ResendVerificationEmailResponses = {
    /**
     * Response Resendverificationemail
     *
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type ResendVerificationEmailResponse = ResendVerificationEmailResponses[keyof ResendVerificationEmailResponses];

export type VerifyEmailData = {
    body: EmailVerificationRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/email/verify';
};

export type VerifyEmailErrors = {
    /**
     * Invalid or expired token
     */
    400: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type VerifyEmailError = VerifyEmailErrors[keyof VerifyEmailErrors];

export type VerifyEmailResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type VerifyEmailResponse = VerifyEmailResponses[keyof VerifyEmailResponses];

export type GetPasswordPolicyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/password/policy';
};

export type GetPasswordPolicyResponses = {
    /**
     * Password policy requirements
     */
    200: PasswordPolicyResponse;
};

export type GetPasswordPolicyResponse = GetPasswordPolicyResponses[keyof GetPasswordPolicyResponses];

export type CheckPasswordStrengthData = {
    body: PasswordCheckRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/password/check';
};

export type CheckPasswordStrengthErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CheckPasswordStrengthError = CheckPasswordStrengthErrors[keyof CheckPasswordStrengthErrors];

export type CheckPasswordStrengthResponses = {
    /**
     * Password strength analysis
     */
    200: PasswordCheckResponse;
};

export type CheckPasswordStrengthResponse = CheckPasswordStrengthResponses[keyof CheckPasswordStrengthResponses];

export type ForgotPasswordData = {
    body: ForgotPasswordRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/password/forgot';
};

export type ForgotPasswordErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: ErrorResponse;
};

export type ForgotPasswordError = ForgotPasswordErrors[keyof ForgotPasswordErrors];

export type ForgotPasswordResponses = {
    /**
     * Response Forgotpassword
     *
     * Successful Response
     */
    200: {
        [key: string]: unknown;
    };
};

export type ForgotPasswordResponse = ForgotPasswordResponses[keyof ForgotPasswordResponses];

export type ValidateResetTokenData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Token
         *
         * Password reset token
         */
        token: string;
    };
    url: '/v1/auth/password/reset/validate';
};

export type ValidateResetTokenErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ValidateResetTokenError = ValidateResetTokenErrors[keyof ValidateResetTokenErrors];

export type ValidateResetTokenResponses = {
    /**
     * Successful Response
     */
    200: ResetPasswordValidateResponse;
};

export type ValidateResetTokenResponse = ValidateResetTokenResponses[keyof ValidateResetTokenResponses];

export type ResetPasswordData = {
    body: ResetPasswordRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/password/reset';
};

export type ResetPasswordErrors = {
    /**
     * Invalid token or password
     */
    400: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ResetPasswordError = ResetPasswordErrors[keyof ResetPasswordErrors];

export type ResetPasswordResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type ResetPasswordResponse = ResetPasswordResponses[keyof ResetPasswordResponses];

export type GenerateSsoTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/sso-token';
};

export type GenerateSsoTokenErrors = {
    /**
     * Not authenticated
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GenerateSsoTokenError = GenerateSsoTokenErrors[keyof GenerateSsoTokenErrors];

export type GenerateSsoTokenResponses = {
    /**
     * Successful Response
     */
    200: SsoTokenResponse;
};

export type GenerateSsoTokenResponse = GenerateSsoTokenResponses[keyof GenerateSsoTokenResponses];

export type SsoTokenExchangeData = {
    body: SsoExchangeRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/sso-exchange';
};

export type SsoTokenExchangeErrors = {
    /**
     * Invalid request data
     */
    400: ErrorResponse;
    /**
     * Invalid SSO token
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type SsoTokenExchangeError = SsoTokenExchangeErrors[keyof SsoTokenExchangeErrors];

export type SsoTokenExchangeResponses = {
    /**
     * Successful Response
     */
    200: SsoExchangeResponse;
};

export type SsoTokenExchangeResponse = SsoTokenExchangeResponses[keyof SsoTokenExchangeResponses];

export type CompleteSsoAuthData = {
    body: SsoCompleteRequest;
    path?: never;
    query?: never;
    url: '/v1/auth/sso-complete';
};

export type CompleteSsoAuthErrors = {
    /**
     * Invalid session
     */
    401: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CompleteSsoAuthError = CompleteSsoAuthErrors[keyof CompleteSsoAuthErrors];

export type CompleteSsoAuthResponses = {
    /**
     * Successful Response
     */
    200: AuthResponse;
};

export type CompleteSsoAuthResponse = CompleteSsoAuthResponses[keyof CompleteSsoAuthResponses];

export type GetCaptchaConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/auth/captcha/config';
};

export type GetCaptchaConfigResponses = {
    /**
     * CAPTCHA configuration
     */
    200: unknown;
};

export type GetServiceStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/status';
};

export type GetServiceStatusResponses = {
    /**
     * Service is healthy
     */
    200: HealthStatus;
};

export type GetServiceStatusResponse = GetServiceStatusResponses[keyof GetServiceStatusResponses];

export type GetCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/user';
};

export type GetCurrentUserResponses = {
    /**
     * Successful Response
     */
    200: UserResponse;
};

export type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type UpdateUserData = {
    body: UpdateUserRequest;
    path?: never;
    query?: never;
    url: '/v1/user';
};

export type UpdateUserErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];

export type UpdateUserResponses = {
    /**
     * Successful Response
     */
    200: UserResponse;
};

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export type UpdateUserPasswordData = {
    body: UpdatePasswordRequest;
    path?: never;
    query?: never;
    url: '/v1/user/password';
};

export type UpdateUserPasswordErrors = {
    /**
     * Invalid password or validation error
     */
    400: ErrorResponse;
    /**
     * User not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Error updating password
     */
    500: ErrorResponse;
};

export type UpdateUserPasswordError = UpdateUserPasswordErrors[keyof UpdateUserPasswordErrors];

export type UpdateUserPasswordResponses = {
    /**
     * Password updated successfully
     */
    200: SuccessResponse;
};

export type UpdateUserPasswordResponse = UpdateUserPasswordResponses[keyof UpdateUserPasswordResponses];

export type ListUserApiKeysData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/user/api-keys';
};

export type ListUserApiKeysResponses = {
    /**
     * Successful Response
     */
    200: ApiKeysResponse;
};

export type ListUserApiKeysResponse = ListUserApiKeysResponses[keyof ListUserApiKeysResponses];

export type CreateUserApiKeyData = {
    body: CreateApiKeyRequest;
    path?: never;
    query?: never;
    url: '/v1/user/api-keys';
};

export type CreateUserApiKeyErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateUserApiKeyError = CreateUserApiKeyErrors[keyof CreateUserApiKeyErrors];

export type CreateUserApiKeyResponses = {
    /**
     * Successful Response
     */
    201: CreateApiKeyResponse;
};

export type CreateUserApiKeyResponse = CreateUserApiKeyResponses[keyof CreateUserApiKeyResponses];

export type RevokeUserApiKeyData = {
    body?: never;
    path: {
        /**
         * Api Key Id
         */
        api_key_id: string;
    };
    query?: never;
    url: '/v1/user/api-keys/{api_key_id}';
};

export type RevokeUserApiKeyErrors = {
    /**
     * API key not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Error revoking API key
     */
    500: ErrorResponse;
};

export type RevokeUserApiKeyError = RevokeUserApiKeyErrors[keyof RevokeUserApiKeyErrors];

export type RevokeUserApiKeyResponses = {
    /**
     * API key revoked successfully
     */
    200: SuccessResponse;
};

export type RevokeUserApiKeyResponse = RevokeUserApiKeyResponses[keyof RevokeUserApiKeyResponses];

export type UpdateUserApiKeyData = {
    body: UpdateApiKeyRequest;
    path: {
        /**
         * Api Key Id
         */
        api_key_id: string;
    };
    query?: never;
    url: '/v1/user/api-keys/{api_key_id}';
};

export type UpdateUserApiKeyErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UpdateUserApiKeyError = UpdateUserApiKeyErrors[keyof UpdateUserApiKeyErrors];

export type UpdateUserApiKeyResponses = {
    /**
     * Successful Response
     */
    200: ApiKeyInfo;
};

export type UpdateUserApiKeyResponse = UpdateUserApiKeyResponses[keyof UpdateUserApiKeyResponses];

export type ListUserOrgsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/orgs';
};

export type ListUserOrgsResponses = {
    /**
     * Successful Response
     */
    200: OrgListResponse;
};

export type ListUserOrgsResponse = ListUserOrgsResponses[keyof ListUserOrgsResponses];

export type CreateOrgData = {
    body: CreateOrgRequest;
    path?: never;
    query?: never;
    url: '/v1/orgs';
};

export type CreateOrgErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateOrgError = CreateOrgErrors[keyof CreateOrgErrors];

export type CreateOrgResponses = {
    /**
     * Successful Response
     */
    201: OrgDetailResponse;
};

export type CreateOrgResponse = CreateOrgResponses[keyof CreateOrgResponses];

export type GetOrgData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/orgs/{org_id}';
};

export type GetOrgErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetOrgError = GetOrgErrors[keyof GetOrgErrors];

export type GetOrgResponses = {
    /**
     * Successful Response
     */
    200: OrgDetailResponse;
};

export type GetOrgResponse = GetOrgResponses[keyof GetOrgResponses];

export type UpdateOrgData = {
    body: UpdateOrgRequest;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/orgs/{org_id}';
};

export type UpdateOrgErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UpdateOrgError = UpdateOrgErrors[keyof UpdateOrgErrors];

export type UpdateOrgResponses = {
    /**
     * Successful Response
     */
    200: OrgDetailResponse;
};

export type UpdateOrgResponse = UpdateOrgResponses[keyof UpdateOrgResponses];

export type ListOrgGraphsData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/orgs/{org_id}/graphs';
};

export type ListOrgGraphsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListOrgGraphsError = ListOrgGraphsErrors[keyof ListOrgGraphsErrors];

export type ListOrgGraphsResponses = {
    /**
     * Response Listorggraphs
     *
     * Successful Response
     */
    200: Array<{
        [key: string]: unknown;
    }>;
};

export type ListOrgGraphsResponse = ListOrgGraphsResponses[keyof ListOrgGraphsResponses];

export type ListOrgMembersData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/orgs/{org_id}/members';
};

export type ListOrgMembersErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListOrgMembersError = ListOrgMembersErrors[keyof ListOrgMembersErrors];

export type ListOrgMembersResponses = {
    /**
     * Successful Response
     */
    200: OrgMemberListResponse;
};

export type ListOrgMembersResponse = ListOrgMembersResponses[keyof ListOrgMembersResponses];

export type InviteOrgMemberData = {
    body: InviteMemberRequest;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/orgs/{org_id}/members';
};

export type InviteOrgMemberErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type InviteOrgMemberError = InviteOrgMemberErrors[keyof InviteOrgMemberErrors];

export type InviteOrgMemberResponses = {
    /**
     * Successful Response
     */
    201: OrgMemberResponse;
};

export type InviteOrgMemberResponse = InviteOrgMemberResponses[keyof InviteOrgMemberResponses];

export type RemoveOrgMemberData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
        /**
         * User Id
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/orgs/{org_id}/members/{user_id}';
};

export type RemoveOrgMemberErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type RemoveOrgMemberError = RemoveOrgMemberErrors[keyof RemoveOrgMemberErrors];

export type RemoveOrgMemberResponses = {
    /**
     * Successful Response
     */
    204: void;
};

export type RemoveOrgMemberResponse = RemoveOrgMemberResponses[keyof RemoveOrgMemberResponses];

export type UpdateOrgMemberRoleData = {
    body: UpdateMemberRoleRequest;
    path: {
        /**
         * Org Id
         */
        org_id: string;
        /**
         * User Id
         */
        user_id: string;
    };
    query?: never;
    url: '/v1/orgs/{org_id}/members/{user_id}';
};

export type UpdateOrgMemberRoleErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UpdateOrgMemberRoleError = UpdateOrgMemberRoleErrors[keyof UpdateOrgMemberRoleErrors];

export type UpdateOrgMemberRoleResponses = {
    /**
     * Successful Response
     */
    200: OrgMemberResponse;
};

export type UpdateOrgMemberRoleResponse = UpdateOrgMemberRoleResponses[keyof UpdateOrgMemberRoleResponses];

export type GetOrgLimitsData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/orgs/{org_id}/limits';
};

export type GetOrgLimitsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetOrgLimitsError = GetOrgLimitsErrors[keyof GetOrgLimitsErrors];

export type GetOrgLimitsResponses = {
    /**
     * Successful Response
     */
    200: OrgLimitsResponse;
};

export type GetOrgLimitsResponse = GetOrgLimitsResponses[keyof GetOrgLimitsResponses];

export type GetOrgUsageData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: {
        /**
         * Days
         */
        days?: number;
    };
    url: '/v1/orgs/{org_id}/usage';
};

export type GetOrgUsageErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetOrgUsageError = GetOrgUsageErrors[keyof GetOrgUsageErrors];

export type GetOrgUsageResponses = {
    /**
     * Successful Response
     */
    200: OrgUsageResponse;
};

export type GetOrgUsageResponse = GetOrgUsageResponses[keyof GetOrgUsageResponses];

export type ListAgentsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Capability
         *
         * Filter by capability (e.g., 'financial_analysis', 'rag_search')
         */
        capability?: string | null;
    };
    url: '/v1/graphs/{graph_id}/agent';
};

export type ListAgentsErrors = {
    /**
     * Unauthorized - Invalid or missing authentication
     */
    401: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListAgentsError = ListAgentsErrors[keyof ListAgentsErrors];

export type ListAgentsResponses = {
    /**
     * List of agents retrieved successfully
     */
    200: AgentListResponse;
};

export type ListAgentsResponse = ListAgentsResponses[keyof ListAgentsResponses];

export type AutoSelectAgentData = {
    body: AgentRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Mode
         *
         * Override execution mode: sync, async, stream, or auto
         */
        mode?: ResponseMode | null;
    };
    url: '/v1/graphs/{graph_id}/agent';
};

export type AutoSelectAgentErrors = {
    /**
     * Invalid request parameters
     */
    400: unknown;
    /**
     * Insufficient credits for selected agent
     */
    402: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: unknown;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type AutoSelectAgentError = AutoSelectAgentErrors[keyof AutoSelectAgentErrors];

export type AutoSelectAgentResponses = {
    /**
     * Query successfully processed by selected agent
     */
    200: AgentResponse;
    /**
     * Query queued for async processing with operation tracking
     */
    202: unknown;
};

export type AutoSelectAgentResponse = AutoSelectAgentResponses[keyof AutoSelectAgentResponses];

export type GetAgentMetadataData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
        /**
         * Agent Type
         *
         * Agent type identifier (e.g., 'financial', 'research', 'rag')
         */
        agent_type: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/agent/{agent_type}';
};

export type GetAgentMetadataErrors = {
    /**
     * Agent type not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetAgentMetadataError = GetAgentMetadataErrors[keyof GetAgentMetadataErrors];

export type GetAgentMetadataResponses = {
    /**
     * Agent metadata retrieved successfully
     */
    200: AgentMetadataResponse;
};

export type GetAgentMetadataResponse = GetAgentMetadataResponses[keyof GetAgentMetadataResponses];

export type ExecuteSpecificAgentData = {
    body: AgentRequest;
    path: {
        /**
         * Agent Type
         */
        agent_type: string;
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Mode
         *
         * Override execution mode: sync, async, stream, or auto
         */
        mode?: ResponseMode | null;
    };
    url: '/v1/graphs/{graph_id}/agent/{agent_type}';
};

export type ExecuteSpecificAgentErrors = {
    /**
     * Invalid agent type or request parameters
     */
    400: unknown;
    /**
     * Insufficient credits for specified agent
     */
    402: unknown;
    /**
     * Agent type not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: unknown;
    /**
     * Internal server error
     */
    500: ErrorResponse;
};

export type ExecuteSpecificAgentError = ExecuteSpecificAgentErrors[keyof ExecuteSpecificAgentErrors];

export type ExecuteSpecificAgentResponses = {
    /**
     * Query successfully processed by specified agent
     */
    200: AgentResponse;
    /**
     * Query queued for async processing with operation tracking
     */
    202: unknown;
};

export type ExecuteSpecificAgentResponse = ExecuteSpecificAgentResponses[keyof ExecuteSpecificAgentResponses];

export type BatchProcessQueriesData = {
    body: BatchAgentRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/agent/batch';
};

export type BatchProcessQueriesErrors = {
    /**
     * Invalid batch request or too many queries
     */
    400: unknown;
    /**
     * Insufficient credits for batch processing
     */
    402: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error during batch processing
     */
    500: unknown;
};

export type BatchProcessQueriesError = BatchProcessQueriesErrors[keyof BatchProcessQueriesErrors];

export type BatchProcessQueriesResponses = {
    /**
     * Batch processing completed successfully
     */
    200: BatchAgentResponse;
};

export type BatchProcessQueriesResponse = BatchProcessQueriesResponses[keyof BatchProcessQueriesResponses];

export type RecommendAgentData = {
    body: AgentRecommendationRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/agent/recommend';
};

export type RecommendAgentErrors = {
    /**
     * Invalid recommendation request
     */
    400: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type RecommendAgentError = RecommendAgentErrors[keyof RecommendAgentErrors];

export type RecommendAgentResponses = {
    /**
     * Recommendations generated successfully
     */
    200: AgentRecommendationResponse;
};

export type RecommendAgentResponse = RecommendAgentResponses[keyof RecommendAgentResponses];

export type ListMcpToolsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/mcp/tools';
};

export type ListMcpToolsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve MCP tools
     */
    500: ErrorResponse;
};

export type ListMcpToolsError = ListMcpToolsErrors[keyof ListMcpToolsErrors];

export type ListMcpToolsResponses = {
    /**
     * MCP tools retrieved successfully
     */
    200: McpToolsResponse;
};

export type ListMcpToolsResponse = ListMcpToolsResponses[keyof ListMcpToolsResponses];

export type CallMcpToolData = {
    body: McpToolCall;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Format
         *
         * Response format override (json, sse, ndjson)
         */
        format?: string | null;
        /**
         * Test Mode
         *
         * Enable test mode for debugging
         */
        test_mode?: boolean;
    };
    url: '/v1/graphs/{graph_id}/mcp/call-tool';
};

export type CallMcpToolErrors = {
    /**
     * Invalid tool call
     */
    400: ErrorResponse;
    /**
     * Insufficient credits
     */
    402: ErrorResponse;
    /**
     * Access denied
     */
    403: ErrorResponse;
    /**
     * Execution timeout
     */
    408: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: ErrorResponse;
    /**
     * Internal error
     */
    500: ErrorResponse;
    /**
     * Service unavailable
     */
    503: ErrorResponse;
};

export type CallMcpToolError = CallMcpToolErrors[keyof CallMcpToolErrors];

export type CallMcpToolResponses = {
    /**
     * Tool executed successfully
     */
    200: unknown;
    /**
     * Tool queued for execution
     */
    202: unknown;
};

export type ListBackupsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Limit
         *
         * Maximum number of backups to return
         */
        limit?: number;
        /**
         * Offset
         *
         * Number of backups to skip
         */
        offset?: number;
    };
    url: '/v1/graphs/{graph_id}/backups';
};

export type ListBackupsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListBackupsError = ListBackupsErrors[keyof ListBackupsErrors];

export type ListBackupsResponses = {
    /**
     * Successful Response
     */
    200: BackupListResponse;
};

export type ListBackupsResponse = ListBackupsResponses[keyof ListBackupsResponses];

export type CreateBackupData = {
    body: BackupCreateRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/backups';
};

export type CreateBackupErrors = {
    /**
     * Invalid backup configuration
     */
    400: ErrorResponse;
    /**
     * Access denied - admin role required
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to initiate backup
     */
    500: ErrorResponse;
};

export type CreateBackupError = CreateBackupErrors[keyof CreateBackupErrors];

export type CreateBackupResponses = {
    /**
     * Backup creation started
     */
    202: unknown;
};

export type GetBackupDownloadUrlData = {
    body?: never;
    path: {
        /**
         * Backup Id
         *
         * Backup identifier
         */
        backup_id: string;
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Expires In
         *
         * URL expiration time in seconds
         */
        expires_in?: number;
    };
    url: '/v1/graphs/{graph_id}/backups/{backup_id}/download';
};

export type GetBackupDownloadUrlErrors = {
    /**
     * Access denied or backup is encrypted
     */
    403: unknown;
    /**
     * Backup not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to generate download URL
     */
    500: unknown;
};

export type GetBackupDownloadUrlError = GetBackupDownloadUrlErrors[keyof GetBackupDownloadUrlErrors];

export type GetBackupDownloadUrlResponses = {
    /**
     * Download URL generated successfully
     */
    200: BackupDownloadUrlResponse;
};

export type GetBackupDownloadUrlResponse = GetBackupDownloadUrlResponses[keyof GetBackupDownloadUrlResponses];

export type RestoreBackupData = {
    body: BackupRestoreRequest;
    path: {
        /**
         * Backup Id
         *
         * Backup identifier
         */
        backup_id: string;
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/backups/{backup_id}/restore';
};

export type RestoreBackupErrors = {
    /**
     * Invalid restore configuration
     */
    400: ErrorResponse;
    /**
     * Access denied - admin role required
     */
    403: ErrorResponse;
    /**
     * Backup not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to initiate restore
     */
    500: ErrorResponse;
};

export type RestoreBackupError = RestoreBackupErrors[keyof RestoreBackupErrors];

export type RestoreBackupResponses = {
    /**
     * Restore started
     */
    202: unknown;
};

export type GetBackupStatsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/backups/stats';
};

export type GetBackupStatsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetBackupStatsError = GetBackupStatsErrors[keyof GetBackupStatsErrors];

export type GetBackupStatsResponses = {
    /**
     * Successful Response
     */
    200: BackupStatsResponse;
};

export type GetBackupStatsResponse = GetBackupStatsResponses[keyof GetBackupStatsResponses];

export type GetGraphMetricsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/analytics';
};

export type GetGraphMetricsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Graph not found or metrics unavailable
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve metrics
     */
    500: ErrorResponse;
};

export type GetGraphMetricsError = GetGraphMetricsErrors[keyof GetGraphMetricsErrors];

export type GetGraphMetricsResponses = {
    /**
     * Graph metrics retrieved successfully
     */
    200: GraphMetricsResponse;
};

export type GetGraphMetricsResponse = GetGraphMetricsResponses[keyof GetGraphMetricsResponses];

export type GetGraphUsageAnalyticsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Time Range
         *
         * Time range: 24h, 7d, 30d, current_month, last_month
         */
        time_range?: string;
        /**
         * Include Storage
         *
         * Include storage usage summary
         */
        include_storage?: boolean;
        /**
         * Include Credits
         *
         * Include credit consumption summary
         */
        include_credits?: boolean;
        /**
         * Include Performance
         *
         * Include performance insights (may be slower)
         */
        include_performance?: boolean;
        /**
         * Include Events
         *
         * Include recent usage events
         */
        include_events?: boolean;
    };
    url: '/v1/graphs/{graph_id}/analytics/usage';
};

export type GetGraphUsageAnalyticsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve usage analytics
     */
    500: ErrorResponse;
};

export type GetGraphUsageAnalyticsError = GetGraphUsageAnalyticsErrors[keyof GetGraphUsageAnalyticsErrors];

export type GetGraphUsageAnalyticsResponses = {
    /**
     * Usage analytics retrieved successfully
     */
    200: GraphUsageResponse;
};

export type GetGraphUsageAnalyticsResponse = GetGraphUsageAnalyticsResponses[keyof GetGraphUsageAnalyticsResponses];

export type ExecuteCypherQueryData = {
    body: CypherQueryRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Mode
         *
         * Response mode override
         */
        mode?: ResponseMode | null;
        /**
         * Chunk Size
         *
         * Rows per chunk for streaming
         */
        chunk_size?: number | null;
        /**
         * Test Mode
         *
         * Enable test mode for better debugging
         */
        test_mode?: boolean;
    };
    url: '/v1/graphs/{graph_id}/query';
};

export type ExecuteCypherQueryErrors = {
    /**
     * Invalid query or parameters
     */
    400: unknown;
    /**
     * Access denied
     */
    403: unknown;
    /**
     * Query timeout
     */
    408: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Rate limit exceeded
     */
    429: unknown;
    /**
     * Internal error
     */
    500: unknown;
    /**
     * Service unavailable
     */
    503: unknown;
};

export type ExecuteCypherQueryError = ExecuteCypherQueryErrors[keyof ExecuteCypherQueryErrors];

export type ExecuteCypherQueryResponses = {
    /**
     * Query executed successfully
     */
    200: {
        success?: boolean;
        data?: Array<{
            [key: string]: unknown;
        }>;
        columns?: Array<string>;
        row_count?: number;
        execution_time_ms?: number;
        graph_id?: string;
        timestamp?: string;
    };
    /**
     * Query queued for execution
     */
    202: unknown;
};

export type ExecuteCypherQueryResponse = ExecuteCypherQueryResponses[keyof ExecuteCypherQueryResponses];

export type GetGraphSchemaData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/schema';
};

export type GetGraphSchemaErrors = {
    /**
     * Access denied to graph
     */
    403: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve schema
     */
    500: unknown;
    /**
     * Schema operation timed out
     */
    504: unknown;
};

export type GetGraphSchemaError = GetGraphSchemaErrors[keyof GetGraphSchemaErrors];

export type GetGraphSchemaResponses = {
    /**
     * Schema information retrieved successfully
     */
    200: SchemaInfoResponse;
};

export type GetGraphSchemaResponse = GetGraphSchemaResponses[keyof GetGraphSchemaResponses];

export type ExportGraphSchemaData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Format
         *
         * Export format: json, yaml, or cypher
         */
        format?: string;
        /**
         * Include Data Stats
         *
         * Include statistics about actual data in the graph (node counts, relationship counts)
         */
        include_data_stats?: boolean;
    };
    url: '/v1/graphs/{graph_id}/schema/export';
};

export type ExportGraphSchemaErrors = {
    /**
     * Access denied to graph
     */
    403: unknown;
    /**
     * Schema not found for graph
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to export schema
     */
    500: unknown;
};

export type ExportGraphSchemaError = ExportGraphSchemaErrors[keyof ExportGraphSchemaErrors];

export type ExportGraphSchemaResponses = {
    /**
     * Schema exported successfully
     */
    200: SchemaExportResponse;
};

export type ExportGraphSchemaResponse = ExportGraphSchemaResponses[keyof ExportGraphSchemaResponses];

export type ValidateSchemaData = {
    /**
     * Schema definition to validate
     */
    body: SchemaValidationRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/schema/validate';
};

export type ValidateSchemaErrors = {
    /**
     * Invalid schema format
     */
    400: ErrorResponse;
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Schema validation failed
     */
    422: ErrorResponse;
    /**
     * Validation error
     */
    500: ErrorResponse;
};

export type ValidateSchemaError = ValidateSchemaErrors[keyof ValidateSchemaErrors];

export type ValidateSchemaResponses = {
    /**
     * Schema validation completed
     */
    200: SchemaValidationResponse;
};

export type ValidateSchemaResponse = ValidateSchemaResponses[keyof ValidateSchemaResponses];

export type GetCreditSummaryData = {
    body?: never;
    path: {
        /**
         * Graph Id
         *
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/credits/summary';
};

export type GetCreditSummaryErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Credit pool not found for graph
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve credit summary
     */
    500: ErrorResponse;
};

export type GetCreditSummaryError = GetCreditSummaryErrors[keyof GetCreditSummaryErrors];

export type GetCreditSummaryResponses = {
    /**
     * Credit summary retrieved successfully
     */
    200: CreditSummaryResponse;
};

export type GetCreditSummaryResponse = GetCreditSummaryResponses[keyof GetCreditSummaryResponses];

export type ListCreditTransactionsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         *
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Transaction Type
         *
         * Filter by transaction type (allocation, consumption, bonus, refund)
         */
        transaction_type?: string | null;
        /**
         * Operation Type
         *
         * Filter by operation type (e.g., entity_lookup, cypher_query)
         */
        operation_type?: string | null;
        /**
         * Start Date
         *
         * Start date for filtering (ISO format: YYYY-MM-DD)
         */
        start_date?: string | null;
        /**
         * End Date
         *
         * End date for filtering (ISO format: YYYY-MM-DD)
         */
        end_date?: string | null;
        /**
         * Limit
         *
         * Maximum number of transactions to return
         */
        limit?: number;
        /**
         * Offset
         *
         * Number of transactions to skip
         */
        offset?: number;
    };
    url: '/v1/graphs/{graph_id}/credits/transactions';
};

export type ListCreditTransactionsErrors = {
    /**
     * Invalid transaction type filter
     */
    400: ErrorResponse;
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve transactions
     */
    500: ErrorResponse;
};

export type ListCreditTransactionsError = ListCreditTransactionsErrors[keyof ListCreditTransactionsErrors];

export type ListCreditTransactionsResponses = {
    /**
     * Transaction history retrieved successfully
     */
    200: DetailedTransactionsResponse;
};

export type ListCreditTransactionsResponse = ListCreditTransactionsResponses[keyof ListCreditTransactionsResponses];

export type CheckCreditBalanceData = {
    body?: never;
    path: {
        /**
         * Graph Id
         *
         * Graph database identifier
         */
        graph_id: string;
    };
    query: {
        /**
         * Operation Type
         *
         * Type of operation to check
         */
        operation_type: string;
        /**
         * Base Cost
         *
         * Custom base cost (uses default if not provided)
         */
        base_cost?: number | string | null;
    };
    url: '/v1/graphs/{graph_id}/credits/balance/check';
};

export type CheckCreditBalanceErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Credit pool not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Credit check failed
     */
    500: ErrorResponse;
};

export type CheckCreditBalanceError = CheckCreditBalanceErrors[keyof CheckCreditBalanceErrors];

export type CheckCreditBalanceResponses = {
    /**
     * Response Checkcreditbalance
     *
     * Credit check completed
     */
    200: {
        [key: string]: unknown;
    };
};

export type CheckCreditBalanceResponse = CheckCreditBalanceResponses[keyof CheckCreditBalanceResponses];

export type GetStorageUsageData = {
    body?: never;
    path: {
        /**
         * Graph Id
         *
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: {
        /**
         * Days
         *
         * Number of days of history to return
         */
        days?: number;
    };
    url: '/v1/graphs/{graph_id}/credits/storage/usage';
};

export type GetStorageUsageErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve storage usage
     */
    500: ErrorResponse;
};

export type GetStorageUsageError = GetStorageUsageErrors[keyof GetStorageUsageErrors];

export type GetStorageUsageResponses = {
    /**
     * Response Getstorageusage
     *
     * Storage usage retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetStorageUsageResponse = GetStorageUsageResponses[keyof GetStorageUsageResponses];

export type CheckStorageLimitsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         *
         * Graph database identifier
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/credits/storage/limits';
};

export type CheckStorageLimitsErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * No credit pool found for graph
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve storage limits
     */
    500: ErrorResponse;
};

export type CheckStorageLimitsError = CheckStorageLimitsErrors[keyof CheckStorageLimitsErrors];

export type CheckStorageLimitsResponses = {
    /**
     * Storage limit information retrieved successfully
     */
    200: StorageLimitResponse;
};

export type CheckStorageLimitsResponse = CheckStorageLimitsResponses[keyof CheckStorageLimitsResponses];

export type GetDatabaseHealthData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/health';
};

export type GetDatabaseHealthErrors = {
    /**
     * Access denied to graph
     */
    403: unknown;
    /**
     * Graph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve health information
     */
    500: unknown;
};

export type GetDatabaseHealthError = GetDatabaseHealthErrors[keyof GetDatabaseHealthErrors];

export type GetDatabaseHealthResponses = {
    /**
     * Database health retrieved successfully
     */
    200: DatabaseHealthResponse;
};

export type GetDatabaseHealthResponse = GetDatabaseHealthResponses[keyof GetDatabaseHealthResponses];

export type GetDatabaseInfoData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/info';
};

export type GetDatabaseInfoErrors = {
    /**
     * Access denied to graph
     */
    403: unknown;
    /**
     * Graph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve database information
     */
    500: unknown;
};

export type GetDatabaseInfoError = GetDatabaseInfoErrors[keyof GetDatabaseInfoErrors];

export type GetDatabaseInfoResponses = {
    /**
     * Database information retrieved successfully
     */
    200: DatabaseInfoResponse;
};

export type GetDatabaseInfoResponse = GetDatabaseInfoResponses[keyof GetDatabaseInfoResponses];

export type GetGraphLimitsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/limits';
};

export type GetGraphLimitsErrors = {
    /**
     * Access denied to graph
     */
    403: unknown;
    /**
     * Graph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve limits
     */
    500: unknown;
};

export type GetGraphLimitsError = GetGraphLimitsErrors[keyof GetGraphLimitsErrors];

export type GetGraphLimitsResponses = {
    /**
     * Limits retrieved successfully
     */
    200: GraphLimitsResponse;
};

export type GetGraphLimitsResponse = GetGraphLimitsResponses[keyof GetGraphLimitsResponses];

export type ListSubgraphsData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/subgraphs';
};

export type ListSubgraphsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListSubgraphsError = ListSubgraphsErrors[keyof ListSubgraphsErrors];

export type ListSubgraphsResponses = {
    /**
     * Successful Response
     */
    200: ListSubgraphsResponse;
};

export type ListSubgraphsResponse2 = ListSubgraphsResponses[keyof ListSubgraphsResponses];

export type CreateSubgraphData = {
    body: CreateSubgraphRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/subgraphs';
};

export type CreateSubgraphErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateSubgraphError = CreateSubgraphErrors[keyof CreateSubgraphErrors];

export type CreateSubgraphResponses = {
    /**
     * Successful Response
     */
    200: SubgraphResponse;
};

export type CreateSubgraphResponse = CreateSubgraphResponses[keyof CreateSubgraphResponses];

export type DeleteSubgraphData = {
    body: DeleteSubgraphRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
        /**
         * Subgraph Name
         *
         * Subgraph name to delete (e.g., 'dev', 'staging')
         */
        subgraph_name: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_name}';
};

export type DeleteSubgraphErrors = {
    /**
     * Invalid subgraph identifier
     */
    400: unknown;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Insufficient permissions
     */
    403: unknown;
    /**
     * Subgraph not found
     */
    404: unknown;
    /**
     * Subgraph contains data (use force=true)
     */
    409: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeleteSubgraphError = DeleteSubgraphErrors[keyof DeleteSubgraphErrors];

export type DeleteSubgraphResponses = {
    /**
     * Subgraph deleted successfully
     */
    200: DeleteSubgraphResponse;
};

export type DeleteSubgraphResponse2 = DeleteSubgraphResponses[keyof DeleteSubgraphResponses];

export type GetSubgraphInfoData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
        /**
         * Subgraph Name
         *
         * Subgraph name (e.g., 'dev', 'staging')
         */
        subgraph_name: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/subgraphs/{subgraph_name}/info';
};

export type GetSubgraphInfoErrors = {
    /**
     * Not a valid subgraph
     */
    400: unknown;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied
     */
    403: unknown;
    /**
     * Subgraph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetSubgraphInfoError = GetSubgraphInfoErrors[keyof GetSubgraphInfoErrors];

export type GetSubgraphInfoResponses = {
    /**
     * Subgraph information retrieved
     */
    200: SubgraphResponse;
};

export type GetSubgraphInfoResponse = GetSubgraphInfoResponses[keyof GetSubgraphInfoResponses];

export type GetSubgraphQuotaData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/subgraphs/quota';
};

export type GetSubgraphQuotaErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied to parent graph
     */
    403: unknown;
    /**
     * Parent graph not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetSubgraphQuotaError = GetSubgraphQuotaErrors[keyof GetSubgraphQuotaErrors];

export type GetSubgraphQuotaResponses = {
    /**
     * Quota information retrieved
     */
    200: SubgraphQuotaResponse;
};

export type GetSubgraphQuotaResponse = GetSubgraphQuotaResponses[keyof GetSubgraphQuotaResponses];

export type GetGraphSubscriptionData = {
    body?: never;
    path: {
        /**
         * Graph Id
         *
         * Graph ID or repository name
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/subscriptions';
};

export type GetGraphSubscriptionErrors = {
    /**
     * No subscription found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetGraphSubscriptionError = GetGraphSubscriptionErrors[keyof GetGraphSubscriptionErrors];

export type GetGraphSubscriptionResponses = {
    /**
     * Subscription retrieved successfully
     */
    200: GraphSubscriptionResponse;
};

export type GetGraphSubscriptionResponse = GetGraphSubscriptionResponses[keyof GetGraphSubscriptionResponses];

export type CreateRepositorySubscriptionData = {
    body: CreateRepositorySubscriptionRequest;
    path: {
        /**
         * Graph Id
         *
         * Repository name (e.g., 'sec', 'industry')
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/subscriptions';
};

export type CreateRepositorySubscriptionErrors = {
    /**
     * Invalid request - cannot create subscription for user graphs
     */
    400: unknown;
    /**
     * User already has a subscription to this repository
     */
    409: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateRepositorySubscriptionError = CreateRepositorySubscriptionErrors[keyof CreateRepositorySubscriptionErrors];

export type CreateRepositorySubscriptionResponses = {
    /**
     * Repository subscription created successfully
     */
    201: GraphSubscriptionResponse;
};

export type CreateRepositorySubscriptionResponse = CreateRepositorySubscriptionResponses[keyof CreateRepositorySubscriptionResponses];

export type UpgradeSubscriptionData = {
    body: UpgradeSubscriptionRequest;
    path: {
        /**
         * Graph Id
         *
         * Graph ID or repository name
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/subscriptions/upgrade';
};

export type UpgradeSubscriptionErrors = {
    /**
     * No subscription found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UpgradeSubscriptionError = UpgradeSubscriptionErrors[keyof UpgradeSubscriptionErrors];

export type UpgradeSubscriptionResponses = {
    /**
     * Subscription upgraded successfully
     */
    200: GraphSubscriptionResponse;
};

export type UpgradeSubscriptionResponse = UpgradeSubscriptionResponses[keyof UpgradeSubscriptionResponses];

export type ListTablesData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/tables';
};

export type ListTablesErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - insufficient permissions for this graph
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListTablesError = ListTablesErrors[keyof ListTablesErrors];

export type ListTablesResponses = {
    /**
     * Tables retrieved successfully with full metrics
     */
    200: TableListResponse;
};

export type ListTablesResponse = ListTablesResponses[keyof ListTablesResponses];

export type QueryTablesData = {
    /**
     * SQL query request
     */
    body: TableQueryRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/tables/query';
};

export type QueryTablesErrors = {
    /**
     * Invalid SQL query syntax or execution error
     */
    400: ErrorResponse;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - shared repositories or insufficient permissions
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Query timeout exceeded
     */
    408: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type QueryTablesError = QueryTablesErrors[keyof QueryTablesErrors];

export type QueryTablesResponses = {
    /**
     * Query executed successfully
     */
    200: TableQueryResponse;
};

export type QueryTablesResponse = QueryTablesResponses[keyof QueryTablesResponses];

export type GetMaterializationStatusData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/materialize/status';
};

export type GetMaterializationStatusErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - insufficient permissions
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetMaterializationStatusError = GetMaterializationStatusErrors[keyof GetMaterializationStatusErrors];

export type GetMaterializationStatusResponses = {
    /**
     * Materialization status retrieved successfully
     */
    200: MaterializeStatusResponse;
};

export type GetMaterializationStatusResponse = GetMaterializationStatusResponses[keyof GetMaterializationStatusResponses];

export type MaterializeGraphData = {
    body: MaterializeRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/materialize';
};

export type MaterializeGraphErrors = {
    /**
     * Graph not stale and force=false
     */
    400: ErrorResponse;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - shared repositories or insufficient permissions
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Conflict - another materialization is already in progress for this graph
     */
    409: ErrorResponse;
    /**
     * Graph content limit exceeded - data too large for current tier
     */
    413: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Internal server error
     */
    500: unknown;
};

export type MaterializeGraphError = MaterializeGraphErrors[keyof MaterializeGraphErrors];

export type MaterializeGraphResponses = {
    /**
     * Graph materialized successfully
     */
    200: MaterializeResponse;
};

export type MaterializeGraphResponse = MaterializeGraphResponses[keyof MaterializeGraphResponses];

export type ListFilesData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: {
        /**
         * Table Name
         *
         * Filter by table name (optional)
         */
        table_name?: string | null;
        /**
         * Status
         *
         * Filter by upload status (optional)
         */
        status?: string | null;
    };
    url: '/v1/graphs/{graph_id}/files';
};

export type ListFilesErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - insufficient permissions
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListFilesError = ListFilesErrors[keyof ListFilesErrors];

export type ListFilesResponses = {
    /**
     * Files retrieved successfully
     */
    200: ListTableFilesResponse;
};

export type ListFilesResponse = ListFilesResponses[keyof ListFilesResponses];

export type CreateFileUploadData = {
    /**
     * Upload request with table_name
     */
    body: FileUploadRequest;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/files';
};

export type CreateFileUploadErrors = {
    /**
     * Invalid file format or parameters
     */
    400: ErrorResponse;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - shared repositories or insufficient permissions
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateFileUploadError = CreateFileUploadErrors[keyof CreateFileUploadErrors];

export type CreateFileUploadResponses = {
    /**
     * Upload URL generated successfully
     */
    200: FileUploadResponse;
};

export type CreateFileUploadResponse = CreateFileUploadResponses[keyof CreateFileUploadResponses];

export type DeleteFileData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
        /**
         * File Id
         *
         * File ID
         */
        file_id: string;
    };
    query?: {
        /**
         * Cascade
         *
         * If true, delete from all layers including DuckDB and mark graph stale
         */
        cascade?: boolean;
    };
    url: '/v1/graphs/{graph_id}/files/{file_id}';
};

export type DeleteFileErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - shared repositories or insufficient permissions
     */
    403: ErrorResponse;
    /**
     * File not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type DeleteFileError = DeleteFileErrors[keyof DeleteFileErrors];

export type DeleteFileResponses = {
    /**
     * File deleted successfully
     */
    200: DeleteFileResponse;
};

export type DeleteFileResponse2 = DeleteFileResponses[keyof DeleteFileResponses];

export type GetFileData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
        /**
         * File Id
         *
         * File ID
         */
        file_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/files/{file_id}';
};

export type GetFileErrors = {
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied - insufficient permissions
     */
    403: ErrorResponse;
    /**
     * File not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetFileError = GetFileErrors[keyof GetFileErrors];

export type GetFileResponses = {
    /**
     * File information retrieved successfully
     */
    200: GetFileInfoResponse;
};

export type GetFileResponse = GetFileResponses[keyof GetFileResponses];

export type UpdateFileData = {
    /**
     * Status update request
     */
    body: FileStatusUpdate;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
        /**
         * File Id
         *
         * File ID
         */
        file_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/files/{file_id}';
};

export type UpdateFileErrors = {
    /**
     * Invalid status or file not in S3
     */
    400: ErrorResponse;
    /**
     * Not authenticated
     */
    401: unknown;
    /**
     * Access denied
     */
    403: ErrorResponse;
    /**
     * File not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type UpdateFileError = UpdateFileErrors[keyof UpdateFileErrors];

export type UpdateFileResponses = {
    /**
     * Response Updatefile
     *
     * File status updated successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type UpdateFileResponse = UpdateFileResponses[keyof UpdateFileResponses];

export type GetGraphsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/graphs';
};

export type GetGraphsErrors = {
    /**
     * Error retrieving graphs
     */
    500: unknown;
};

export type GetGraphsResponses = {
    /**
     * Graphs retrieved successfully
     */
    200: UserGraphsResponse;
};

export type GetGraphsResponse = GetGraphsResponses[keyof GetGraphsResponses];

export type CreateGraphData = {
    body: CreateGraphRequest;
    path?: never;
    query?: never;
    url: '/v1/graphs';
};

export type CreateGraphErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateGraphError = CreateGraphErrors[keyof CreateGraphErrors];

export type CreateGraphResponses = {
    /**
     * Successful Response
     */
    202: unknown;
};

export type GetAvailableExtensionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/graphs/extensions';
};

export type GetAvailableExtensionsErrors = {
    /**
     * Failed to retrieve extensions
     */
    500: unknown;
};

export type GetAvailableExtensionsResponses = {
    /**
     * Extensions retrieved successfully
     */
    200: AvailableExtensionsResponse;
};

export type GetAvailableExtensionsResponse = GetAvailableExtensionsResponses[keyof GetAvailableExtensionsResponses];

export type GetAvailableGraphTiersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Include Disabled
         */
        include_disabled?: boolean;
    };
    url: '/v1/graphs/tiers';
};

export type GetAvailableGraphTiersErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve tiers
     */
    500: unknown;
};

export type GetAvailableGraphTiersError = GetAvailableGraphTiersErrors[keyof GetAvailableGraphTiersErrors];

export type GetAvailableGraphTiersResponses = {
    /**
     * Tiers retrieved successfully
     */
    200: AvailableGraphTiersResponse;
};

export type GetAvailableGraphTiersResponse = GetAvailableGraphTiersResponses[keyof GetAvailableGraphTiersResponses];

export type SelectGraphData = {
    body?: never;
    path: {
        /**
         * Graph Id
         */
        graph_id: string;
    };
    query?: never;
    url: '/v1/graphs/{graph_id}/select';
};

export type SelectGraphErrors = {
    /**
     * Access denied to graph
     */
    403: ErrorResponse;
    /**
     * Graph not found
     */
    404: ErrorResponse;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Error selecting graph
     */
    500: ErrorResponse;
};

export type SelectGraphError = SelectGraphErrors[keyof SelectGraphErrors];

export type SelectGraphResponses = {
    /**
     * Graph selected successfully
     */
    200: SuccessResponse;
};

export type SelectGraphResponse = SelectGraphResponses[keyof SelectGraphResponses];

export type GetServiceOfferingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/offering';
};

export type GetServiceOfferingsErrors = {
    /**
     * Failed to retrieve service offerings
     */
    500: ErrorResponse;
};

export type GetServiceOfferingsError = GetServiceOfferingsErrors[keyof GetServiceOfferingsErrors];

export type GetServiceOfferingsResponses = {
    /**
     * Complete service offerings retrieved successfully
     */
    200: ServiceOfferingsResponse;
};

export type GetServiceOfferingsResponse = GetServiceOfferingsResponses[keyof GetServiceOfferingsResponses];

export type StreamOperationEventsData = {
    body?: never;
    headers?: {
        /**
         * Authorization
         */
        authorization?: string | null;
    };
    path: {
        /**
         * Operation Id
         *
         * Operation identifier from initial submission
         */
        operation_id: string;
    };
    query?: {
        /**
         * From Sequence
         *
         * Start streaming from this sequence number (0 = from beginning)
         */
        from_sequence?: number;
        /**
         * Token
         *
         * JWT token for SSE authentication
         */
        token?: string | null;
    };
    url: '/v1/operations/{operation_id}/stream';
};

export type StreamOperationEventsErrors = {
    /**
     * Access denied to operation
     */
    403: unknown;
    /**
     * Operation not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to create event stream
     */
    500: unknown;
};

export type StreamOperationEventsError = StreamOperationEventsErrors[keyof StreamOperationEventsErrors];

export type StreamOperationEventsResponses = {
    /**
     * SSE stream of operation events
     */
    200: unknown;
};

export type GetOperationStatusData = {
    body?: never;
    path: {
        /**
         * Operation Id
         *
         * Operation identifier
         */
        operation_id: string;
    };
    query?: never;
    url: '/v1/operations/{operation_id}/status';
};

export type GetOperationStatusErrors = {
    /**
     * Access denied to operation
     */
    403: unknown;
    /**
     * Operation not found
     */
    404: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to retrieve operation status
     */
    500: unknown;
};

export type GetOperationStatusError = GetOperationStatusErrors[keyof GetOperationStatusErrors];

export type GetOperationStatusResponses = {
    /**
     * Response Getoperationstatus
     *
     * Operation status retrieved successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type GetOperationStatusResponse = GetOperationStatusResponses[keyof GetOperationStatusResponses];

export type CancelOperationData = {
    body?: never;
    path: {
        /**
         * Operation Id
         *
         * Operation identifier
         */
        operation_id: string;
    };
    query?: never;
    url: '/v1/operations/{operation_id}';
};

export type CancelOperationErrors = {
    /**
     * Access denied to operation
     */
    403: unknown;
    /**
     * Operation not found
     */
    404: unknown;
    /**
     * Operation cannot be cancelled (already completed)
     */
    409: unknown;
    /**
     * Validation Error
     */
    422: HttpValidationError;
    /**
     * Failed to cancel operation
     */
    500: unknown;
};

export type CancelOperationError = CancelOperationErrors[keyof CancelOperationErrors];

export type CancelOperationResponses = {
    /**
     * Response Canceloperation
     *
     * Operation cancelled successfully
     */
    200: {
        [key: string]: unknown;
    };
};

export type CancelOperationResponse = CancelOperationResponses[keyof CancelOperationResponses];

export type GetOrgBillingCustomerData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/billing/customer/{org_id}';
};

export type GetOrgBillingCustomerErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetOrgBillingCustomerError = GetOrgBillingCustomerErrors[keyof GetOrgBillingCustomerErrors];

export type GetOrgBillingCustomerResponses = {
    /**
     * Successful Response
     */
    200: BillingCustomer;
};

export type GetOrgBillingCustomerResponse = GetOrgBillingCustomerResponses[keyof GetOrgBillingCustomerResponses];

export type CreatePortalSessionData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/billing/customer/{org_id}/portal';
};

export type CreatePortalSessionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreatePortalSessionError = CreatePortalSessionErrors[keyof CreatePortalSessionErrors];

export type CreatePortalSessionResponses = {
    /**
     * Successful Response
     */
    200: PortalSessionResponse;
};

export type CreatePortalSessionResponse = CreatePortalSessionResponses[keyof CreatePortalSessionResponses];

export type ListOrgSubscriptionsData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/billing/subscriptions/{org_id}';
};

export type ListOrgSubscriptionsErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListOrgSubscriptionsError = ListOrgSubscriptionsErrors[keyof ListOrgSubscriptionsErrors];

export type ListOrgSubscriptionsResponses = {
    /**
     * Response Listorgsubscriptions
     *
     * Successful Response
     */
    200: Array<GraphSubscriptionResponse>;
};

export type ListOrgSubscriptionsResponse = ListOrgSubscriptionsResponses[keyof ListOrgSubscriptionsResponses];

export type GetOrgSubscriptionData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
        /**
         * Subscription Id
         */
        subscription_id: string;
    };
    query?: never;
    url: '/v1/billing/subscriptions/{org_id}/subscription/{subscription_id}';
};

export type GetOrgSubscriptionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetOrgSubscriptionError = GetOrgSubscriptionErrors[keyof GetOrgSubscriptionErrors];

export type GetOrgSubscriptionResponses = {
    /**
     * Successful Response
     */
    200: GraphSubscriptionResponse;
};

export type GetOrgSubscriptionResponse = GetOrgSubscriptionResponses[keyof GetOrgSubscriptionResponses];

export type CancelOrgSubscriptionData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
        /**
         * Subscription Id
         */
        subscription_id: string;
    };
    query?: never;
    url: '/v1/billing/subscriptions/{org_id}/subscription/{subscription_id}/cancel';
};

export type CancelOrgSubscriptionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CancelOrgSubscriptionError = CancelOrgSubscriptionErrors[keyof CancelOrgSubscriptionErrors];

export type CancelOrgSubscriptionResponses = {
    /**
     * Successful Response
     */
    200: GraphSubscriptionResponse;
};

export type CancelOrgSubscriptionResponse = CancelOrgSubscriptionResponses[keyof CancelOrgSubscriptionResponses];

export type ListOrgInvoicesData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: {
        /**
         * Limit
         *
         * Number of invoices to return
         */
        limit?: number;
    };
    url: '/v1/billing/invoices/{org_id}';
};

export type ListOrgInvoicesErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type ListOrgInvoicesError = ListOrgInvoicesErrors[keyof ListOrgInvoicesErrors];

export type ListOrgInvoicesResponses = {
    /**
     * Successful Response
     */
    200: InvoicesResponse;
};

export type ListOrgInvoicesResponse = ListOrgInvoicesResponses[keyof ListOrgInvoicesResponses];

export type GetOrgUpcomingInvoiceData = {
    body?: never;
    path: {
        /**
         * Org Id
         */
        org_id: string;
    };
    query?: never;
    url: '/v1/billing/invoices/{org_id}/upcoming';
};

export type GetOrgUpcomingInvoiceErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetOrgUpcomingInvoiceError = GetOrgUpcomingInvoiceErrors[keyof GetOrgUpcomingInvoiceErrors];

export type GetOrgUpcomingInvoiceResponses = {
    /**
     * Response Getorgupcominginvoice
     *
     * Successful Response
     */
    200: UpcomingInvoice | null;
};

export type GetOrgUpcomingInvoiceResponse = GetOrgUpcomingInvoiceResponses[keyof GetOrgUpcomingInvoiceResponses];

export type CreateCheckoutSessionData = {
    body: CreateCheckoutRequest;
    path?: never;
    query?: never;
    url: '/v1/billing/checkout';
};

export type CreateCheckoutSessionErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type CreateCheckoutSessionError = CreateCheckoutSessionErrors[keyof CreateCheckoutSessionErrors];

export type CreateCheckoutSessionResponses = {
    /**
     * Successful Response
     */
    201: CheckoutResponse;
};

export type CreateCheckoutSessionResponse = CreateCheckoutSessionResponses[keyof CreateCheckoutSessionResponses];

export type GetCheckoutStatusData = {
    body?: never;
    path: {
        /**
         * Session Id
         */
        session_id: string;
    };
    query?: never;
    url: '/v1/billing/checkout/{session_id}/status';
};

export type GetCheckoutStatusErrors = {
    /**
     * Validation Error
     */
    422: HttpValidationError;
};

export type GetCheckoutStatusError = GetCheckoutStatusErrors[keyof GetCheckoutStatusErrors];

export type GetCheckoutStatusResponses = {
    /**
     * Successful Response
     */
    200: CheckoutStatusResponse;
};

export type GetCheckoutStatusResponse = GetCheckoutStatusResponses[keyof GetCheckoutStatusResponses];
